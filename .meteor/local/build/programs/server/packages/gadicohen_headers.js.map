{"version":3,"sources":["gadicohen:headers/lib/headers-common.js","gadicohen:headers/lib/headers-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,W;AACA,U;AACA,e;AACA,sC;AACA,qC;AACA,+B;AACA,G;AACA,4B;AACA,yB;AACA,G;AACA,6C;AACA,iB;AACA,sE;AACA,sE;AACA,uE;AACA,wD;AACA,E;AACA,C;;;;;;;;;;;;;;;;;;;ACjBA,gD;AACA,iE;;AAEA,2B;AACA,iD;AACA,8D;AACA,yC;;AAEA,wD;AACA,iE;AACA,qC;AACA,kE;;AAEA,E;AACA,+E;AACA,sE;AACA,G;AACA,uC;AACA,iB;AACA,iC;AACA,gE;AACA,2C;AACA,O;AACA,+E;AACA,yC;AACA,e;AACA,C;;AAEA,E;AACA,0E;AACA,0E;AACA,mE;AACA,G;AACA,gB;AACA,mC;AACA,wB;AACA,8B;AACA,sD;AACA,yC;AACA,gC;;AAEA,+D;AACA,iE;AACA,+D;AACA,8D;AACA,oC;AACA,K;AACA,G;AACA,G;;AAEA,E;AACA,4B;AACA,I;AACA,+B;AACA,2B;AACA,oE;AACA,gC;AACA,yB;;AAEA,E;AACA,8C;AACA,G;AACA,yB;AACA,qB;AACA,0C;AACA,uB;AACA,C;AACA,C;AACA,E;AACA,4C;AACA,G;AACA,oC;AACA,0E;AACA,6E;AACA,iE;AACA,8E;AACA,C;;AAEA,E;AACA,8D;AACA,G;AACA,mC;AACA,yB;AACA,uG;;AAEA,kC;AACA,4C;AACA,gC;;AAEA,Y;AACA,kD;AACA,0B;AACA,C;;AAEA,gC;AACA,2B;AACA,uG;AACA,kC;AACA,qD;AACA,C;;AAEA,kD;AACA,iC;AACA,sD;AACA,0C;AACA,0C;AACA,iC;AACA,G;AACA,8C;AACA,C;;AAEA,E;AACA,mE;AACA,G;AACA,4C;AACA,8B;AACA,+B;;AAEA,wB;AACA,oB;AACA,yD;AACA,kD;AACA,2D;AACA,oF;AACA,uB;AACA,iD;AACA,iC;AACA,gE;AACA,2C;AACA,O;AACA,G;;AAEA,mC;AACA,6B;AACA,4D;;AAEA,4C;AACA,C;;AAEA,E;AACA,0E;AACA,G;AACA,qD;AACA,oC;AACA,iD;AACA,0C;AACA,0C;AACA,iC;AACA,G;AACA,8C;AACA,C;;;AAGA,sD;AACA,kC;AACA,e;;AAEA,0B;AACA,4C;AACA,qD;AACA,8B;;AAEA,a;AACA,C;;AAEA,E;AACA,0E;AACA,wE;AACA,wE;AACA,4B;AACA,G;AACA,0E;AACA,8B;AACA,+B;;AAEA,6E;AACA,oC;AACA,yC;;AAEA,yB;AACA,2C;;AAEA,mE;AACA,uD;AACA,6C;AACA,G;;AAEA,uC;AACA,sB;AACA,qD;AACA,8B;AACA,iB;AACA,iD;AACA,K;AACA,2B;AACA,6C;;AAEA,+E;AACA,6C;AACA,2C;;AAEA,8C;AACA,G;AACA,S;AACA,G","file":"/packages/gadicohen_headers.js","sourcesContent":["headers = {\n\tlist: {},\n\tproxyCount: 0,\n\tsetProxyCount: function(proxyCount) {\n\t    this.proxyCountDeprecated(true);\n\t\tthis.proxyCount = proxyCount;\n\t},\n\tgetProxyCount: function() {\n\t\treturn this.proxyCount;\n\t},\n\tproxyCountDeprecated: function(proxyCount) {\n\t\tif (proxyCount)\n\t\tconsole.log('Specifying the proxyCount is deprecated.  By default, '\n\t\t\t+ 'we now use the HTTP_FORWARDED_COUNT environment variable which '\n\t\t\t+ 'is used by Meteor 0.7.1+ too (and set by default in development '\n\t\t\t+ 'environment and meteor.com with correct values.');\n\t}\n}\n","var HEADERS_CLEANUP_TIME = 300000;  // 5 minutes\nvar FILTERED_HEADERS = ['user-agent', 'cookie', 'authorization'];\n\n// be helpful on meteor.com\nif (process.env.ROOT_URL.match(/meteor.com$/i) &&\n      typeof(process.env.HTTP_FORWARDED_COUNT) == 'undefined')\n    process.env.HTTP_FORWARDED_COUNT = 1;\n\n// Since Meteor 0.7.1, replaces headers.setProxy(count);\n// +1 is for our strategy of always adding the host to x-ip-chain\nif (process.env.HTTP_FORWARDED_COUNT)\n  headers.proxyCount = parseInt(process.env.HTTP_FORWARDED_COUNT);\n\n/*\n * Returns an array describing the suspected IP route the connection has taken.\n * This is in order of trust, see the README.md for which value to use\n */\nfunction ipChain(headers, connection) {\n  var chain = [];\n  if (headers['x-forwarded-for'])\n    _.each(headers['x-forwarded-for'].split(','), function(ip) {\n      chain.push(ip.replace('/\\s*/g', ''));\n    });\n//  if (chain.length == 0 || chain[chain.length-1] != connection.remoteAddress)\n    chain.push(connection.remoteAddress);\n  return chain;\n}\n\n/*\n * After user has requested the headers (which were stored in headers.list\n * at the same time with the client's token, the below is called, which we\n * use to re-associate with the user's livedata session (see above)\n */\nMeteor.methods({\n  'headersToken': function(token) {\n  \tcheck(token, Number);\n    if (headers.list[token]) {\n      var data = this.connection || this._sessionData;\n      data.headers = headers.list[token];\n      headerDep(data).changed();\n\n      // Don't do this until Meteor resumes sessions.  Consider\n      // longer cleanup time, and keeping last reassocation time.\n      // Or on disconnect, put back in the list with disconnect\n      // time and keep that for cleanup_time (can do in 0.7+).\n      // delete headers.list[token];\n    }\n  }\n});\n\n/*\n * Cleanup unclaimed headers\n */ \nMeteor.setInterval(function() {\n  for (key in headers.list)\n    if (parseInt(key) < new Date().getTime() - HEADERS_CLEANUP_TIME)\n      delete(headers.list[key]);\n}, HEADERS_CLEANUP_TIME);\n\n/*\n * Return the headerDep.  Create if necessary.\n */\nfunction headerDep(obj) {\n  if (!obj.headerDep)\n    obj.headerDep = new Deps.Dependency();\n  return obj.headerDep;\n}\n \n/*\n * Provide helpful hints for incorrect usage\n */\nfunction checkSelf(self, funcName) {\n  if (!self || (!self.connection && !self._session && !self._sessionData))\n    throw new Error('Call headers.' + funcName + '(this) only from within a '\n    \t+ 'method or publish function.  With callbacks / anonymous '\n    \t+ 'functions, use: var self=this; and call headers.'+funcName+'(self);');\n}\n\n/*\n * Usage in a Meteor method/publish: headers.get(this, 'host')\n */\nheaders.get = function(self, key) {\n  checkSelf(self, 'get');\n  var sessionData = self.connection || (self._session ? self._session.sessionData : self._sessionData);\n\n  headerDep(sessionData).depend();\n  if (!(sessionData && sessionData.headers))\n    return key ? undefined : {};\n\n  return key\n    ? sessionData.headers[key.toLocaleLowerCase()]\n    : sessionData.headers;\n}\n\nheaders.ready = function(self) {\n  checkSelf(self, 'ready');\n  var sessionData = self.connection || (self._session ? self._session.sessionData : self._sessionData);\n  headerDep(sessionData).depend();\n  return Object.keys(sessionData.headers).length > 0;\n}\n\nheaders.getClientIP = function(self, proxyCount) {\n  checkSelf(self, 'getClientIP');\n  var chain = this.get(self, 'x-ip-chain').split(',');\n  if (typeof(proxyCount) == 'undefined') {\n    this.proxyCountDeprecated(proxyCount);\n    proxyCount = this.proxyCount;\n  }\n  return chain[chain.length - proxyCount - 1];\n}\n\n/*\n * Retrieve header(s) for the current method socket (see README.md)\n */\nheaders.methodGet = function(self, header) {\n  var session, headers, chain;\n  checkSelf(self, 'methodGet');\n\n  if (self.connection) {\n    // Meteor 0.6.7+\n    session = Meteor.server.sessions[self.connection.id];\n  } else if (self._session || self._sessionData) {\n    // convoluted way to find our session in Meteor < 0.6.7\n    var sessionData = self._session ? self._session.sessionData : self._sessionData;\n    var token, session;\n    token = new Date().getTime() + Math.random();\n    sessionData.tmpToken = token;\n    session = _.find(Meteor.server.sessions, function(session) {\n      return sessionData.tmpToken == token;\n    });\n  }\n\n  headers = session.socket.headers;\n  if (!headers['x-ip-chain'])\n\t  headers['x-ip-chain'] = ipChain(headers, session.socket);\n\n  return header ? headers[header] : headers;\n}\n\n/*\n * Get the IP for the livedata connection used by a Method (see README.md)\n */\nheaders.methodClientIP = function(self, proxyCount) {\n  checkSelf(self, 'methodClientIP');\n  var chain = this.methodGet(self, 'x-ip-chain');\n  if (typeof(proxyCount) == 'undefined') {\n    this.proxyCountDeprecated(proxyCount);\n    proxyCount = this.proxyCount;\n  }\n  return chain[chain.length - proxyCount - 1];\n}\n\n\n// What's safe + necessary to send back to the client?\nvar filtered = function(headers) {\n  var out = {};\n\n  for (var key in headers)\n    if (FILTERED_HEADERS.indexOf(key) === -1\n        && !headers[key].match(/<\\/?\\s*script\\s*>/i))\n      out[key] = headers[key];\n\n  return out;\n}\n\n/*\n * The client will request this \"script\", and send a unique token with it,\n * which we later use to re-associate the headers from this request with\n * the user's livedata session (since XHR requests only send a subset of\n * all the regular headers).\n */\nWebApp.connectHandlers.use('/headersHelper.js', function(req, res, next) {\n  var token = req.query.token;\n  var mhData = { headers: {} };\n\n  req.headers['x-ip-chain'] = ipChain(req.headers, req.connection).join(',');\n  headers.list[token] = req.headers;\n  mhData.headers = filtered(req.headers);\n\n  if (headers.proxyCount)\n    mhData.proxyCount = headers.proxyCount;\n\n  res.writeHead(200, { 'Content-type': 'application/javascript' });\n  res.end(\"Package['gadicohen:headers'].headers.store(\"\n    + JSON.stringify(mhData) + \");\", 'utf8');\n});\n\n// Can only inject headers w/o appcache\nif (!Package.appcache)\nWebApp.connectHandlers.use(function(req, res, next) {\n  if(Inject.appUrl(req.url)) {\n  \tvar mhData = {\n      token: new Date().getTime() + Math.random()\n    }\n    if (headers.proxyCount)\n      mhData.proxyCount = headers.proxyCount;\n\n    req.headers['x-ip-chain'] = ipChain(req.headers, req.connection).join(',');\n    headers.list[mhData.token] = req.headers;\n    mhData.headers = filtered(req.headers);\n\n    Inject.obj('meteor-headers', mhData, res);\n  }\n  next();\n});\n\n"]}