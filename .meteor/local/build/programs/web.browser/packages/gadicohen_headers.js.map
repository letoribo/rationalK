)]}'
{"version":3,"sources":["gadicohen:headers/lib/headers-common.js","gadicohen:headers/lib/headers-client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,W;AACA,U;AACA,e;AACA,sC;AACA,qC;AACA,+B;AACA,G;AACA,4B;AACA,yB;AACA,G;AACA,6C;AACA,iB;AACA,sE;AACA,sE;AACA,uE;AACA,wD;AACA,E;AACA,C;;;;;;;;;;;;;;;;;;;ACjBA,E;AACA,0B;AACA,G;AACA,qD;;AAEA,E;AACA,sB;AACA,G;AACA,kC;;AAEA,E;AACA,uE;AACA,6D;AACA,G;AACA,kC;AACA,4B;AACA,uB;AACA,sC;AACA,yD;AACA,6C;AACA,qB;AACA,yB;AACA,qB;AACA,E;;AAEA,8D;AACA,yB;AACA,8B;AACA,mD;AACA,6C;AACA,E;AACA,G;;AAEA,E;AACA,oE;AACA,iC;AACA,E;AACA,0E;AACA,0E;AACA,G;AACA,qB;AACA,2B;AACA,oC;AACA,gB;AACA,8B;AACA,qE;AACA,sB;AACA,c;AACA,S;AACA,oB;AACA,2C;AACA,E;AACA,E;;AAEA,kD;AACA,kB;AACA,wE;AACA,4B;AACA,qB;AACA,Q;AACA,uE;AACA,G;AACA,wE;AACA,wE;AACA,oD;AACA,G;AACA,kB;AACA,gC;AACA,0C;AACA,wD;AACA,qC;AACA,wB;AACA,C;;AAEA,E;AACA,8B;AACA,G;AACA,gC;AACA,oB;AACA,mE;AACA,C;;AAEA,E;AACA,8C;AACA,G;AACA,4C;AACA,+C;AACA,uC;AACA,+B;AACA,6C;AACA,C","file":"/packages/gadicohen_headers.js","sourcesContent":["headers = {\n\tlist: {},\n\tproxyCount: 0,\n\tsetProxyCount: function(proxyCount) {\n\t    this.proxyCountDeprecated(true);\n\t\tthis.proxyCount = proxyCount;\n\t},\n\tgetProxyCount: function() {\n\t\treturn this.proxyCount;\n\t},\n\tproxyCountDeprecated: function(proxyCount) {\n\t\tif (proxyCount)\n\t\tconsole.log('Specifying the proxyCount is deprecated.  By default, '\n\t\t\t+ 'we now use the HTTP_FORWARDED_COUNT environment variable which '\n\t\t\t+ 'is used by Meteor 0.7.1+ too (and set by default in development '\n\t\t\t+ 'environment and meteor.com with correct values.');\n\t}\n}\n","/*\n * Generate a unique token\n */\nheaders.token = new Date().getTime() + Math.random();\n\n/*\n * Used for reactivity\n */\nheaders.dep = new Deps.Dependency;\n\n/*\n * Called after receiving all the headers, used to re-associate headers\n * with this clients livedata session (see headers-server.js)\n */\nheaders.store = function(mhData) {\n\tthis.list = mhData.headers;\n\tif (mhData.proxyCount)\n\t\tthis.proxyCount = mhData.proxyCount;\n\tMeteor.call('headersToken', mhData.token || this.token);\n \tfor (var i=0; i < this.readies.length; i++)\n \t\tthis.readies[i]();\n \tthis.readiesRun = true;\n \tthis.dep.changed();\n};\n\n// On each disconnect, queue reassociation for next connection\nDeps.autorun(function() {\n\tvar status = Meteor.status();\n\tif (!status.connected && status.retryCount == 0) {\n\t\tMeteor.call('headersToken', headers.token);\n\t}\n});\n\n/*\n * This has two completely different uses, but retains the same name\n * as this is what people expect.\n *\n * With an arg: Store a callback to be run when headersHelper.js completes\n * Without an arg: Return a reactive boolean on whether or not we're ready\n */\nheaders.readies = [];\nheaders.readiesRun = false;\nheaders.ready = function(callback) {\n\tif (callback) {\n\t\tthis.readies.push(callback);\n\t\t// Run immediately if headers.store() was already called previously\n\t\tif (this.readiesRun)\n\t\t\tcallback();\n\t} else {\n\t\tthis.dep.depend();\n\t\treturn Object.keys(this.list).length > 0;\n\t}\n};\n\nvar __headers__ = Inject.getObj('meteor-headers');\nif (__headers__) {\n\t// Since 0.0.13, headers are available before this package is loaded :)\n\theaders.store(__headers__);\n\tdelete(__headers__);\n} else {\n\t// Except in tests, browserPolicy disallowInlineScripts() and appcache\n\t/*\n \t* Create another connection to retrieve our headers (see README.md for\n \t* why this is necessary).  Called with our unique token, the retrieved\n \t* code runs headers.store() above with the results\n\t*/\n\t(function(d, t) {\n\t    var g = d.createElement(t),\n\t        s = d.getElementsByTagName(t)[0];\n\t    g.src = '/headersHelper.js?token=' + headers.token;\n\t    s.parentNode.insertBefore(g, s);\n\t}(document, 'script'));\n}\n\n/*\n * Get a header or all headers\n */\nheaders.get = function(header) {\n \tthis.dep.depend();\n\treturn header ? this.list[header.toLocaleLowerCase()] : this.list;\n}\n\n/*\n * Get the client's IP address (see README.md)\n */\nheaders.getClientIP = function(proxyCount) {\n\tvar chain = this.get('x-ip-chain').split(',');\n\tif (typeof(proxyCount) == 'undefined')\n\t\tproxyCount = this.proxyCount;\n\treturn chain[chain.length - proxyCount - 1];\n}\n"]}