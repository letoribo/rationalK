)]}'
{"version":3,"sources":["gadicohen:messageformat/lib/messageformat.js/messageformat.js","gadicohen:messageformat/lib/mfPkg/messageformat.js","gadicohen:messageformat/lib/mfPkg/locale-all.js","gadicohen:messageformat/lib/mfPkg/messageformat.html","gadicohen:messageformat/lib/mfPkg/messageformat-client.js","gadicohen:messageformat/lib/mfPkg/3rdparty/taboverride.js","gadicohen:messageformat/lib/mfPkg/3rdparty/taboverride.jquery.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,mB;AACA,E;AACA,iD;AACA,E;AACA,mC;AACA,iB;AACA,iB;AACA,gC;AACA,E;AACA,oB;;AAEA,mC;AACA,iD;AACA,uB;;AAEA,iC;AACA,kD;AACA,K;;AAEA,e;AACA,6C;AACA,wH;;AAEA,yB;AACA,2E;AACA,K;;AAEA,qB;AACA,iC;AACA,yB;AACA,yC;AACA,G;;AAEA,yD;AACA,0B;AACA,2B;AACA,sB;AACA,qB;AACA,O;AACA,qB;AACA,K;AACA,I;;AAEA,wC;AACA,mD;AACA,iD;AACA,yB;AACA,I;;AAEA,6D;AACA,kC;AACA,I;;AAEA,yB;AACA,8C;AACA,sD;AACA,yD;AACA,4D;AACA,qD;AACA,oI;AACA,S;AACA,M;AACA,0C;AACA,oB;AACA,wB;AACA,uB;AACA,Y;AACA,8B;AACA,6B;AACA,sC;AACA,0C;AACA,Y;;AAEA,6D;AACA,yD;AACA,iC;AACA,O;AACA,uD;AACA,kB;AACA,O;;AAEA,wC;AACA,sB;AACA,O;AACA,oD;AACA,M;AACA,2C;AACA,8D;;AAEA,iE;AACA,iE;AACA,yE;AACA,kC;AACA,sB;AACA,S;AACA,O;;AAEA,oB;AACA,K;AACA,I;;AAEA,kD;AACA,4B;AACA,M;AACA,iC;AACA,M;AACA,6B;AACA,O;AACA,I;AACA,uB;AACA,Q;AACA,2E;AACA,0E;AACA,6E;AACA,oE;AACA,Q;AACA,yE;AACA,0E;AACA,kE;AACA,S;AACA,qB;AACA,6C;AACA,2D;AACA,6C;AACA,kD;AACA,6C;AACA,6C;AACA,mD;AACA,gE;AACA,c;AACA,K;AACA,I;AACA,kB;AACA,Q;AACA,iF;AACA,+E;AACA,kF;AACA,4E;AACA,S;AACA,yC;AACA,8B;AACA,+B;AACA,6D;AACA,uE;AACA,6D;AACA,+C;AACA,2C;AACA,2C;AACA,2D;AACA,+C;AACA,2D;AACA,2C;AACA,uC;AACA,iC;AACA,yB;AACA,+B;AACA,6B;AACA,iC;AACA,qC;AACA,uB;AACA,wC;AACA,U;AACA,Q;AACA,sC;AACA,wD;AACA,4E;AACA,W;AACA,gB;AACA,8B;AACA,S;AACA,Q;AACA,oB;AACA,+B;AACA,qC;AACA,2C;AACA,Q;AACA,kD;AACA,6B;AACA,U;AACA,gD;AACA,+C;AACA,sC;AACA,W;AACA,U;AACA,wB;AACA,S;AACA,Q;AACA,6B;AACA,0C;AACA,yB;AACA,qB;AACA,U;AACA,iC;AACA,6B;AACA,uB;AACA,kB;AACA,6B;AACA,uB;AACA,W;AACA,U;AACA,+F;AACA,S;AACA,Q;AACA,uC;AACA,2C;AACA,mB;AACA,W;AACA,U;AACA,2C;AACA,uC;AACA,2C;AACA,W;AACA,U;AACA,kD;AACA,S;AACA,Q;AACA,gC;AACA,sB;AACA,mB;AACA,U;AACA,qB;AACA,iD;AACA,iC;AACA,6I;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,+C;AACA,wC;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,mC;AACA,iC;AACA,yB;AACA,wD;AACA,sC;AACA,oC;AACA,0D;AACA,a;AACA,mC;AACA,2C;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,oD;AACA,0B;AACA,mC;AACA,8B;AACA,e;AACA,oC;AACA,kD;AACA,wC;AACA,iB;AACA,e;AACA,sE;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,oD;AACA,mE;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,8C;AACA,0B;AACA,kB;AACA,kB;AACA,2B;AACA,uC;AACA,mC;AACA,a;AACA,W;AACA,iC;AACA,gC;AACA,mC;AACA,qD;AACA,qC;AACA,oC;AACA,uC;AACA,sD;AACA,kC;AACA,0B;AACA,0B;AACA,mC;AACA,+C;AACA,2C;AACA,qB;AACA,mB;AACA,yC;AACA,6C;AACA,2C;AACA,uF;AACA,4B;AACA,qC;AACA,iC;AACA,qB;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,kD;AACA,2B;AACA,0B;AACA,8B;AACA,e;AACA,mC;AACA,+B;AACA,e;AACA,6E;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,+C;AACA,wC;AACA,+B;AACA,U;AACA,qB;AACA,qB;AACA,+B;AACA,iC;AACA,uB;AACA,+C;AACA,4B;AACA,oB;AACA,oB;AACA,6B;AACA,yC;AACA,qC;AACA,e;AACA,a;AACA,mC;AACA,8C;AACA,qC;AACA,6C;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,sD;AACA,mC;AACA,2C;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,uD;AACA,0B;AACA,6C;AACA,qC;AACA,gB;AACA,0C;AACA,4C;AACA,e;AACA,oB;AACA,kC;AACA,e;AACA,yB;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,wC;AACA,4E;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,8B;AACA,iC;AACA,oD;AACA,iC;AACA,uB;AACA,oB;AACA,6B;AACA,yC;AACA,0C;AACA,e;AACA,a;AACA,mC;AACA,kC;AACA,qC;AACA,mD;AACA,gC;AACA,wB;AACA,wB;AACA,iC;AACA,6C;AACA,yC;AACA,mB;AACA,iB;AACA,uC;AACA,sC;AACA,yC;AACA,kD;AACA,2C;AACA,0C;AACA,6C;AACA,kG;AACA,8B;AACA,uC;AACA,mC;AACA,uB;AACA,4B;AACA,qC;AACA,iC;AACA,qB;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,+C;AACA,sB;AACA,uC;AACA,yB;AACA,4B;AACA,gB;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,iC;AACA,uB;AACA,uB;AACA,gC;AACA,mC;AACA,sD;AACA,mC;AACA,yB;AACA,sB;AACA,+B;AACA,2C;AACA,4C;AACA,iB;AACA,e;AACA,qC;AACA,oC;AACA,uC;AACA,qD;AACA,kC;AACA,0B;AACA,0B;AACA,mC;AACA,+C;AACA,2C;AACA,qB;AACA,mB;AACA,yC;AACA,wC;AACA,2C;AACA,oD;AACA,6C;AACA,4C;AACA,+C;AACA,oG;AACA,gC;AACA,yC;AACA,qC;AACA,yB;AACA,8B;AACA,uC;AACA,mC;AACA,uB;AACA,4B;AACA,qC;AACA,iC;AACA,qB;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,mC;AACA,iD;AACA,wB;AACA,yC;AACA,2B;AACA,8B;AACA,kB;AACA,+C;AACA,a;AACA,mC;AACA,yB;AACA,a;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,sC;AACA,sB;AACA,mB;AACA,U;AACA,qB;AACA,gD;AACA,iC;AACA,8C;AACA,uD;AACA,8B;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,sC;AACA,sB;AACA,mB;AACA,U;AACA,qB;AACA,gD;AACA,iC;AACA,8C;AACA,uD;AACA,8B;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,8C;AACA,wC;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,0C;AACA,oD;AACA,iC;AACA,yB;AACA,0C;AACA,sC;AACA,oC;AACA,4C;AACA,a;AACA,mC;AACA,2C;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,iD;AACA,yB;AACA,4C;AACA,+B;AACA,gB;AACA,yB;AACA,gC;AACA,e;AACA,oB;AACA,+B;AACA,e;AACA,yB;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,wC;AACA,4E;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,8B;AACA,iC;AACA,oD;AACA,iC;AACA,uB;AACA,oB;AACA,6B;AACA,yC;AACA,0C;AACA,e;AACA,a;AACA,mC;AACA,kC;AACA,qC;AACA,mD;AACA,gC;AACA,wB;AACA,wB;AACA,iC;AACA,6C;AACA,yC;AACA,mB;AACA,iB;AACA,uC;AACA,sC;AACA,yC;AACA,6C;AACA,2C;AACA,0C;AACA,6C;AACA,kG;AACA,8B;AACA,uC;AACA,mC;AACA,uB;AACA,4B;AACA,qC;AACA,iC;AACA,qB;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,4C;AACA,uB;AACA,iC;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,8C;AACA,+B;AACA,mB;AACA,U;AACA,qB;AACA,uB;AACA,wC;AACA,oC;AACA,kC;AACA,0C;AACA,W;AACA,iC;AACA,6C;AACA,sB;AACA,4C;AACA,+B;AACA,gB;AACA,8B;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,sC;AACA,qF;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,8B;AACA,iC;AACA,wC;AACA,mC;AACA,kC;AACA,qC;AACA,oD;AACA,gC;AACA,wB;AACA,wB;AACA,iC;AACA,6C;AACA,yC;AACA,mB;AACA,iB;AACA,uC;AACA,sC;AACA,yC;AACA,2D;AACA,2C;AACA,0C;AACA,6C;AACA,4D;AACA,wC;AACA,gC;AACA,gC;AACA,yC;AACA,qD;AACA,iD;AACA,2B;AACA,yB;AACA,+C;AACA,6G;AACA,gC;AACA,yC;AACA,qC;AACA,yB;AACA,8B;AACA,uC;AACA,mC;AACA,uB;AACA,4B;AACA,qC;AACA,iC;AACA,qB;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,iD;AACA,sB;AACA,oC;AACA,uB;AACA,wB;AACA,gB;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,oC;AACA,+B;AACA,yB;AACA,U;AACA,qB;AACA,+B;AACA,iC;AACA,4C;AACA,uB;AACA,8B;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,iC;AACA,uB;AACA,uB;AACA,+C;AACA,4B;AACA,oB;AACA,oB;AACA,6B;AACA,yC;AACA,qC;AACA,e;AACA,a;AACA,mC;AACA,uC;AACA,qC;AACA,6C;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,mC;AACA,8C;AACA,yB;AACA,mC;AACA,a;AACA,mC;AACA,yB;AACA,a;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,iC;AACA,0D;AACA,+B;AACA,U;AACA,qB;AACA,qB;AACA,8B;AACA,iC;AACA,yB;AACA,uB;AACA,gC;AACA,mC;AACA,sC;AACA,qC;AACA,oC;AACA,uC;AACA,wD;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,sC;AACA,oC;AACA,yB;AACA,kC;AACA,qC;AACA,wC;AACA,uC;AACA,sC;AACA,yC;AACA,0D;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,a;AACA,mC;AACA,2C;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,gD;AACA,2B;AACA,mD;AACA,0D;AACA,oC;AACA,iB;AACA,e;AACA,sB;AACA,+B;AACA,sC;AACA,gB;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,6B;AACA,iD;AACA,yB;AACA,U;AACA,qB;AACA,qB;AACA,8B;AACA,iC;AACA,wD;AACA,0C;AACA,oB;AACA,oB;AACA,6B;AACA,yC;AACA,0C;AACA,e;AACA,a;AACA,mC;AACA,2B;AACA,gE;AACA,4C;AACA,sB;AACA,sB;AACA,+B;AACA,2C;AACA,qD;AACA,iB;AACA,e;AACA,wC;AACA,sC;AACA,kE;AACA,8C;AACA,wB;AACA,wB;AACA,iC;AACA,6C;AACA,uD;AACA,mB;AACA,iB;AACA,e;AACA,qC;AACA,oC;AACA,uC;AACA,iE;AACA,wB;AACA,iC;AACA,6B;AACA,iB;AACA,sB;AACA,+B;AACA,2B;AACA,e;AACA,oB;AACA,6B;AACA,yB;AACA,a;AACA,kB;AACA,2B;AACA,uB;AACA,W;AACA,iC;AACA,iD;AACA,kD;AACA,6C;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,gC;AACA,+B;AACA,mB;AACA,U;AACA,qB;AACA,iC;AACA,iC;AACA,yB;AACA,sC;AACA,oC;AACA,qC;AACA,a;AACA,kB;AACA,2B;AACA,W;AACA,iC;AACA,0F;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,+B;AACA,0D;AACA,yB;AACA,U;AACA,qB;AACA,kE;AACA,wC;AACA,kB;AACA,kB;AACA,2B;AACA,uC;AACA,2D;AACA,a;AACA,W;AACA,iC;AACA,4C;AACA,uB;AACA,8B;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,iC;AACA,uB;AACA,iD;AACA,8B;AACA,uB;AACA,oB;AACA,6B;AACA,yC;AACA,yC;AACA,e;AACA,a;AACA,mC;AACA,2C;AACA,6B;AACA,uB;AACA,a;AACA,mC;AACA,yB;AACA,a;AACA,mC;AACA,yB;AACA,mD;AACA,gC;AACA,yB;AACA,sB;AACA,+B;AACA,2C;AACA,2C;AACA,iB;AACA,e;AACA,qC;AACA,6C;AACA,kC;AACA,yB;AACA,e;AACA,qC;AACA,2B;AACA,e;AACA,qC;AACA,2B;AACA,qD;AACA,kC;AACA,2B;AACA,wB;AACA,iC;AACA,6C;AACA,6C;AACA,mB;AACA,iB;AACA,uC;AACA,+C;AACA,oC;AACA,2B;AACA,iB;AACA,uC;AACA,6B;AACA,iB;AACA,uC;AACA,6B;AACA,6B;AACA,uD;AACA,oC;AACA,6B;AACA,0B;AACA,mC;AACA,+C;AACA,+C;AACA,qB;AACA,mB;AACA,yC;AACA,+C;AACA,2C;AACA,iD;AACA,6C;AACA,mD;AACA,+C;AACA,qD;AACA,iD;AACA,oF;AACA,kC;AACA,2C;AACA,uC;AACA,2B;AACA,gC;AACA,yC;AACA,qC;AACA,yB;AACA,8B;AACA,uC;AACA,mC;AACA,uB;AACA,4B;AACA,qC;AACA,iC;AACA,qB;AACA,0B;AACA,mC;AACA,+B;AACA,mB;AACA,yC;AACA,iE;AACA,uF;AACA,6E;AACA,mB;AACA,yC;AACA,+B;AACA,mB;AACA,iB;AACA,e;AACA,a;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,iC;AACA,+B;AACA,mB;AACA,U;AACA,qB;AACA,iD;AACA,wC;AACA,kB;AACA,kB;AACA,2B;AACA,uC;AACA,mC;AACA,a;AACA,W;AACA,iC;AACA,yB;AACA,sC;AACA,oC;AACA,qD;AACA,4C;AACA,sB;AACA,sB;AACA,+B;AACA,2C;AACA,uC;AACA,iB;AACA,e;AACA,a;AACA,kB;AACA,2B;AACA,W;AACA,iC;AACA,6C;AACA,iD;AACA,8B;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,mC;AACA,sB;AACA,U;AACA,uD;AACA,wC;AACA,kB;AACA,kB;AACA,2B;AACA,uC;AACA,yC;AACA,a;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,4B;AACA,+B;AACA,mB;AACA,U;AACA,2B;AACA,qB;AACA,uB;AACA,uC;AACA,oC;AACA,kC;AACA,yC;AACA,W;AACA,iC;AACA,kF;AACA,W;AACA,iC;AACA,uB;AACA,W;AACA,2B;AACA,yD;AACA,sC;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,qC;AACA,sB;AACA,U;AACA,qD;AACA,wC;AACA,kB;AACA,kB;AACA,2B;AACA,uC;AACA,0C;AACA,a;AACA,W;AACA,yB;AACA,S;AACA,Q;AACA,Q;AACA,4C;AACA,0B;AACA,U;AACA,kC;AACA,iC;AACA,qD;AACA,+C;AACA,8C;AACA,yC;AACA,a;AACA,W;AACA,+B;AACA,S;AACA,Q;AACA,yC;AACA,Y;AACA,kF;AACA,8E;AACA,gF;AACA,kC;AACA,a;AACA,U;AACA,uB;AACA,yB;AACA,6B;AACA,U;AACA,yE;AACA,qC;AACA,8B;AACA,sC;AACA,yB;AACA,6B;AACA,2E;AACA,qB;AACA,yB;AACA,4B;AACA,oB;AACA,uB;AACA,6B;AACA,a;AACA,W;AACA,U;AACA,gD;AACA,S;AACA,Q;AACA,Q;AACA,iD;AACA,Q;AACA,U;AACA,kE;AACA,U;AACA,6D;AACA,U;AACA,iC;AACA,sC;AACA,4E;AACA,U;AACA,sE;AACA,U;AACA,iC;AACA,oC;AACA,4E;AACA,U;AACA,0E;AACA,U;AACA,gC;AACA,0B;AACA,wE;AACA,U;AACA,4E;AACA,+B;AACA,W;AACA,sD;AACA,2D;AACA,0E;AACA,qD;AACA,U;AACA,qC;AACA,uD;AACA,kB;AACA,mB;AACA,+B;AACA,gC;AACA,Y;AACA,S;AACA,Q;AACA,sB;AACA,Q;AACA,M;AACA,2C;AACA,mD;AACA,M;AACA,I;AACA,yD;AACA,I;AACA,0E;AACA,8C;AACA,8C;AACA,Q;AACA,kC;AACA,iB;AACA,+C;AACA,kB;AACA,iB;AACA,4C;AACA,kB;AACA,kB;AACA,iF;AACA,sB;AACA,8C;AACA,S;AACA,Q;AACA,+D;AACA,Q;AACA,sF;AACA,O;AACA,M;AACA,gC;AACA,+B;AACA,yB;AACA,mD;AACA,2B;AACA,uB;AACA,2B;AACA,M;AACA,I;AACA,mD;AACA,I;AACA,kB;AACA,O;;AAEA,+C;AACA,6C;AACA,qD;AACA,I;;AAEA,yD;AACA,oB;AACA,0B;AACA,c;AACA,2C;AACA,2B;AACA,M;;AAEA,sC;AACA,8B;AACA,wB;AACA,sC;;AAEA,2B;AACA,uB;AACA,0C;AACA,oC;AACA,yD;AACA,sD;AACA,W;AACA,uC;AACA,yC;AACA,yD;AACA,sD;AACA,W;AACA,mB;AACA,oC;AACA,6C;AACA,8F;AACA,6B;AACA,0D;AACA,W;AACA,gB;AACA,uD;AACA,oE;AACA,qE;AACA,sD;AACA,W;AACA,mB;AACA,6B;AACA,uC;AACA,4C;AACA,8B;AACA,gC;AACA,+F;AACA,W;AACA,4C;AACA,4C;AACA,qF;AACA,sF;AACA,+B;AACA,8B;AACA,gC;AACA,6C;AACA,sC;AACA,0H;AACA,uB;AACA,W;AACA,mB;AACA,gC;AACA,2B;AACA,6B;AACA,mC;AACA,6C;AACA,+D;AACA,qD;AACA,2B;AACA,iG;;AAEA,0D;AACA,yD;AACA,gC;AACA,a;AACA,wB;AACA,yB;AACA,a;AACA,iB;AACA,sB;AACA,a;AACA,+F;AACA,sG;AACA,W;AACA,wB;AACA,4B;AACA,6F;AACA,W;AACA,mB;AACA,mC;;AAEA,6C;AACA,kD;AACA,qD;AACA,2B;;AAEA,0D;AACA,yD;AACA,gC;AACA,a;AACA,wB;AACA,yB;AACA,a;AACA,iB;AACA,sB;AACA,a;AACA,+F;AACA,0B;AACA,+D;AACA,+B;AACA,2B;AACA,kB;AACA,c;AACA,W;AACA,wB;AACA,4B;AACA,6F;AACA,W;AACA,mB;AACA,yB;AACA,2B;AACA,U;AACA,sB;AACA,uD;AACA,4D;AACA,qE;AACA,yB;AACA,qB;AACA,gB;AACA,yD;AACA,O;AACA,K;AACA,4B;AACA,I;;AAEA,0D;AACA,0C;AACA,iB;AACA,wB;AACA,+B;AACA,S;AACA,sB;AACA,I;;;AAGA,uC;AACA,0D;AACA,+C;AACA,K;AACA,0C;AACA,G;AACA,wD;AACA,uB;AACA,2B;AACA,O;AACA,G;AACA,Q;AACA,0C;AACA,G;;AAEA,W;;;;;;;;;;;;;;;;;;;ACxjDA,E;AACA,O;AACA,E;AACA,0B;AACA,uE;AACA,iE;AACA,E;AACA,yE;AACA,4C;AACA,c;AACA,0B;AACA,E;AACA,G;;;AAGA,S;AACA,sF;AACA,gB;AACA,iB;AACA,gB;AACA,a;AACA,mB;;AAEA,sB;AACA,sB;AACA,c;AACA,qB;AACA,M;;AAEA,qH;AACA,2H;AACA,4G;;AAEA,qC;AACA,6B;AACA,4B;AACA,4B;AACA,6C;AACA,Y;AACA,6C;AACA,M;;AAEA,M;AACA,sE;AACA,yC;AACA,O;AACA,yC;AACA,0C;AACA,8B;AACA,sC;AACA,kC;AACA,gD;;AAEA,uC;AACA,kC;AACA,mE;AACA,6C;AACA,iD;AACA,8C;AACA,kD;AACA,gD;AACA,uD;AACA,uC;AACA,qE;AACA,gD;AACA,uD;AACA,sD;AACA,6D;AACA,a;AACA,W;AACA,M;;AAEA,Y;AACA,iE;AACA,sB;AACA,8D;AACA,4D;AACA,6B;AACA,8C;AACA,kE;AACA,8C;AACA,e;AACA,U;AACA,4B;AACA,8C;AACA,iE;AACA,8C;AACA,e;AACA,S;AACA,K;AACA,C;;AAEA,4G;AACA,wG;AACA,8G;AACA,0G;AACA,+C;;AAEA,6C;AACA,mC;AACA,uC;AACA,gB;AACA,8B;AACA,6B;AACA,yB;AACA,sB;AACA,K;;AAEA,mC;AACA,c;AACA,+D;AACA,+D;AACA,oC;AACA,K;;AAEA,+C;AACA,oB;AACA,6F;AACA,gE;AACA,iD;AACA,kD;AACA,uD;AACA,Y;AACA,qC;;AAEA,sE;AACA,mD;AACA,gC;;AAEA,qE;AACA,K;;AAEA,S;AACA,oC;AACA,K;AACA,gB;AACA,uB;AACA,K;AACA,I;AACA,oB;AACA,C;;;AAGA,gE;AACA,2B;AACA,8C;AACA,yB;AACA,oC;AACA,wB;AACA,4B;AACA,+E;AACA,uC;AACA,gD;AACA,wE;AACA,wE;;AAEA,kC;AACA,wD;AACA,8D;AACA,uF;AACA,mG;AACA,2C;AACA,S;AACA,O;AACA,G;;;;;;;;;;;;;;;;;;;ACpKA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,uC;AACA,0B;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,uC;AACA,gB;AACA,kB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,gE;AACA,iB;AACA,G;AACA,iE;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,gB;AACA,kB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,mC;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,gB;AACA,kB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,0B;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,wB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,e;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,2C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,uC;AACA,0B;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,yC;AACA,iB;AACA,G;AACA,uC;AACA,iE;AACA,iB;AACA,G;AACA,2D;AACA,mE;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,uC;AACA,iB;AACA,E;AACA,uC;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,yC;AACA,gB;AACA,kB;AACA,G;AACA,uB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,uC;AACA,0B;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,4D;AACA,iB;AACA,G;AACA,uC;AACA,iE;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,gB;AACA,kB;AACA,G;AACA,yC;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,iC;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,4C;AACA,8C;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,4E;AACA,iB;AACA,G;AACA,iE;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,uC;AACA,iE;AACA,iB;AACA,G;AACA,kD;AACA,+E;AACA,2B;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,4C;AACA,8C;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,yC;AACA,iB;AACA,G;AACA,uC;AACA,iE;AACA,iB;AACA,G;AACA,2D;AACA,mE;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,yB;AACA,iB;AACA,G;AACA,gD;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,e;AACA,iB;AACA,G;AACA,mC;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,uB;AACA,iB;AACA,G;AACA,uB;AACA,iB;AACA,G;AACA,yC;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,wC;AACA,yC;AACA,iB;AACA,G;AACA,uC;AACA,iE;AACA,iB;AACA,G;AACA,2D;AACA,mE;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,uC;AACA,0B;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,uC;AACA,iB;AACA,E;AACA,wC;AACA,yC;AACA,iB;AACA,G;AACA,uC;AACA,iE;AACA,iB;AACA,G;AACA,2D;AACA,mE;AACA,kB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,kB;AACA,iB;AACA,G;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;AACA,0C;AACA,iB;AACA,E;;;;;;;;;;;;;;;;;;;;AC/eA,2B;AACA,0D;AACA,kB;AACA,gC;AACA,mG;AACA,K;AACA,I;;AAEA,gC;AACA,oE;AACA,kB;AACA,mB;AACA,yB;AACA,0B;AACA,2C;AACA,8F;AACA,wE;AACA,qD;AACA,oC;AACA,4E;AACA,kD;AACA,wE;AACA,iB;AACA,mC;AACA,wB;AACA,4R;AACA,0E;AACA,mB;AACA,0D;AACA,0B;AACA,4E;AACA,S;AACA,gC;AACA,uD;AACA,qD;AACA,wD;AACA,oD;AACA,+D;AACA,oD;AACA,wD;AACA,oD;AACA,+D;AACA,oD;AACA,0D;AACA,oD;AACA,iE;AACA,kD;AACA,sC;AACA,2B;AACA,+D;AACA,S;AACA,oB;AACA,sC;AACA,2B;AACA,+D;AACA,S;AACA,oB;AACA,wC;AACA,2B;AACA,iE;AACA,S;AACA,yC;AACA,4F;AACA,mB;AACA,2B;AACA,mC;AACA,6B;AACA,qB;AACA,6B;AACA,iB;AACA,4D;AACA,oB;AACA,iC;AACA,0T;AACA,iB;AACA,0M;AACA,8C;AACA,wD;AACA,a;AACA,I;;AAEA,oC;AACA,4E;AACA,kB;AACA,mB;AACA,yB;AACA,qB;AACA,yB;AACA,wB;AACA,iI;AACA,mD;AACA,wE;AACA,oD;AACA,gE;AACA,0B;AACA,kF;AACA,kD;AACA,iB;AACA,kC;AACA,8B;AACA,sD;AACA,Q;AACA,2B;AACA,oH;AACA,O;AACA,mD;AACA,qD;AACA,qD;AACA,sD;AACA,kC;AACA,qK;AACA,4E;AACA,sC;AACA,6E;AACA,kC;AACA,6E;AACA,2B;AACA,6E;AACA,iB;AACA,sD;AACA,+E;AACA,mB;AACA,kC;AACA,0B;AACA,uF;AACA,S;AACA,gC;AACA,qF;AACA,Y;AACA,mB;AACA,2C;AACA,qF;AACA,gB;AACA,c;AACA,2B;AACA,yE;AACA,iB;AACA,0C;AACA,+E;AACA,S;AACA,oD;AACA,sB;AACA,iB;AACA,uB;AACA,4D;AACA,K;AACA,6B;AACA,sB;AACA,uB;AACA,6D;AACA,K;AACA,2G;AACA,I;;AAEA,0C;AACA,wF;AACA,kB;AACA,mB;AACA,yB;AACA,qB;AACA,4C;AACA,mF;AACA,6C;AACA,+J;AACA,c;AACA,I;;;;;;;;;;;;;;;;;;;ACtKA,E;AACA,yE;AACA,wE;AACA,yE;AACA,e;AACA,G;AACA,iD;AACA,sE;AACA,2B;AACA,iC;AACA,iB;AACA,S;AACA,oC;AACA,qC;AACA,E;;AAEA,+D;AACA,E;AACA,wC;;AAEA,qB;AACA,uC;AACA,4B;AACA,qB;AACA,uD;AACA,yC;AACA,O;AACA,gI;AACA,G;AACA,6C;AACA,E;AACA,G;;AAEA,6B;AACA,+D;AACA,8C;AACA,c;AACA,e;;AAEA,wB;AACA,uC;;AAEA,4B;;AAEA,0B;AACA,c;AACA,oC;AACA,2C;AACA,0B;;AAEA,oE;AACA,qE;AACA,6E;AACA,gB;AACA,M;AACA,uC;AACA,I;;AAEA,yF;AACA,gC;AACA,2B;AACA,wD;AACA,K;AACA,C;;AAEA,E;AACA,+D;AACA,mE;AACA,G;AACA,oB;AACA,2B;AACA,+C;AACA,2B;AACA,0B;AACA,4D;AACA,Y;AACA,0B;;AAEA,8B;AACA,4C;AACA,iD;AACA,G;;AAEA,mD;AACA,e;AACA,c;;AAEA,6B;AACA,2B;AACA,I;AACA,E;;AAEA,E;AACA,oE;AACA,kE;AACA,wB;AACA,G;AACA,qC;AACA,0B;AACA,+D;AACA,uC;AACA,wB;AACA,c;AACA,C;;AAEA,E;AACA,gF;AACA,G;AACA,uC;AACA,6B;AACA,4B;AACA,0B;AACA,a;AACA,C;;AAEA,E;AACA,+D;AACA,2D;AACA,G;AACA,oC;AACA,+B;AACA,C;;AAEA,E;AACA,sE;AACA,sE;AACA,kE;AACA,qD;AACA,G;AACA,8C;AACA,a;AACA,gE;AACA,gD;AACA,mD;AACA,yC;AACA,wC;AACA,mB;AACA,S;AACA,M;AACA,C;AACA,0B;AACA,gE;;AAEA,kD;AACA,e;AACA,iC;AACA,M;AACA,4D;AACA,c;AACA,iE;AACA,a;;AAEA,kC;AACA,M;AACA,E;AACA,G;;AAEA,yB;AACA,8C;AACA,8B;AACA,6B;AACA,mC;AACA,+B;AACA,E;AACA,G;;AAEA,E;AACA,+E;AACA,gF;AACA,8E;AACA,sB;AACA,G;AACA,uB;AACA,oD;AACA,2C;AACA,wB;AACA,4B;AACA,mB;AACA,yC;AACA,kC;AACA,C;;AAEA,E;AACA,6D;AACA,G;AACA,sC;AACA,oD;AACA,6B;AACA,yC;AACA,M;AACA,6B;AACA,I;AACA,4B;AACA,C;;AAEA,E;AACA,gE;AACA,gE;AACA,G;AACA,4B;AACA,6C;AACA,gE;AACA,kD;AACA,oC;AACA,iD;AACA,E;AACA,C;;AAEA,E;AACA,uE;AACA,qE;AACA,mC;AACA,G;AACA,sC;AACA,yC;AACA,sB;AACA,I;AACA,uC;AACA,8B;AACA,I;;AAEA,kD;AACA,S;;AAEA,4C;AACA,a;AACA,W;AACA,a;AACA,8B;AACA,0B;AACA,6B;AACA,I;;AAEA,c;AACA,gD;AACA,c;AACA,c;AACA,+B;AACA,yB;AACA,6B;AACA,K;AACA,0B;AACA,Y;AACA,c;AACA,c;AACA,+B;AACA,+B;AACA,yB;AACA,K;AACA,C;;AAEA,E;AACA,sE;AACA,G;AACA,4B;AACA,4C;AACA,wC;AACA,8B;;AAEA,uD;;AAEA,wC;AACA,oC;AACA,6B;AACA,I;AACA,4C;;AAEA,mC;AACA,2B;AACA,C;;AAEA,2B;AACA,8C;AACA,uD;AACA,wB;AACA,qB;AACA,sB;AACA,sC;AACA,I;AACA,oB;AACA,iB;AACA,yC;AACA,uD;AACA,8B;AACA,e;AACA,G;AACA,I;;AAEA,iD;AACA,4B;AACA,2B;AACA,sB;AACA,4D;AACA,uC;AACA,+C;AACA,I;AACA,8B;AACA,0E;AACA,qC;AACA,W;AACA,wD;AACA,kD;;AAEA,6C;AACA,qD;AACA,qE;AACA,sD;AACA,gC;AACA,4C;AACA,6C;AACA,sB;AACA,iC;AACA,yB;AACA,O;AACA,M;AACA,O;;AAEA,wD;AACA,gB;AACA,I;AACA,I;AACA,sB;AACA,oC;AACA,I;AACA,oB;AACA,8B;AACA,yB;AACA,4B;AACA,iC;;AAEA,+D;AACA,mC;AACA,gE;AACA,0B;AACA,c;AACA,kC;AACA,sB;AACA,qC;AACA,8B;AACA,kC;AACA,Q;AACA,mC;AACA,kB;AACA,+B;AACA,M;AACA,gC;;AAEA,e;AACA,G;AACA,I;AACA,G;;AAEA,yB;AACA,wC;AACA,wD;AACA,G;AACA,yC;AACA,oD;AACA,6D;AACA,yB;AACA,0B;AACA,0C;AACA,E;AACA,G;;AAEA,6B;AACA,2C;AACA,yC;AACA,2B;AACA,0B;AACA,E;AACA,G;;AAEA,8B;AACA,yB;AACA,iB;AACA,kB;AACA,iB;AACA,kB;AACA,M;AACA,oB;AACA,G;AACA,wB;AACA,4C;AACA,oB;AACA,G;AACA,0B;AACA,qC;AACA,kC;AACA,kB;AACA,K;AACA,6B;AACA,G;AACA,2B;AACA,qC;AACA,kC;AACA,mB;AACA,K;AACA,6B;AACA,G;AACA,sB;AACA,qC;AACA,kC;AACA,kB;AACA,K;AACA,4B;AACA,uD;AACA,iB;AACA,0C;AACA,G;AACA,mB;AACA,E;AACA,G;;AAEA,uC;AACA,qC;AACA,gD;AACA,e;AACA,iE;;AAEA,2B;AACA,G;;AAEA,4C;AACA,yC;;AAEA,kD;AACA,uD;AACA,+D;AACA,iC;AACA,E;;AAEA,mC;AACA,0E;AACA,iB;AACA,E;;;;;;;;;;;;;;;;;;;ACnbA,gE;AACA,sE;;AAEA,G;AACA,4B;AACA,4B;AACA,sB;AACA,G;;AAEA,yB;AACA,2B;;AAEA,mC;AACA,qB;AACA,iB;;AAEA,Y;;AAEA,sC;AACA,2B;AACA,yB;AACA,4D;AACA,gD;AACA,0E;AACA,qC;AACA,Y;AACA,oD;AACA,sC;AACA,qB;AACA,K;AACA,0B;AACA,iB;;AAEA,O;AACA,uC;AACA,M;AACA,6B;AACA,O;;AAEA,mC;AACA,kB;AACA,qD;AACA,mB;AACA,qB;AACA,6B;AACA,yC;AACA,gF;AACA,yG;AACA,+G;AACA,+D;AACA,2E;AACA,mB;;AAEA,O;AACA,6E;AACA,yB;AACA,M;AACA,qF;AACA,8E;AACA,oF;AACA,M;AACA,wD;AACA,O;AACA,uD;AACA,gE;AACA,6C;AACA,c;AACA,c;AACA,4B;AACA,2B;;AAEA,6D;AACA,6C;AACA,sC;AACA,gC;AACA,sB;AACA,a;AACA,S;;AAEA,2E;AACA,sB;AACA,8D;AACA,8D;;AAEA,0C;AACA,yC;AACA,gF;AACA,kC;AACA,qC;AACA,wC;;AAEA,8D;AACA,6D;AACA,sE;AACA,+C;AACA,sC;AACA,6B;AACA,yB;AACA,4B;AACA,gE;AACA,wC;AACA,qB;AACA,iB;;AAEA,gE;AACA,+B;AACA,0B;AACA,iB;AACA,a;AACA,S;;AAEA,uB;AACA,K;;AAEA,O;AACA,8D;AACA,M;AACA,0E;AACA,oE;AACA,uE;AACA,M;AACA,e;AACA,O;AACA,6C;AACA,iF;AACA,K;;AAEA,O;AACA,gE;AACA,M;AACA,0E;AACA,oE;AACA,yE;AACA,M;AACA,e;AACA,O;AACA,+C;AACA,qF;AACA,K;;AAEA,O;AACA,uE;AACA,M;AACA,0E;AACA,gF;AACA,kF;AACA,uD;AACA,M;AACA,e;AACA,O;AACA,4D;AACA,qD;AACA,kB;AACA,8B;;AAEA,mC;AACA,kD;AACA,qC;;AAEA,+D;;AAEA,sE;AACA,0E;AACA,2E;AACA,yB;AACA,qB;AACA,iB;;AAEA,4B;AACA,a;;AAEA,0D;AACA,+D;AACA,a;;AAEA,wC;AACA,U;AACA,K;;AAEA,O;AACA,+E;AACA,gC;AACA,M;AACA,yC;AACA,M;AACA,2C;AACA,O;AACA,iC;AACA,uB;;AAEA,4E;AACA,4E;AACA,8E;AACA,iD;AACA,8G;AACA,yE;AACA,iD;AACA,0C;AACA,iD;AACA,6C;AACA,mF;AACA,yG;AACA,mG;AACA,sF;AACA,qD;AACA,iD;AACA,qC;AACA,mG;AACA,+F;AACA,8E;AACA,8E;AACA,6E;AACA,qF;AACA,sG;AACA,uF;;AAEA,wC;AACA,gF;AACA,sF;AACA,mB;AACA,S;;AAEA,2D;AACA,uG;AACA,4B;;AAEA,yF;AACA,2F;AACA,8F;AACA,yE;AACA,yC;;AAEA,iC;AACA,wD;AACA,6C;AACA,yC;AACA,+C;;AAEA,8C;AACA,qD;AACA,6B;AACA,0C;AACA,gD;AACA,qD;AACA,2C;AACA,2C;;AAEA,yF;AACA,+F;AACA,0F;AACA,oF;AACA,iC;AACA,gF;AACA,4D;AACA,oB;AACA,8C;AACA,a;AACA,gB;AACA,oE;AACA,S;;AAEA,gD;AACA,iD;;AAEA,uC;AACA,uB;AACA,gC;AACA,wB;AACA,yB;AACA,uB;;AAEA,mC;AACA,kE;AACA,gG;;AAEA,4D;AACA,2E;AACA,sE;AACA,yC;AACA,wB;AACA,yE;AACA,0F;AACA,+F;AACA,sF;AACA,wE;AACA,oF;AACA,2F;AACA,yE;AACA,iB;;AAEA,yD;AACA,6E;AACA,8D;AACA,qC;AACA,8D;AACA,wE;AACA,uE;AACA,yC;AACA,wB;AACA,kE;AACA,iF;AACA,yD;AACA,yC;AACA,8C;AACA,qB;AACA,iB;;AAEA,8C;AACA,iD;;AAEA,qD;;AAEA,iF;AACA,mE;AACA,mF;AACA,yC;AACA,8C;AACA,iD;;AAEA,+C;AACA,sC;AACA,yC;AACA,0G;AACA,oF;AACA,uC;AACA,4B;AACA,6E;AACA,kE;AACA,2F;AACA,0E;AACA,yD;AACA,qB;AACA,0D;AACA,gG;;AAEA,mE;AACA,6D;AACA,qD;AACA,+C;AACA,oD;AACA,gC;AACA,iE;AACA,4C;AACA,yB;AACA,0C;AACA,qB;;AAEA,wG;AACA,8E;AACA,yC;AACA,wC;AACA,gD;;AAEA,+C;AACA,sC;AACA,sE;AACA,yC;AACA,qH;AACA,oF;AACA,uC;AACA,4B;AACA,oD;AACA,2F;AACA,0F;AACA,qF;AACA,qB;AACA,wB;AACA,sE;AACA,iB;;AAEA,6C;;AAEA,+C;AACA,iD;AACA,sC;AACA,yC;AACA,uC;AACA,4B;AACA,0F;AACA,wF;AACA,yD;AACA,qB;AACA,0D;AACA,gG;;AAEA,gF;AACA,2E;AACA,+F;;AAEA,mD;AACA,0C;AACA,qE;AACA,mF;AACA,2C;AACA,gC;AACA,4F;AACA,6D;AACA,yB;AACA,qB;AACA,wB;AACA,sE;AACA,iB;AACA,a;AACA,6C;AACA,sF;;AAEA,wD;AACA,uE;AACA,kE;AACA,qC;AACA,oC;AACA,uB;AACA,a;;AAEA,iE;AACA,iE;;AAEA,sD;AACA,mD;;AAEA,yE;AACA,iC;AACA,sC;AACA,a;;AAEA,oG;AACA,4E;AACA,8C;;AAEA,kF;AACA,iC;AACA,uD;AACA,oC;AACA,uB;AACA,a;;AAEA,8B;AACA,oD;AACA,+C;AACA,+B;AACA,oB;AACA,oD;AACA,gG;AACA,gE;AACA,kE;AACA,oG;AACA,iD;AACA,a;AACA,S;;AAEA,+B;AACA,+B;AACA,gB;AACA,kC;AACA,yB;AACA,S;AACA,K;;AAEA,O;AACA,8E;AACA,4E;AACA,4E;AACA,yE;AACA,M;AACA,yC;AACA,M;AACA,4C;AACA,O;AACA,kC;AACA,uB;;AAEA,4B;;AAEA,yE;AACA,8D;;AAEA,mC;AACA,mC;AACA,oB;AACA,sC;AACA,6B;AACA,a;AACA,S;AACA,K;;AAEA,O;AACA,0E;AACA,M;AACA,2F;AACA,qE;AACA,M;AACA,kD;AACA,O;AACA,4C;AACA,c;AACA,2C;AACA,oC;;AAEA,sC;AACA,4C;AACA,S;AACA,K;;AAEA,O;AACA,qD;AACA,M;AACA,mD;AACA,kF;AACA,O;;AAEA,O;AACA,uD;AACA,M;AACA,uE;AACA,qD;AACA,wE;AACA,yD;AACA,O;;AAEA,O;AACA,6E;AACA,sB;AACA,M;AACA,gI;AACA,6H;AACA,M;AACA,gD;AACA,O;AACA,2C;AACA,c;AACA,qC;AACA,mB;AACA,gB;;AAEA,6B;AACA,0C;AACA,kE;AACA,a;AACA,S;;AAEA,4E;AACA,wC;AACA,sC;AACA,+C;AACA,mE;AACA,mB;AACA,c;AACA,mC;AACA,gF;AACA,uC;AACA,6B;AACA,+C;AACA,gE;AACA,mB;AACA,c;AACA,0C;AACA,6B;AACA,sC;AACA,+C;AACA,2D;AACA,mB;AACA,c;AACA,mC;AACA,6B;AACA,+C;AACA,2D;AACA,mB;AACA,c;AACA,S;;AAEA,gB;AACA,qB;AACA,0B;AACA,U;AACA,K;;AAEA,O;AACA,sE;AACA,M;AACA,2E;AACA,gB;AACA,M;AACA,8E;AACA,M;AACA,6C;AACA,O;AACA,iC;AACA,kD;AACA,4B;AACA,K;;AAEA,O;AACA,2E;AACA,M;AACA,2E;AACA,uB;AACA,M;AACA,kF;AACA,M;AACA,gD;AACA,O;AACA,oC;AACA,qD;AACA,+B;AACA,K;;;AAGA,2B;;AAEA,iC;AACA,sD;AACA,uD;AACA,O;;AAEA,4C;AACA,8B;AACA,iC;AACA,gC;AACA,wB;;;AAGA,oC;;AAEA,O;AACA,oC;AACA,M;AACA,iB;AACA,O;AACA,yB;AACA,6C;AACA,yD;AACA,yC;AACA,mC;AACA,wC;AACA,M;;AAEA,O;AACA,4C;AACA,M;AACA,iB;AACA,O;AACA,4B;AACA,iC;AACA,kC;AACA,M;;AAEA,O;AACA,2E;AACA,+E;AACA,2C;AACA,M;AACA,4E;AACA,kD;AACA,oF;AACA,sD;AACA,O;AACA,sD;AACA,6E;AACA,+B;AACA,iC;AACA,a;AACA,mC;AACA,S;;AAEA,oB;AACA,M;;AAEA,O;AACA,8E;AACA,M;AACA,+E;AACA,4C;AACA,M;AACA,6E;AACA,4E;AACA,8D;AACA,gF;AACA,4E;AACA,wE;AACA,O;AACA,gD;AACA,uB;AACA,qB;AACA,qB;AACA,yB;AACA,sB;AACA,c;AACA,iB;;AAEA,oB;AACA,wD;;AAEA,uE;AACA,gD;AACA,6B;AACA,uC;;AAEA,+C;AACA,sC;AACA,6B;AACA,a;;AAEA,6B;AACA,4C;AACA,mC;AACA,oB;AACA,+C;AACA,+B;AACA,a;;AAEA,+C;AACA,mC;AACA,0F;AACA,iE;AACA,6E;AACA,uC;AACA,iB;AACA,a;AACA,S;;AAEA,oB;AACA,M;;AAEA,O;AACA,iF;AACA,sC;AACA,M;AACA,mD;AACA,6E;AACA,O;AACA,2C;AACA,c;;AAEA,+B;AACA,gD;AACA,4B;AACA,8D;AACA,0B;AACA,+C;AACA,gC;AACA,iB;AACA,a;AACA,wB;AACA,S;;AAEA,iD;AACA,M;;AAEA,O;AACA,wE;AACA,+C;AACA,M;AACA,+E;AACA,+E;AACA,4D;AACA,O;AACA,gD;AACA,+B;AACA,+C;AACA,wB;AACA,S;;AAEA,0B;AACA,M;;AAEA,O;AACA,4C;AACA,M;AACA,yF;AACA,2F;AACA,qF;AACA,yF;AACA,qE;AACA,M;AACA,c;AACA,O;AACA,oE;AACA,gC;AACA,0B;AACA,S;AACA,yB;AACA,wB;;AAEA,O;AACA,8C;AACA,M;AACA,2F;AACA,2F;AACA,qF;AACA,2F;AACA,qE;AACA,M;AACA,c;AACA,O;AACA,sE;AACA,gC;AACA,4B;AACA,S;AACA,2B;AACA,0B;AACA,I;;;;;;;;;;;;;;;;;;;AChyBA,8E;AACA,sE;;AAEA,G;AACA,2C;AACA,4B;AACA,sB;AACA,G;;AAEA,yD;;AAEA,G;AACA,8B;AACA,E;AACA,wB;AACA,G;;AAEA,mC;AACA,uB;AACA,c;;AAEA,sE;AACA,qB;AACA,2D;AACA,2D;AACA,0C;AACA,oE;AACA,iD;AACA,S;AACA,oD;AACA,iC;AACA,E;AACA,+B;AACA,c;;AAEA,oB;;AAEA,I;AACA,2E;AACA,qE;AACA,G;AACA,wE;AACA,Y;AACA,I;AACA,kE;AACA,kB;AACA,uD;AACA,wD;AACA,gB;AACA,E;;AAEA,I;AACA,qE;AACA,kC;AACA,G;AACA,sE;AACA,gD;AACA,G;AACA,2E;AACA,mF;AACA,G;AACA,2E;AACA,I;AACA,4D;AACA,8F;AACA,yD;AACA,E;;AAEA,I;AACA,wE;AACA,4B;AACA,G;AACA,mE;AACA,gD;AACA,G;AACA,2E;AACA,mF;AACA,G;AACA,wE;AACA,I;AACA,yD;AACA,2F;AACA,yD;AACA,iB;AACA,uD;AACA,wD;AACA,gB;AACA,E;;AAEA,I;AACA,oC;AACA,G;AACA,+C;AACA,I;;AAEA,I;AACA,uE;AACA,2E;AACA,G;AACA,0E;AACA,0E;AACA,oE;AACA,G;AACA,2E;AACA,uD;AACA,6E;AACA,sD;AACA,G;AACA,+C;AACA,I;AACA,oE;;AAEA,iD;AACA,8C;AACA,c;;AAEA,sB;AACA,qB;;AAEA,2F;;AAEA,wB;AACA,kD;AACA,W;AACA,qD;AACA,I;AACA,U;AACA,yE;AACA,0B;AACA,yC;AACA,G;;AAEA,6B;AACA,c;AACA,G;;AAEA,I;AACA,iC;AACA,G;AACA,qD;AACA,I;AACA,yB;AACA,+C;AACA,oD;AACA,G;;AAEA,I;AACA,8E;AACA,mC;AACA,G;AACA,kD;AACA,8E;AACA,G;AACA,oD;AACA,I;AACA,8C;;AAEA,I;AACA,qE;AACA,6C;AACA,G;AACA,8E;AACA,8E;AACA,6D;AACA,G;AACA,uD;AACA,I;AACA,oD;;AAEA,I;AACA,yC;AACA,G;AACA,wF;AACA,0F;AACA,oF;AACA,wF;AACA,sE;AACA,G;AACA,mD;AACA,I;AACA,4C;;AAEA,I;AACA,2C;AACA,G;AACA,0F;AACA,0F;AACA,oF;AACA,0F;AACA,sE;AACA,G;AACA,qD;AACA,I;AACA,gD;AACA,I","file":"/packages/gadicohen:messageformat.js","sourcesContent":["/**\n * messageformat.js\n *\n * ICU PluralFormat + SelectFormat for JavaScript\n *\n * @author Alex Sexton - @SlexAxton\n * @version 0.1.5\n * @license WTFPL\n * @contributor_license Dojo CLA\n*/\n(function ( root ) {\n\n  // Create the contructor function\n  function MessageFormat ( locale, pluralFunc ) {\n    var fallbackLocale;\n\n    if ( locale && pluralFunc ) {\n      MessageFormat.locale[ locale ] = pluralFunc;\n    }\n\n    // Defaults\n    fallbackLocale = locale = locale || \"en\";\n    pluralFunc = pluralFunc || MessageFormat.locale[ fallbackLocale = MessageFormat.Utils.getFallbackLocale( locale ) ];\n\n    if ( ! pluralFunc ) {\n      throw new Error( \"Plural Function not found for locale: \" + locale );\n    }\n\n    // Own Properties\n    this.pluralFunc = pluralFunc;\n    this.locale = locale;\n    this.fallbackLocale = fallbackLocale;\n  }\n\n  // Set up the locales object. Add in english by default\n  MessageFormat.locale = {\n    \"en\" : function ( n ) {\n      if ( n === 1 ) {\n        return \"one\";\n      }\n      return \"other\";\n    }\n  };\n\n  // Build out our basic SafeString type\n  // more or less stolen from Handlebars by @wycats\n  MessageFormat.SafeString = function( string ) {\n    this.string = string;\n  };\n\n  MessageFormat.SafeString.prototype.toString = function () {\n    return this.string.toString();\n  };\n\n  MessageFormat.Utils = {\n    numSub : function ( string, key, depth ) {\n      // make sure that it's not an escaped octothorpe\n      return string.replace( /^#|[^\\\\]#/g, function (m) {\n        var prefix = m && m.length === 2 ? m.charAt(0) : '';\n        return prefix + '\" + (function(){ var x = ' +\n        key+';\\nif( isNaN(x) ){\\nthrow new Error(\"MessageFormat: `\"+lastkey_'+depth+'+\"` isnt a number.\");\\n}\\nreturn x;\\n})() + \"';\n      });\n    },\n    escapeExpression : function (string) {\n      var escape = {\n            \"\\n\": \"\\\\n\",\n            \"\\\"\": '\\\\\"'\n          },\n          badChars = /[\\n\"]/g,\n          possible = /[\\n\"]/,\n          escapeChar = function(chr) {\n            return escape[chr] || \"&amp;\";\n          };\n\n      // Don't escape SafeStrings, since they're already safe\n      if ( string instanceof MessageFormat.SafeString ) {\n        return string.toString();\n      }\n      else if ( string === null || string === false ) {\n        return \"\";\n      }\n\n      if ( ! possible.test( string ) ) {\n        return string;\n      }\n      return string.replace( badChars, escapeChar );\n    },\n    getFallbackLocale: function( locale ) {\n      var tagSeparator = locale.indexOf(\"-\") >= 0 ? \"-\" : \"_\";\n\n      // Lets just be friends, fallback through the language tags\n      while ( ! MessageFormat.locale.hasOwnProperty( locale ) ) {\n        locale = locale.substring(0, locale.lastIndexOf( tagSeparator ));\n        if (locale.length === 0) {\n          return null;\n        }\n      }\n\n      return locale;\n    }\n  };\n\n  // This is generated and pulled in for browsers.\n  var mparser = (function(){\n    /*\n     * Generated by PEG.js 0.7.0.\n     *\n     * http://pegjs.majda.cz/\n     */\n    \n    function quote(s) {\n      /*\n       * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n       * string literal except for the closing quote character, backslash,\n       * carriage return, line separator, paragraph separator, and line feed.\n       * Any character may appear in the form of an escape sequence.\n       *\n       * For portability, we also escape escape all control and non-ASCII\n       * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\n       * because JSHint does not like the first and IE the second.\n       */\n       return '\"' + s\n        .replace(/\\\\/g, '\\\\\\\\')  // backslash\n        .replace(/\"/g, '\\\\\"')    // closing quote character\n        .replace(/\\x08/g, '\\\\b') // backspace\n        .replace(/\\t/g, '\\\\t')   // horizontal tab\n        .replace(/\\n/g, '\\\\n')   // line feed\n        .replace(/\\f/g, '\\\\f')   // form feed\n        .replace(/\\r/g, '\\\\r')   // carriage return\n        .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\n        + '\"';\n    }\n    \n    var result = {\n      /*\n       * Parses the input with a generated parser. If the parsing is successfull,\n       * returns a value explicitly or implicitly specified by the grammar from\n       * which the parser was generated (see |PEG.buildParser|). If the parsing is\n       * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n       */\n      parse: function(input, startRule) {\n        var parseFunctions = {\n          \"start\": parse_start,\n          \"messageFormatPattern\": parse_messageFormatPattern,\n          \"messageFormatPatternRight\": parse_messageFormatPatternRight,\n          \"messageFormatElement\": parse_messageFormatElement,\n          \"elementFormat\": parse_elementFormat,\n          \"pluralStyle\": parse_pluralStyle,\n          \"selectStyle\": parse_selectStyle,\n          \"pluralFormatPattern\": parse_pluralFormatPattern,\n          \"offsetPattern\": parse_offsetPattern,\n          \"selectFormatPattern\": parse_selectFormatPattern,\n          \"pluralForms\": parse_pluralForms,\n          \"stringKey\": parse_stringKey,\n          \"string\": parse_string,\n          \"id\": parse_id,\n          \"chars\": parse_chars,\n          \"char\": parse_char,\n          \"digits\": parse_digits,\n          \"hexDigit\": parse_hexDigit,\n          \"_\": parse__,\n          \"whitespace\": parse_whitespace\n        };\n        \n        if (startRule !== undefined) {\n          if (parseFunctions[startRule] === undefined) {\n            throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n          }\n        } else {\n          startRule = \"start\";\n        }\n        \n        var pos = 0;\n        var reportFailures = 0;\n        var rightmostFailuresPos = 0;\n        var rightmostFailuresExpected = [];\n        \n        function padLeft(input, padding, length) {\n          var result = input;\n          \n          var padLength = length - input.length;\n          for (var i = 0; i < padLength; i++) {\n            result = padding + result;\n          }\n          \n          return result;\n        }\n        \n        function escape(ch) {\n          var charCode = ch.charCodeAt(0);\n          var escapeChar;\n          var length;\n          \n          if (charCode <= 0xFF) {\n            escapeChar = 'x';\n            length = 2;\n          } else {\n            escapeChar = 'u';\n            length = 4;\n          }\n          \n          return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n        }\n        \n        function matchFailed(failure) {\n          if (pos < rightmostFailuresPos) {\n            return;\n          }\n          \n          if (pos > rightmostFailuresPos) {\n            rightmostFailuresPos = pos;\n            rightmostFailuresExpected = [];\n          }\n          \n          rightmostFailuresExpected.push(failure);\n        }\n        \n        function parse_start() {\n          var result0;\n          var pos0;\n          \n          pos0 = pos;\n          result0 = parse_messageFormatPattern();\n          if (result0 !== null) {\n            result0 = (function(offset, messageFormatPattern) { return { type: \"program\", program: messageFormatPattern }; })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_messageFormatPattern() {\n          var result0, result1, result2;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse_string();\n          if (result0 !== null) {\n            result1 = [];\n            result2 = parse_messageFormatPatternRight();\n            while (result2 !== null) {\n              result1.push(result2);\n              result2 = parse_messageFormatPatternRight();\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, s1, inner) {\n              var st = [];\n              if ( s1 && s1.val ) {\n                st.push( s1 );\n              }\n              for( var i in inner ){\n                if ( inner.hasOwnProperty( i ) ) {\n                  st.push( inner[ i ] );\n                }\n              }\n              return { type: 'messageFormatPattern', statements: st };\n            })(pos0, result0[0], result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_messageFormatPatternRight() {\n          var result0, result1, result2, result3, result4, result5;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 123) {\n            result0 = \"{\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"{\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse__();\n            if (result1 !== null) {\n              result2 = parse_messageFormatElement();\n              if (result2 !== null) {\n                result3 = parse__();\n                if (result3 !== null) {\n                  if (input.charCodeAt(pos) === 125) {\n                    result4 = \"}\";\n                    pos++;\n                  } else {\n                    result4 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"}\\\"\");\n                    }\n                  }\n                  if (result4 !== null) {\n                    result5 = parse_string();\n                    if (result5 !== null) {\n                      result0 = [result0, result1, result2, result3, result4, result5];\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, mfe, s1) {\n              var res = [];\n              if ( mfe ) {\n                res.push(mfe);\n              }\n              if ( s1 && s1.val ) {\n                res.push( s1 );\n              }\n              return { type: \"messageFormatPatternRight\", statements : res };\n            })(pos0, result0[2], result0[5]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_messageFormatElement() {\n          var result0, result1, result2;\n          var pos0, pos1, pos2;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse_id();\n          if (result0 !== null) {\n            pos2 = pos;\n            if (input.charCodeAt(pos) === 44) {\n              result1 = \",\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\",\\\"\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = parse_elementFormat();\n              if (result2 !== null) {\n                result1 = [result1, result2];\n              } else {\n                result1 = null;\n                pos = pos2;\n              }\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n            result1 = result1 !== null ? result1 : \"\";\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, argIdx, efmt) {\n              var res = { \n                type: \"messageFormatElement\",\n                argumentIndex: argIdx\n              };\n              if ( efmt && efmt.length ) {\n                res.elementFormat = efmt[1];\n              }\n              else {\n                res.output = true;\n              }\n              return res;\n            })(pos0, result0[0], result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_elementFormat() {\n          var result0, result1, result2, result3, result4, result5, result6;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse__();\n          if (result0 !== null) {\n            if (input.substr(pos, 6) === \"plural\") {\n              result1 = \"plural\";\n              pos += 6;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"plural\\\"\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = parse__();\n              if (result2 !== null) {\n                if (input.charCodeAt(pos) === 44) {\n                  result3 = \",\";\n                  pos++;\n                } else {\n                  result3 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result3 !== null) {\n                  result4 = parse__();\n                  if (result4 !== null) {\n                    result5 = parse_pluralStyle();\n                    if (result5 !== null) {\n                      result6 = parse__();\n                      if (result6 !== null) {\n                        result0 = [result0, result1, result2, result3, result4, result5, result6];\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, t, s) {\n              return {\n                type : \"elementFormat\",\n                key  : t,\n                val  : s.val\n              };\n            })(pos0, result0[1], result0[5]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            result0 = parse__();\n            if (result0 !== null) {\n              if (input.substr(pos, 6) === \"select\") {\n                result1 = \"select\";\n                pos += 6;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"select\\\"\");\n                }\n              }\n              if (result1 !== null) {\n                result2 = parse__();\n                if (result2 !== null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result3 = \",\";\n                    pos++;\n                  } else {\n                    result3 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result3 !== null) {\n                    result4 = parse__();\n                    if (result4 !== null) {\n                      result5 = parse_selectStyle();\n                      if (result5 !== null) {\n                        result6 = parse__();\n                        if (result6 !== null) {\n                          result0 = [result0, result1, result2, result3, result4, result5, result6];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = (function(offset, t, s) {\n                return {\n                  type : \"elementFormat\",\n                  key  : t,\n                  val  : s.val\n                };\n              })(pos0, result0[1], result0[5]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n          }\n          return result0;\n        }\n        \n        function parse_pluralStyle() {\n          var result0;\n          var pos0;\n          \n          pos0 = pos;\n          result0 = parse_pluralFormatPattern();\n          if (result0 !== null) {\n            result0 = (function(offset, pfp) {\n              return { type: \"pluralStyle\", val: pfp };\n            })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_selectStyle() {\n          var result0;\n          var pos0;\n          \n          pos0 = pos;\n          result0 = parse_selectFormatPattern();\n          if (result0 !== null) {\n            result0 = (function(offset, sfp) {\n              return { type: \"selectStyle\", val: sfp };\n            })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_pluralFormatPattern() {\n          var result0, result1, result2;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse_offsetPattern();\n          result0 = result0 !== null ? result0 : \"\";\n          if (result0 !== null) {\n            result1 = [];\n            result2 = parse_pluralForms();\n            while (result2 !== null) {\n              result1.push(result2);\n              result2 = parse_pluralForms();\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, op, pf) {\n              var res = {\n                type: \"pluralFormatPattern\",\n                pluralForms: pf\n              };\n              if ( op ) {\n                res.offset = op;\n              }\n              else {\n                res.offset = 0;\n              }\n              return res;\n            })(pos0, result0[0], result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_offsetPattern() {\n          var result0, result1, result2, result3, result4, result5, result6;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse__();\n          if (result0 !== null) {\n            if (input.substr(pos, 6) === \"offset\") {\n              result1 = \"offset\";\n              pos += 6;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"offset\\\"\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = parse__();\n              if (result2 !== null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result3 = \":\";\n                  pos++;\n                } else {\n                  result3 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result3 !== null) {\n                  result4 = parse__();\n                  if (result4 !== null) {\n                    result5 = parse_digits();\n                    if (result5 !== null) {\n                      result6 = parse__();\n                      if (result6 !== null) {\n                        result0 = [result0, result1, result2, result3, result4, result5, result6];\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, d) {\n              return d;\n            })(pos0, result0[5]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_selectFormatPattern() {\n          var result0, result1;\n          var pos0;\n          \n          pos0 = pos;\n          result0 = [];\n          result1 = parse_pluralForms();\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_pluralForms();\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, pf) {\n              return {\n                type: \"selectFormatPattern\",\n                pluralForms: pf\n              };\n            })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_pluralForms() {\n          var result0, result1, result2, result3, result4, result5, result6, result7;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse__();\n          if (result0 !== null) {\n            result1 = parse_stringKey();\n            if (result1 !== null) {\n              result2 = parse__();\n              if (result2 !== null) {\n                if (input.charCodeAt(pos) === 123) {\n                  result3 = \"{\";\n                  pos++;\n                } else {\n                  result3 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"{\\\"\");\n                  }\n                }\n                if (result3 !== null) {\n                  result4 = parse__();\n                  if (result4 !== null) {\n                    result5 = parse_messageFormatPattern();\n                    if (result5 !== null) {\n                      result6 = parse__();\n                      if (result6 !== null) {\n                        if (input.charCodeAt(pos) === 125) {\n                          result7 = \"}\";\n                          pos++;\n                        } else {\n                          result7 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"}\\\"\");\n                          }\n                        }\n                        if (result7 !== null) {\n                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, k, mfp) {\n              return {\n                type: \"pluralForms\",\n                key: k,\n                val: mfp\n              };\n            })(pos0, result0[1], result0[5]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_stringKey() {\n          var result0, result1;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          result0 = parse_id();\n          if (result0 !== null) {\n            result0 = (function(offset, i) {\n              return i;\n            })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 61) {\n              result0 = \"=\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"=\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_digits();\n              if (result1 !== null) {\n                result0 = [result0, result1];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = (function(offset, d) {\n                return d;\n              })(pos0, result0[1]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n          }\n          return result0;\n        }\n        \n        function parse_string() {\n          var result0, result1, result2, result3, result4;\n          var pos0, pos1, pos2;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse__();\n          if (result0 !== null) {\n            result1 = [];\n            pos2 = pos;\n            result2 = parse__();\n            if (result2 !== null) {\n              result3 = parse_chars();\n              if (result3 !== null) {\n                result4 = parse__();\n                if (result4 !== null) {\n                  result2 = [result2, result3, result4];\n                } else {\n                  result2 = null;\n                  pos = pos2;\n                }\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n            while (result2 !== null) {\n              result1.push(result2);\n              pos2 = pos;\n              result2 = parse__();\n              if (result2 !== null) {\n                result3 = parse_chars();\n                if (result3 !== null) {\n                  result4 = parse__();\n                  if (result4 !== null) {\n                    result2 = [result2, result3, result4];\n                  } else {\n                    result2 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result2 = null;\n                  pos = pos2;\n                }\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, ws, s) {\n              var tmp = [];\n              for( var i = 0; i < s.length; ++i ) {\n                for( var j = 0; j < s[ i ].length; ++j ) {\n                  tmp.push(s[i][j]);\n                }\n              }\n              return {\n                type: \"string\",\n                val: ws + tmp.join('')\n              };\n            })(pos0, result0[0], result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_id() {\n          var result0, result1, result2, result3;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse__();\n          if (result0 !== null) {\n            if (/^[a-zA-Z$_]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[a-zA-Z$_]\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = [];\n              if (/^[^ \\t\\n\\r,.+={}]/.test(input.charAt(pos))) {\n                result3 = input.charAt(pos);\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[^ \\\\t\\\\n\\\\r,.+={}]\");\n                }\n              }\n              while (result3 !== null) {\n                result2.push(result3);\n                if (/^[^ \\t\\n\\r,.+={}]/.test(input.charAt(pos))) {\n                  result3 = input.charAt(pos);\n                  pos++;\n                } else {\n                  result3 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"[^ \\\\t\\\\n\\\\r,.+={}]\");\n                  }\n                }\n              }\n              if (result2 !== null) {\n                result3 = parse__();\n                if (result3 !== null) {\n                  result0 = [result0, result1, result2, result3];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, s1, s2) {\n              return s1 + (s2 ? s2.join('') : '');\n            })(pos0, result0[1], result0[2]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_chars() {\n          var result0, result1;\n          var pos0;\n          \n          pos0 = pos;\n          result1 = parse_char();\n          if (result1 !== null) {\n            result0 = [];\n            while (result1 !== null) {\n              result0.push(result1);\n              result1 = parse_char();\n            }\n          } else {\n            result0 = null;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, chars) { return chars.join(''); })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_char() {\n          var result0, result1, result2, result3, result4;\n          var pos0, pos1;\n          \n          pos0 = pos;\n          if (/^[^{}\\\\\\0-\\x1F \\t\\n\\r]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[^{}\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\");\n            }\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, x) {\n              return x;\n            })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            if (input.substr(pos, 2) === \"\\\\#\") {\n              result0 = \"\\\\#\";\n              pos += 2;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"\\\\\\\\#\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result0 = (function(offset) {\n                return \"\\\\#\";\n              })(pos0);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n            if (result0 === null) {\n              pos0 = pos;\n              if (input.substr(pos, 2) === \"\\\\{\") {\n                result0 = \"\\\\{\";\n                pos += 2;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"\\\\\\\\{\\\"\");\n                }\n              }\n              if (result0 !== null) {\n                result0 = (function(offset) {\n                  return \"\\u007B\";\n                })(pos0);\n              }\n              if (result0 === null) {\n                pos = pos0;\n              }\n              if (result0 === null) {\n                pos0 = pos;\n                if (input.substr(pos, 2) === \"\\\\}\") {\n                  result0 = \"\\\\}\";\n                  pos += 2;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"\\\\\\\\}\\\"\");\n                  }\n                }\n                if (result0 !== null) {\n                  result0 = (function(offset) {\n                    return \"\\u007D\";\n                  })(pos0);\n                }\n                if (result0 === null) {\n                  pos = pos0;\n                }\n                if (result0 === null) {\n                  pos0 = pos;\n                  pos1 = pos;\n                  if (input.substr(pos, 2) === \"\\\\u\") {\n                    result0 = \"\\\\u\";\n                    pos += 2;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"\\\\\\\\u\\\"\");\n                    }\n                  }\n                  if (result0 !== null) {\n                    result1 = parse_hexDigit();\n                    if (result1 !== null) {\n                      result2 = parse_hexDigit();\n                      if (result2 !== null) {\n                        result3 = parse_hexDigit();\n                        if (result3 !== null) {\n                          result4 = parse_hexDigit();\n                          if (result4 !== null) {\n                            result0 = [result0, result1, result2, result3, result4];\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                  if (result0 !== null) {\n                    result0 = (function(offset, h1, h2, h3, h4) {\n                        return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n                    })(pos0, result0[1], result0[2], result0[3], result0[4]);\n                  }\n                  if (result0 === null) {\n                    pos = pos0;\n                  }\n                }\n              }\n            }\n          }\n          return result0;\n        }\n        \n        function parse_digits() {\n          var result0, result1;\n          var pos0;\n          \n          pos0 = pos;\n          if (/^[0-9]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[0-9]\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [];\n            while (result1 !== null) {\n              result0.push(result1);\n              if (/^[0-9]/.test(input.charAt(pos))) {\n                result1 = input.charAt(pos);\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[0-9]\");\n                }\n              }\n            }\n          } else {\n            result0 = null;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, ds) {\n              return parseInt((ds.join('')), 10);\n            })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          return result0;\n        }\n        \n        function parse_hexDigit() {\n          var result0;\n          \n          if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[0-9a-fA-F]\");\n            }\n          }\n          return result0;\n        }\n        \n        function parse__() {\n          var result0, result1;\n          var pos0;\n          \n          reportFailures++;\n          pos0 = pos;\n          result0 = [];\n          result1 = parse_whitespace();\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_whitespace();\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, w) { return w.join(''); })(pos0, result0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          reportFailures--;\n          if (reportFailures === 0 && result0 === null) {\n            matchFailed(\"whitespace\");\n          }\n          return result0;\n        }\n        \n        function parse_whitespace() {\n          var result0;\n          \n          if (/^[ \\t\\n\\r]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[ \\\\t\\\\n\\\\r]\");\n            }\n          }\n          return result0;\n        }\n        \n        \n        function cleanupExpected(expected) {\n          expected.sort();\n          \n          var lastExpected = null;\n          var cleanExpected = [];\n          for (var i = 0; i < expected.length; i++) {\n            if (expected[i] !== lastExpected) {\n              cleanExpected.push(expected[i]);\n              lastExpected = expected[i];\n            }\n          }\n          return cleanExpected;\n        }\n        \n        function computeErrorPosition() {\n          /*\n           * The first idea was to use |String.split| to break the input up to the\n           * error position along newlines and derive the line and column from\n           * there. However IE's |split| implementation is so broken that it was\n           * enough to prevent it.\n           */\n          \n          var line = 1;\n          var column = 1;\n          var seenCR = false;\n          \n          for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n            var ch = input.charAt(i);\n            if (ch === \"\\n\") {\n              if (!seenCR) { line++; }\n              column = 1;\n              seenCR = false;\n            } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n              line++;\n              column = 1;\n              seenCR = true;\n            } else {\n              column++;\n              seenCR = false;\n            }\n          }\n          \n          return { line: line, column: column };\n        }\n        \n        \n        var result = parseFunctions[startRule]();\n        \n        /*\n         * The parser is now in one of the following three states:\n         *\n         * 1. The parser successfully parsed the whole input.\n         *\n         *    - |result !== null|\n         *    - |pos === input.length|\n         *    - |rightmostFailuresExpected| may or may not contain something\n         *\n         * 2. The parser successfully parsed only a part of the input.\n         *\n         *    - |result !== null|\n         *    - |pos < input.length|\n         *    - |rightmostFailuresExpected| may or may not contain something\n         *\n         * 3. The parser did not successfully parse any part of the input.\n         *\n         *   - |result === null|\n         *   - |pos === 0|\n         *   - |rightmostFailuresExpected| contains at least one failure\n         *\n         * All code following this comment (including called functions) must\n         * handle these states.\n         */\n        if (result === null || pos !== input.length) {\n          var offset = Math.max(pos, rightmostFailuresPos);\n          var found = offset < input.length ? input.charAt(offset) : null;\n          var errorPosition = computeErrorPosition();\n          \n          throw new this.SyntaxError(\n            cleanupExpected(rightmostFailuresExpected),\n            found,\n            offset,\n            errorPosition.line,\n            errorPosition.column\n          );\n        }\n        \n        return result;\n      },\n      \n      /* Returns the parser source code. */\n      toSource: function() { return this._source; }\n    };\n    \n    /* Thrown when a parser encounters a syntax error. */\n    \n    result.SyntaxError = function(expected, found, offset, line, column) {\n      function buildMessage(expected, found) {\n        var expectedHumanized, foundHumanized;\n        \n        switch (expected.length) {\n          case 0:\n            expectedHumanized = \"end of input\";\n            break;\n          case 1:\n            expectedHumanized = expected[0];\n            break;\n          default:\n            expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\n              + \" or \"\n              + expected[expected.length - 1];\n        }\n        \n        foundHumanized = found ? quote(found) : \"end of input\";\n        \n        return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n      }\n      \n      this.name = \"SyntaxError\";\n      this.expected = expected;\n      this.found = found;\n      this.message = buildMessage(expected, found);\n      this.offset = offset;\n      this.line = line;\n      this.column = column;\n    };\n    \n    result.SyntaxError.prototype = Error.prototype;\n    \n    return result;\n  })();\n\n  MessageFormat.prototype.parse = function () {\n    // Bind to itself so error handling works\n    return mparser.parse.apply( mparser, arguments );\n  };\n\n  MessageFormat.prototype.precompile = function ( ast ) {\n    var self = this,\n        needOther = false,\n        fp = {\n      begin: 'function(d){\\nvar r = \"\";\\n',\n      end  : \"return r;\\n}\"\n    };\n\n    function interpMFP ( ast, data ) {\n      // Set some default data\n      data = data || {};\n      var s = '', i, tmp, lastkeyname;\n\n      switch ( ast.type ) {\n        case 'program':\n          return interpMFP( ast.program );\n        case 'messageFormatPattern':\n          for ( i = 0; i < ast.statements.length; ++i ) {\n            s += interpMFP( ast.statements[i], data );\n          }\n          return fp.begin + s + fp.end;\n        case 'messageFormatPatternRight':\n          for ( i = 0; i < ast.statements.length; ++i ) {\n            s += interpMFP( ast.statements[i], data );\n          }\n          return s;\n        case 'messageFormatElement':\n          data.pf_count = data.pf_count || 0;\n          s += 'if(!d){\\nthrow new Error(\"MessageFormat: No data passed to function.\");\\n}\\n';\n          if ( ast.output ) {\n            s += 'r += d[\"' + ast.argumentIndex + '\"];\\n';\n          }\n          else {\n            lastkeyname = 'lastkey_'+(data.pf_count+1);\n            s += 'var '+lastkeyname+' = \"'+ast.argumentIndex+'\";\\n';\n            s += 'var k_'+(data.pf_count+1)+'=d['+lastkeyname+'];\\n';\n            s += interpMFP( ast.elementFormat, data );\n          }\n          return s;\n        case 'elementFormat':\n          if ( ast.key === 'select' ) {\n            s += interpMFP( ast.val, data );\n            s += 'r += (pf_' +\n                 data.pf_count +\n                 '[ k_' + (data.pf_count+1) + ' ] || pf_'+data.pf_count+'[ \"other\" ])( d );\\n';\n          }\n          else if ( ast.key === 'plural' ) {\n            s += interpMFP( ast.val, data );\n            s += 'if ( pf_'+(data.pf_count)+'[ k_'+(data.pf_count+1)+' + \"\" ] ) {\\n';\n            s += 'r += pf_'+data.pf_count+'[ k_'+(data.pf_count+1)+' + \"\" ]( d ); \\n';\n            s += '}\\nelse {\\n';\n            s += 'r += (pf_' +\n                 data.pf_count +\n                 '[ MessageFormat.locale[\"' +\n                 self.fallbackLocale +\n                 '\"]( k_'+(data.pf_count+1)+' - off_'+(data.pf_count)+' ) ] || pf_'+data.pf_count+'[ \"other\" ] )( d );\\n';\n            s += '}\\n';\n          }\n          return s;\n        /* // Unreachable cases.\n        case 'pluralStyle':\n        case 'selectStyle':*/\n        case 'pluralFormatPattern':\n          data.pf_count = data.pf_count || 0;\n          s += 'var off_'+data.pf_count+' = '+ast.offset+';\\n';\n          s += 'var pf_' + data.pf_count + ' = { \\n';\n          needOther = true;\n          // We're going to simultaneously check to make sure we hit the required 'other' option.\n\n          for ( i = 0; i < ast.pluralForms.length; ++i ) {\n            if ( ast.pluralForms[ i ].key === 'other' ) {\n              needOther = false;\n            }\n            if ( tmp ) {\n              s += ',\\n';\n            }\n            else{\n              tmp = 1;\n            }\n            s += '\"' + ast.pluralForms[ i ].key + '\" : ' + interpMFP( ast.pluralForms[ i ].val,\n          (function(){ var res = JSON.parse(JSON.stringify(data)); res.pf_count++; return res; })() );\n          }\n          s += '\\n};\\n';\n          if ( needOther ) {\n            throw new Error(\"No 'other' form found in pluralFormatPattern \" + data.pf_count);\n          }\n          return s;\n        case 'selectFormatPattern':\n\n          data.pf_count = data.pf_count || 0;\n          s += 'var off_'+data.pf_count+' = 0;\\n';\n          s += 'var pf_' + data.pf_count + ' = { \\n';\n          needOther = true;\n\n          for ( i = 0; i < ast.pluralForms.length; ++i ) {\n            if ( ast.pluralForms[ i ].key === 'other' ) {\n              needOther = false;\n            }\n            if ( tmp ) {\n              s += ',\\n';\n            }\n            else{\n              tmp = 1;\n            }\n            s += '\"' + ast.pluralForms[ i ].key + '\" : ' + interpMFP( ast.pluralForms[ i ].val,\n              (function(){\n                var res = JSON.parse( JSON.stringify( data ) );\n                res.pf_count++;\n                return res;\n              })()\n            );\n          }\n          s += '\\n};\\n';\n          if ( needOther ) {\n            throw new Error(\"No 'other' form found in selectFormatPattern \" + data.pf_count);\n          }\n          return s;\n        /* // Unreachable\n        case 'pluralForms':\n        */\n        case 'string':\n          return 'r += \"' + MessageFormat.Utils.numSub(\n            MessageFormat.Utils.escapeExpression( ast.val ),\n            'k_' + data.pf_count + ' - off_' + ( data.pf_count - 1 ),\n            data.pf_count\n          ) + '\";\\n';\n        default:\n          throw new Error( 'Bad AST type: ' + ast.type );\n      }\n    }\n    return interpMFP( ast );\n  };\n\n  MessageFormat.prototype.compile = function ( message ) {\n    return (new Function( 'MessageFormat',\n      'return ' +\n        this.precompile(\n          this.parse( message )\n        )\n    ))(MessageFormat);\n  };\n\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = MessageFormat;\n    }\n    exports.MessageFormat = MessageFormat;\n  }\n  else if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return MessageFormat;\n    });\n  }\n  else {\n    root['MessageFormat'] = MessageFormat;\n  }\n\n})( this );\n","/*\n * TODO\n *\n * -> Revisions, show diff\n * -> Mark stuff as fuzzy or invalid depending on how big the change is\n * -> transUI, enable on load, etc... decide on mfTrans.js format\n *\n * sendNative code (force send of native strings in case not kept inline)\n * ready() function for loadlang, sub.  XXX-\n * setLocale()\n * language loader tooltip\n *\n */\n\n\nmfPkg = {\n    native: 'en',   // Fine to use reserved words for IdentifierNames (vs Identifiers)\n    objects: {},\n    compiled: {},\n    strings: {},\n    meta: {},\n    initted: false,\n\n    sendPolicy: 'all',\n    sendNative: false,\n    transUI: {\n        enabled: true\n    },\n\n    mfStrings: typeof Mongo !== 'undefined' ? new Mongo.Collection('mfStrings') : new Meteor.Collection('mfStrings'),\n    mfRevisions: typeof Mongo !== 'undefined' ? new Mongo.Collection('mfRevisions') : new Meteor.Collection('mfRevisions'),\n    mfMeta: typeof Mongo !== 'undefined' ? new Mongo.Collection('mfMeta') : new Meteor.Collection('mfMeta'),\n\n    init: function(native, options) {\n        this.native = native;\n        this.initted = true;\n        if (Meteor.isServer)\n            this.serverInit(native, options);\n        else\n            this.clientInit(native, options);\n    },\n\n    /*\n     * Observe additions/changes from after our last extract time, and\n     * update the local cache accordingly\n     */\n    observeFrom: function(mtime, which) {\n        var query = {mtime: {$gt: mtime}};\n        if (which == 'native')\n            query.lang = mfPkg.native;\n        else if (which == 'trans')\n            query.lang = { $not: mfPkg.native };\n\n        this.mfStrings.find().observe({\n            added: function(doc) {\n//                console.log('added ' + doc.key + ' ' + doc.text);\n                if (!mfPkg.strings[doc.lang])\n                    mfPkg.strings[doc.lang] = {};\n                if (!mfPkg.compiled[doc.lang])\n                    mfPkg.compiled[doc.lang] = {};\n                mfPkg.strings[doc.lang][doc.key]\n                    = Meteor.isClient ? doc.text : doc;\n            }, changed: function(doc) {\n//                console.log('changed ' + doc.key + ' ' + doc.text);\n                mfPkg.strings[doc.lang][doc.key]\n                    = Meteor.isClient ? doc.text : doc;\n                if (mfPkg.compiled[doc.lang][doc.key])\n                    delete mfPkg.compiled[doc.lang][doc.key];\n            }\n        });\n    },\n\n    webUI: {\n        allowFuncs: [ function() { return !!Meteor.userId(); } ],\n        denyFuncs: [],\n        allow: function(func) { this.allowFuncs.push(func); },\n        deny: function(func) { this.denyFuncs.push(func); },\n        allowed: function() {\n            var self = this, args = arguments;\n            return _.some(mfPkg.webUI.allowFuncs, function(func) {\n                return func.apply(self, args);\n            });\n        },\n        denied: function() {\n            var self = this, args = arguments;\n            return _.some(mfPkg.webUI.denyFuncs, function(func) {\n                return func.apply(self, args);\n            });\n        }\n    }\n}\n\nmfPkg.mfStrings.allow({insert:mfPkg.webUI.allowed, update:mfPkg.webUI.allowed, remove:mfPkg.webUI.allowed});\nmfPkg.mfStrings.deny({insert:mfPkg.webUI.denied, update:mfPkg.webUI.denied, remove:mfPkg.webUI.denied});\nmfPkg.mfRevisions.allow({insert:mfPkg.webUI.allowed, update:mfPkg.webUI.allowed, remove:mfPkg.webUI.allowed});\nmfPkg.mfRevisions.deny({insert:mfPkg.webUI.denied, update:mfPkg.webUI.denied, remove:mfPkg.webUI.denied});\nmfPkg.mfMeta.deny(function() { return true; });\n\nmf = function(key, params, message, locale) {\n    if (!locale && Meteor.isClient)\n        locale = Session.get('locale');\n    if (!locale)\n        locale = mfPkg.native;\n    if (_.isString(params)) {\n        message = params;\n        params = null;\n    }\n\n    var mf = mfPkg.objects[locale];\n    if (!mf) {\n        mf = mfPkg.objects[locale] = new MessageFormat(locale);\n        if (!mfPkg.strings[locale]) mfPkg.strings[locale] = {};\n        mfPkg.compiled[locale] = {};\n    }\n\n    var cmessage = mfPkg.compiled[locale][key];\n    if (!cmessage) {\n        // try find key in 1) locale, 2) native, 3) as an argument, 4) just show the key name\n        if (mfPkg.strings[locale] && mfPkg.strings[locale][key])\n            message = mfPkg.strings[locale][key];\n        else if (mfPkg.strings[mfPkg.native][key])\n            message = mfPkg.strings[mfPkg.native][key];\n        else\n            message = message || key;\n\n        // If loaded from database (only when mfExtract/All.js exists)\n        if (Meteor.isServer && _.isObject(message))\n        \tmessage = message.text;\n\n        cmessage = mfPkg.compiled[locale][key] = mf.compile(message);\n    }\n\n    try {\n        cmessage = cmessage(params);\n    }\n    catch(err) {\n        cmessage = err;\n    }\n    \n    return cmessage;\n}\n\n\n// needs to be on client and server for routing to work properly\nif (Package['iron:router'])\nPackage['iron:router'].Router.map(function() {\n    this.route('mfAll', {\n        path: '/translate/mfAll.js',\n        where: 'server',\n        action: function() {\n            var out, meta = { exportedAt: new Date().getTime(), updatedAt: 0 };\n            for (lang in mfPkg.strings)\n                for (key in mfPkg.strings[lang])\n                    if (mfPkg.strings[lang][key].mtime > meta.updatedAt)\n                        meta.updatedAt = mfPkg.strings[lang][key].mtime;\n\n            out = 'mfPkg.syncAll('\n                + JSON.stringify(mfPkg.strings, null, 2)\n                + ', ' + JSON.stringify(meta, null, 2) + ');';\n            //this.response.writeHead(200, {'Content-Type': 'application/javascript'});\n            this.response.writeHead(200, {'Content-Disposition': 'attachment; filename=mfAll.js'});\n            this.response.end(out, 'utf8');\n        }\n    });\n});\n","MessageFormat.locale.af = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.am = function(n) {\n  if (n === 0 || n == 1) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.ar = function(n) {\n  if (n === 0) {\n    return 'zero';\n  }\n  if (n == 1) {\n    return 'one';\n  }\n  if (n == 2) {\n    return 'two';\n  }\n  if ((n % 100) >= 3 && (n % 100) <= 10 && n == Math.floor(n)) {\n    return 'few';\n  }\n  if ((n % 100) >= 11 && (n % 100) <= 99 && n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.bg = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.bn = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.br = function (n) {\n  if (n === 0) {\n    return 'zero';\n  }\n  if (n == 1) {\n    return 'one';\n  }\n  if (n == 2) {\n    return 'two';\n  }\n  if (n == 3) {\n    return 'few';\n  }\n  if (n == 6) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.ca = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.cs = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if (n == 2 || n == 3 || n == 4) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.cy = function (n) {\n  if (n === 0) {\n    return 'zero';\n  }\n  if (n == 1) {\n    return 'one';\n  }\n  if (n == 2) {\n    return 'two';\n  }\n  if (n == 3) {\n    return 'few';\n  }\n  if (n == 6) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.da = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.de = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.el = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.en = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.es = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.et = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.eu = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.fa = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.fi = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.fil = function(n) {\n  if (n === 0 || n == 1) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.fr = function (n) {\n  if (n >= 0 && n < 2) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.ga = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if (n == 2) {\n    return 'two';\n  }\n  return 'other';\n};\nMessageFormat.locale.gl = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.gsw = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.gu = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.he = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.hi = function(n) {\n  if (n === 0 || n == 1) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.hr = function (n) {\n  if ((n % 10) == 1 && (n % 100) != 11) {\n    return 'one';\n  }\n  if ((n % 10) >= 2 && (n % 10) <= 4 &&\n      ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) {\n    return 'few';\n  }\n  if ((n % 10) === 0 || ((n % 10) >= 5 && (n % 10) <= 9) ||\n      ((n % 100) >= 11 && (n % 100) <= 14) && n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.hu = function(n) {\n  return 'other';\n};\nMessageFormat.locale.id = function(n) {\n  return 'other';\n};\nMessageFormat.locale[\"in\"] = function(n) {\n  return 'other';\n};\nMessageFormat.locale.is = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.it = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.iw = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.ja = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.kn = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.ko = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.lag = function (n) {\n  if (n === 0) {\n    return 'zero';\n  }\n  if (n > 0 && n < 2) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.ln = function(n) {\n  if (n === 0 || n == 1) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.lt = function (n) {\n  if ((n % 10) == 1 && ((n % 100) < 11 || (n % 100) > 19)) {\n    return 'one';\n  }\n  if ((n % 10) >= 2 && (n % 10) <= 9 &&\n      ((n % 100) < 11 || (n % 100) > 19) && n == Math.floor(n)) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.lv = function (n) {\n  if (n === 0) {\n    return 'zero';\n  }\n  if ((n % 10) == 1 && (n % 100) != 11) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.mk = function (n) {\n  if ((n % 10) == 1 && n != 11) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.ml = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.mo = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if (n === 0 || n != 1 && (n % 100) >= 1 &&\n      (n % 100) <= 19 && n == Math.floor(n)) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.mr = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.ms = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.mt = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if (n === 0 || ((n % 100) >= 2 && (n % 100) <= 4 && n == Math.floor(n))) {\n    return 'few';\n  }\n  if ((n % 100) >= 11 && (n % 100) <= 19 && n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.nl = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.no = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.or = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.pl = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if ((n % 10) >= 2 && (n % 10) <= 4 &&\n      ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) {\n    return 'few';\n  }\n  if ((n % 10) === 0 || n != 1 && (n % 10) == 1 ||\n      ((n % 10) >= 5 && (n % 10) <= 9 || (n % 100) >= 12 && (n % 100) <= 14) &&\n      n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.pt = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.ro = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if (n === 0 || n != 1 && (n % 100) >= 1 &&\n      (n % 100) <= 19 && n == Math.floor(n)) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.ru = function (n) {\n  if ((n % 10) == 1 && (n % 100) != 11) {\n    return 'one';\n  }\n  if ((n % 10) >= 2 && (n % 10) <= 4 &&\n      ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) {\n    return 'few';\n  }\n  if ((n % 10) === 0 || ((n % 10) >= 5 && (n % 10) <= 9) ||\n      ((n % 100) >= 11 && (n % 100) <= 14) && n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.shi = function(n) {\n  if (n >= 0 && n <= 1) {\n    return 'one';\n  }\n  if (n >= 2 && n <= 10 && n == Math.floor(n)) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.sk = function (n) {\n  if (n == 1) {\n    return 'one';\n  }\n  if (n == 2 || n == 3 || n == 4) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.sl = function (n) {\n  if ((n % 100) == 1) {\n    return 'one';\n  }\n  if ((n % 100) == 2) {\n    return 'two';\n  }\n  if ((n % 100) == 3 || (n % 100) == 4) {\n    return 'few';\n  }\n  return 'other';\n};\nMessageFormat.locale.sq = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.sr = function (n) {\n  if ((n % 10) == 1 && (n % 100) != 11) {\n    return 'one';\n  }\n  if ((n % 10) >= 2 && (n % 10) <= 4 &&\n      ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) {\n    return 'few';\n  }\n  if ((n % 10) === 0 || ((n % 10) >= 5 && (n % 10) <= 9) ||\n      ((n % 100) >= 11 && (n % 100) <= 14) && n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.sv = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.sw = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.ta = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.te = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.th = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.tl = function(n) {\n  if (n === 0 || n == 1) {\n    return 'one';\n  }\n  return 'other';\n};\nMessageFormat.locale.tr = function(n) {\n  return 'other';\n};\nMessageFormat.locale.uk = function (n) {\n  if ((n % 10) == 1 && (n % 100) != 11) {\n    return 'one';\n  }\n  if ((n % 10) >= 2 && (n % 10) <= 4 &&\n      ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) {\n    return 'few';\n  }\n  if ((n % 10) === 0 || ((n % 10) >= 5 && (n % 10) <= 9) ||\n      ((n % 100) >= 11 && (n % 100) <= 14) && n == Math.floor(n)) {\n    return 'many';\n  }\n  return 'other';\n};\nMessageFormat.locale.ur = function ( n ) {\n  if ( n === 1 ) {\n    return \"one\";\n  }\n  return \"other\";\n};\nMessageFormat.locale.vi = function ( n ) {\n  return \"other\";\n};\nMessageFormat.locale.zh = function ( n ) {\n  return \"other\";\n};\n","\nTemplate.__checkName(\"mf\");\nTemplate[\"mf\"] = new Template(\"Template.mf\", (function() {\n  var view = this;\n  return Blaze.View(function() {\n    return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"helper\"), view.templateContentBlock));\n  });\n}));\n\nTemplate.__checkName(\"mfTrans\");\nTemplate[\"mfTrans\"] = new Template(\"Template.mfTrans\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"container\",\n    id: \"mfTransContainer\"\n  }, \"\\n\t\", HTML.H2(Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"mf\"), \"mf_site_translations\", \"Site Translations\");\n  })), \"\\n\t\", HTML.P(\"Native language: \", HTML.B(Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"native\"));\n  })), \" (\", Blaze.View(function() {\n    return Spacebars.mustache(Spacebars.dot(view.lookup(\"stats\"), \"total\"));\n  }), \" strings)\"), \"\\n\\n\t\", Blaze.If(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\"stats\"), \"total\"));\n  }, function() {\n    return [ \"\\n\\n\t\t\", HTML.TABLE({\n      \"class\": \"mfTrans\"\n    }, \"\\n\t\t\t\", HTML.TR(\"\\n\t\t\t\t\", HTML.TH(\"Language\"), \"\\n\t\t\t\t\", HTML.TH(\"trans.\"), \"\\n\t\t\t\t\", HTML.TH(\"%\"), \"\\n\t\t\t\t\", HTML.TH(\"fuzzy\"), \"\\n\t\t\t\t\", HTML.TH(\"%\"), \"\\n\t\t\t\t\", HTML.TH(\"untrans\"), \"\\n\t\t\t\t\", HTML.TH(\"%\"), \"\\n\t\t\t\t\", HTML.TH(\"graph\"), \"\\n\t\t\t\"), \"\\n\t\t\t\", Blaze.Each(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"stats\"), \"langs\"));\n    }, function() {\n      return [ \"\\n\t\t\t\", HTML.TR(\"\\n\t\t\t\t\", HTML.TD(HTML.A({\n        href: function() {\n          return [ \"/translate/\", Spacebars.mustache(view.lookup(\"lang\")) ];\n        }\n      }, Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"lang\"));\n      }))), \"\\n\t\t\t\t\", HTML.TD(Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"trans\"));\n      })), \"\\n\t\t\t\t\", HTML.TD(Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"transPercent\"));\n      })), \"\\n\t\t\t\t\", HTML.TD(Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"fuzzy\"));\n      })), \"\\n\t\t\t\t\", HTML.TD(Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"fuzzyPercent\"));\n      })), \"\\n\t\t\t\t\", HTML.TD(Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"untrans\"));\n      })), \"\\n\t\t\t\t\", HTML.TD(Blaze.View(function() {\n        return Spacebars.mustache(view.lookup(\"untransPercent\"));\n      })), \"\\n\t\t\t\t\", HTML.TD(\"\\n\t\t\t\t\t\", HTML.DIV({\n        \"class\": \"mfTransGraph trans\",\n        style: function() {\n          return Spacebars.mustache(view.lookup(\"transWidth\"));\n        }\n      }), HTML.DIV({\n        \"class\": \"mfTransGraph fuzzy\",\n        style: function() {\n          return Spacebars.mustache(view.lookup(\"fuzzyWidth\"));\n        }\n      }), HTML.DIV({\n        \"class\": \"mfTransGraph untrans\",\n        style: function() {\n          return Spacebars.mustache(view.lookup(\"untransWidth\"));\n        }\n      }), \"\\n\t\t\t\t\"), \"\\n\t\t\t\"), \"\\n\t\t\t\" ];\n    }), \"\\n\t\t\"), \"\\n\\n\t\t\", HTML.BR(), \"\\n\t\t\", HTML.P(\"\\n\t\t\tNew language:\\n\t\t\t\", HTML.INPUT({\n      type: \"text\",\n      id: \"mfTransNewText\",\n      placeholder: \"fr, en_GB, etc\"\n    }), \"\\n\t\t\t\", HTML.INPUT({\n      type: \"submit\",\n      id: \"mfTransNewSubmit\",\n      value: \"Go\"\n    }), \"\\n\t\t\"), \"\\n\\n\t\t\", HTML.P(\"\\n\t\t\tDownload \", HTML.A({\n      id: \"mfAllJs\",\n      href: \"/translate/mfAll.js\"\n    }, \"server/mfAll.js\"), \"\\n\t\t\t(latest strings from all langs; save before redeploying/releasing an app)\\n\t\t\"), \"\\n    \", HTML.Comment('\\n\t\t<p>\\n\t\t\tDownload <a href=\"/translate/mfSmart.js\">server/mfSmart.js</a>\\n\t\t\t(all strings, untranslateable; save before releasing a smart package)\\n\t\t</p>\\n    '), \"\\n\\n\t\" ];\n  }, function() {\n    return [ \"\\n\\n\t\t\", HTML.P(\"Run \", HTML.B(\"mf_extract\"), \" in the root directory of your project to extract\\n\t\tall the translateable strings.\"), \"\\n\\n\t\t\", HTML.P(\"For more details see:\\n\t\t\", HTML.A({\n      href: \"http://messageformat.meteor.com/\"\n    }, \"messageformat.meteor.com\"), \".\\n\t\t\"), \"\\n\\n\t\" ];\n  }), \"\\n\t\");\n}));\n\nTemplate.__checkName(\"mfTransLang\");\nTemplate[\"mfTransLang\"] = new Template(\"Template.mfTransLang\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"container\",\n    id: \"mfTransLang\"\n  }, \"\\n\\n\t\t\", HTML.DIV({\n    id: \"mfTransPreview\"\n  }, \"\\n\t\t\t\", HTML.TABLE(\"\\n\t\t\t\t\", HTML.THEAD(\"\\n\t\t\t\t\t\", HTML.TR(\"\\n\t\t\t\t\t\t\", HTML.TH(\"Original String (\", Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"orig\"));\n  }), \")\"), \"\\n\t\t\t\t\t\t\", HTML.TH(\"Translation (\", Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"trans\"));\n  }), \")\"), \"\\n\t\t\t\t\t\"), \"\\n\t\t\t\t\"), \"\\n\t\t\t\"), \"\\n\t\t\t\", HTML.DIV({\n    \"class\": \"tbodyScroll\"\n  }, \"\\n\t\t\t\t\", HTML.TABLE(\"\\n\t\t\t\t\t\", HTML.TBODY(\"\\n\t\t\t\t\t\", Blaze.Each(function() {\n    return Spacebars.call(view.lookup(\"strings\"));\n  }, function() {\n    return [ \"\\n\t\t\t\t\t\t\", HTML.TR({\n      \"data-key\": function() {\n        return Spacebars.mustache(view.lookup(\"key\"));\n      },\n      \"class\": function() {\n        return [ Spacebars.mustache(view.lookup(\"stateClass\")), \" \", Spacebars.mustache(view.lookup(\"isCurrent\")) ];\n      }\n    }, \"\\n\t\t\t\t\t\t\t\", HTML.TD(Blaze.View(function() {\n      return Spacebars.mustache(view.lookup(\"orig\"));\n    })), \"\\n\t\t\t\t\t\t\t\", HTML.TD(Blaze.View(function() {\n      return Spacebars.mustache(view.lookup(\"trans\"));\n    })), \"\\n\t\t\t\t\t\t\"), \"\\n\t\t\t\t\t\" ];\n  }), \"\\n\t\t\t\t\t\"), \"\\n\t\t\t\t\"), \"\\n\t\t\t\"), \"\\n\t\t\"), HTML.Raw(\"\\n\t\t<p>Use ctrl-up and ctrl-down to quickly change keys</p>\\n\t\t\"), HTML.SPAN(HTML.B(Blaze.View(function() {\n    return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"key\"));\n  })), \" in \", Blaze.View(function() {\n    return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"file\"));\n  }), \":\", Blaze.View(function() {\n    return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"line\"));\n  }), Blaze.If(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\"keyInfo\"), \"template\"));\n  }, function() {\n    return [ \" (template\\n\t\t\t\t\", Blaze.If(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"keyInfo\"), \"routeUrl\"));\n    }, function() {\n      return [ \"\\n\t\t\t\t\t\", HTML.A({\n        href: function() {\n          return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"routeUrl\"));\n        }\n      }, Blaze.View(function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"template\"));\n      })) ];\n    }, function() {\n      return [ '\"', Blaze.View(function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"template\"));\n      }), '\"' ];\n    }), \")\" ];\n  }), Blaze.If(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\"keyInfo\"), \"func\"));\n  }, function() {\n    return [ \"; \", Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\"keyInfo\"), \"func\"));\n    }) ];\n  }), \"\\n\t\t\"), HTML.Raw(\"<br>\\n\t\t\"), HTML.TEXTAREA({\n    id: \"mfTransOrig\",\n    readonly: \"\",\n    value: function() {\n      return Spacebars.mustache(view.lookup(\"mfTransOrig\"));\n    }\n  }), \"\\n\t\t\", HTML.TEXTAREA({\n    id: \"mfTransDest\",\n    value: function() {\n      return Spacebars.mustache(view.lookup(\"mfTransTrans\"));\n    }\n  }), HTML.Raw('\\n\\n\t<br><br>\\n\t<p>\\n\t\t<a href=\"/translate\">Back to Translation Summary</a>\\n\t</p>\\n\\n\t'));\n}));\n\nTemplate.__checkName(\"mfTransLangDenied\");\nTemplate[\"mfTransLangDenied\"] = new Template(\"Template.mfTransLangDenied\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"container\",\n    id: \"mfTransLang\"\n  }, \"\\n\t\t\", HTML.H1(Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"mf\"), \"access_denied\", \"Access Denied\");\n  })), \"\\n\t\t\", HTML.P(Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"mf\"), \"login_and_access\", \"Please ensure you are logged in and have the relevant access to add/edit translations.\");\n  })), \"\\n\t\");\n}));\n","/*\n * Main Handlebars regular helper / block helper, calls mf() with correct\n * parameters.  On the client, mf() honors the Session locale if none is\n * manually specified here (see messageformat.js), making this a reactive\n * data source.\n */\nmfPkg.mfHelper = function(key, message, params) {\n\t// For best performance, waiton mfPkg.ready() before drawing template\n\tvar dep = mfPkg.updated();\n\tif (typeof key == \"undefined\") {\n\t\tkey = this.KEY;\n\t} else {\n\t\tmessage = params ? message : null;\n\t\tparams = params ? params.hash : {};\n\t}\n\n\treturn mf(key, params, message, params ? params.LOCALE : null)\n};\nUI.registerHelper('mf', mfPkg.mfHelper);\n\nTemplate.mf.helpers({\n\thelper: function(component, options) {\n\t\tvar dep = mfPkg.updated();\n\t\tvar key = this.KEY;\n\t\tif(typeof(UI.toRawText) == \"function\") //0.8.2 compat\n\t\t\tvar message = UI.toRawText(component);\n\t\telse{\n\t\t\tvar message = Blaze._toText ? Blaze._toText(component, HTML.TEXTMODE.STRING) : Blaze.toText(component, HTML.TEXTMODE.STRING);\n\t\t}\n\t\treturn mf(key, this, message, this.LOCALE);\n\t}\n});\n\nmfPkg.sendPolicy = 'current';\nmfPkg.mfStringsSub = Meteor.subscribe('mfStrings', 'notReady');\nmfPkg.clientInit = function(native, options) {\n\tif (!options)\n\t\toptions = {};\n\n\tif (options.sendPolicy)\n\t\tthis.sendPolicy = options.sendPolicy;\n\n\tmfPkg.strings[native] = {};\n\n\tDeps.autorun(function() {\n\t\tvar locale =\n\t\t\tmfPkg.sendPolicy == 'all' ? 'all'\n\t\t\t: Session.get('locale') || mfPkg.native;\n\t\t\t// console.log(locale);\n\n\t\t// If we requested the lang previously, or requesting native lang,\n\t\t// don't retrieve the strings [again], just update the subscription\n\t\tif (mfPkg.strings[locale] || (!mfPkg.sendNative && locale == mfPkg.native))\n\t\t\tupdateSubs();\n\t\telse\n\t\t\tmfPkg.loadLangs(locale, updateSubs);\n\t});\n\n\t// if momentjs is used on the client, we reactively change the locale on moment globally\n\tif(typeof moment == 'function')\n\t\tDeps.autorun(function() {\n\t\t\tmoment.locale(Session.get('locale') || mfPkg.native);\n\t\t});\n}\n\n/*\n * Fetch lang data from server, more efficiently than through a\n * collection publish (which we only use when editing translations)\n */\nmfPkg.lastSync = {};\nmfPkg.langsLoading = false;\nmfPkg.loadLangs = function(reqLang, callback) {\n\tmfPkg.langsLoading = true;\n\tmfPkg.readyDep.changed();\n\tMeteor.call('mfLoadLangs', reqLang, function(error, data) {\n\t\tif (error)\n\t\t\tthrow new Error(error);\n\n\t\tfor (lang in data.strings) {\n\t\t\tmfPkg.strings[lang] = data.strings[lang];\n\t\t\tmfPkg.compiled[lang] = {};  // reset if exists\n\t\t}\n\n\t\tmfPkg.lastSync[reqLang || 'all'] = data.lastSync;\n\t\tif (callback)\n\t\t\tcallback();\n\n\t\tmfPkg.langsLoading = false;\n\t\tmfPkg.readyDep.changed();\n\t});\n};\n\n/*\n * Reactive ready function.  All our subscriptions are dependencies.\n * Additionally, this is set to false when loadLang is called, and\n * true when it returns.\n */\nmfPkg.readyDep = new Deps.Dependency;\nmfPkg.ready = function() {\n\tvar ready = !mfPkg.langsLoading && mfPkg.mfStringsSub.ready();\n\t//console.log('changed to: ' + ready);\n\tthis.readyDep.depend();\n\treturn ready;\n}\n\n/*\n * Similar to the above, but only gets invalidated each time ready() set to true\n */\nmfPkg.updatedDep = new Deps.Dependency;\nmfPkg.updatedCurrent = false;\nmfPkg.updated = function() {\n\tthis.updatedDep.depend();\n\treturn null;\n}\n\n/*\n * Simple placeholder for now.  Future improvements detailed in\n * https://github.com/gadicc/meteor-messageformat/issues/38\n */\nmfPkg.setLocale = function(locale) {\n\tSession.set('locale', locale);\n}\n\n/*\n * On user connect, honor their language preferences if no Session var\n * already set.  headers.ready() is run immediately unless appcache is\n * being used.  langList is available instantly unless appcache is\n * being used, and then we have to fetch it ourselves\n */\nvar setLocaleFromHeader = function(langList) {\n    var lang;\n    var acceptLangs = headers.get('accept-language').split(',');\n    for (var i=0; i < acceptLangs.length; i++) {\n        lang = acceptLangs[i].split(';')[0].trim();\n        if (_.contains(langList, lang)) {\n            Session.set('locale', lang);\n            return;\n        }\n    }\t\n}\nheaders.ready(function() {\n\tif (!Session.get('locale') && headers.get('accept-language')) {\n\n\t\tvar langList = Inject.getObj('meteor-langList');\n\t\tif (langList)\n\t\t\tsetLocaleFromHeader(langList);\n\t\telse\n\t\t\tMeteor.call('mfPkg.langList', function(error, langList) {\n\t\t\t\tif (error)\n\t\t\t\t\tconsole.log('messageformat: error retrieving language list',\n\t\t\t\t\t\terror);\n\n\t\t\t\tsetLocaleFromHeader(langList);\n\t\t\t});\n\t}\n});\n\nDeps.autorun(function() {\n\tif (mfPkg.ready() && !mfPkg.updatedCurrent) {\n\t\tmfPkg.updatedCurrent = true;\n\t\tmfPkg.updatedDep.changed();\n\t} else if (mfPkg.updatedCurrent) {\n\t\tmfPkg.updatedCurrent = false;\n\t}\n});\n\n/*\n * Update our subscription for language updates.  If we change languages, we'll\n * we'll still have all the lang data in mfPkg, we just stop getting updates for\n * that language.  If we change back, we'll get all the updates since our last\n * sync for that lang.\n */\nfunction updateSubs() {\n\tvar locale = Session.get('locale') || mfPkg.native;\n\tmfPkg.observeFrom(mfPkg.lastSync[locale]);\n\tif (mfPkg.mfStringsSub)\n\t\tmfPkg.mfStringsSub.stop();\n\tmfPkg.mfStringsSub\n\t\t= Meteor.subscribe('mfStrings', locale,\n\t\t\tmfPkg.lastSync[locale], false);\n}\n\n/*\n * Finds the name of the first route using the given template\n */\nfunction routeNameFromTemplate(name) {\n\tvar route = _.find(Router.routes, function(route) {\n\t\tif (route.options.template)\n\t\t\treturn route.options.template == name;\n\t\telse\n\t\t\treturn route.name == name;\n\t});\n\treturn route && route.name;\n}\n\n/*\n * After user presses ctrl up-down, if the newly highlighted row\n * is not above or below the viewable area, scroll appropriately\n */\nfunction mfCheckScroll(tr) {\n\tvar box = $('#mfTransPreview .tbodyScroll');\n\tif (tr.position().top + tr.outerHeight() > box.outerHeight()) {\n\t\tbox.scrollTop(box.scrollTop()+tr.outerHeight());\n\t} else if (tr.position().top < 0) {\n\t\tbox.scrollTop(box.scrollTop()-tr.outerHeight())\n\t}\n}\n\n/*\n * Called whenever the user changes rows.  Checks if the text string is\n * non-empty and changed, and does the relevant database mods.  TODO,\n * consider refactoring as a Method\n */\nfunction saveChange(lang, key, text) {\n\tvar existing = mfPkg.mfStrings.findOne({\n\t\tlang: lang, key: key\n\t});\n\tvar source = mfPkg.mfStrings.findOne({\n\t\tlang: mfPkg.native, key: key\n\t});\n\n\tif (!text || (existing && text == existing.text))\n\t\treturn;\n\n\tvar revisionId = mfPkg.mfRevisions.insert({\n\t\tlang: lang,\n\t\tkey: key,\n\t\ttext: text,\n\t\tctime: new Date().getTime(),\n\t\tuserId: Meteor.userId(),\n\t\tsourceId: source.revisionId\n\t});\n\n\tif (existing)\n\t\tmfPkg.mfStrings.update(existing._id, { $set: {\n\t\t\tlang: lang,\n\t\t\ttext: text,\n\t\t\tmtime: new Date().getTime(),\n\t\t\trevisionId: revisionId\n\t\t}, $unset: { fuzzy: \"\" }});\n\telse\n\t\tmfPkg.mfStrings.insert({\n\t\t\tkey: key,\n\t\t\tlang: lang,\n\t\t\ttext: text,\n\t\t\tctime: new Date().getTime(),\n\t\t\tmtime: new Date().getTime(),\n\t\t\trevisionId: revisionId\n\t\t});\n}\n\n/*\n * Called everytime the current key is changed (ctrl up/down or click)\n */\nfunction changeKey(newKey) {\n\tvar destLang = Session.get('mfTransTrans');\n\tvar oldKey = Session.get('mfTransKey');\n\tif (oldKey == newKey) return;\n\n\tsaveChange(destLang, oldKey, $('#mfTransDest').val());\n\n\t// Temporary, need to turn off preserve\n\tvar str = mfPkg.mfStrings.findOne({\n\t\tkey: newKey, lang: destLang\n\t});\n\t$('#mfTransDest').val(str ? str.text : '');\n\n\tSession.set('mfTransKey', newKey);\n\t$('#mfTransDest').focus();\n}\n\nif (Package['iron:router'])\nPackage['iron:router'].Router.map(function() {\n\t// Main translation page, summary of all language data\n\tthis.route('mfTrans', {\n\t\tpath: '/translate',\n\t\twaitOn: function() {\n\t\t\treturn Meteor.subscribe('mfStats');\n\t\t},\n\t\tdata: function() {\n\t\t\tvar data = {};\n\t\t\tdata.strings = mfPkg.mfStrings.find();\n\t\t\tdata.stats = mfPkg.mfMeta.findOne({_id: '__stats'});\n\t\t\tdata.native = mfPkg.native;\n\t\t\treturn data;\n\t\t}\n\t});\n\n\t// Modify translations for a particular language\n\tthis.route('mfTransLang', {\n\t\tpath: '/translate/:lang',\n\t\twaitOn: function() {\n\t\t\t// Note, this is in ADDITION to the regular mfStrings sub\n\t\t\treturn Meteor.subscribe('mfStrings',\n\t\t\t\t[mfPkg.native, this.params.lang], 0, true);\n\t\t},\n\t\tonBeforeAction: function() {\n\t\t\tif (!mfPkg.webUI.allowed.call(this) || mfPkg.webUI.denied.call(this)) {\n\t\t\t\tthis.render('mfTransLangDenied');\n\t\t\t} else {\n\t\t\t\t// Temporary, only used to override preserve on dest\n\t\t\t\tSession.set('mfTransTrans', this.params.lang);\n\n\t\t\t\t// Handle ctrl-up/ctrl-down, respectively\n\t\t\t\t$(window).on('keydown.mfTrans', function(event) {\n\t\t\t\t\tif (event.ctrlKey && (event.which == 38 || event.which == 40)) {\n\t\t\t\t\t\tevent.preventDefault(); event.stopPropagation();\n\t\t\t\t\t\tvar tr = event.which == 38\n\t\t\t\t\t\t\t? $('#mfTransLang tr.current').prev()\n\t\t\t\t\t\t\t: $('#mfTransLang tr.current').next();\n\t\t\t\t\t\tif (tr.length) {\n\t\t\t\t\t\t\tchangeKey(tr.data('key'));\n\t\t\t\t\t\t\tmfCheckScroll(tr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthis.subscribe('mfRevisions', this.params.lang, 10);\n\t\t\t\tthis.next();\n\t\t\t}\n\t\t},\n\t\tonStop: function() {\n\t\t\t$(window).off('keydown.mfTrans');\n\t\t},\n\t\tdata: function() {\n\t\t\tvar data = { strings: {} };\n\t\t\tvar strings, out = {};\n\t\t\tdata.orig = mfPkg.native;\n\t\t\tdata.trans = this.params.lang;\n\n\t\t\t// summarise matching keys (orig + trans) to a single record\n\t\t\tstrings = mfPkg.mfStrings.find({\n\t\t\t\t$and: [{$or: [{lang: data.orig}, {lang: this.params.lang}]},\n\t\t\t\t\t{removed: undefined}]\n\t\t\t}).fetch();\n\t\t\t_.each(strings, function(str) {\n\t\t\t\tif (!out[str.key])\n\t\t\t\t\tout[str.key] = { key: str.key };\n\t\t\t\tif (str.lang == data.orig)\n\t\t\t\t\tout[str.key].orig = str.text;\n\t\t\t\telse\n\t\t\t\t\tout[str.key].trans = str.text;\n\t\t\t\tif (str.fuzzy)\n\t\t\t\t\tout[str.key].fuzzy = true;\n\t\t\t});\n\t\t\tdata.strings = _.values(out);\n\n\t\t\treturn data;\n\t\t}\n\t});\n});\n\nTemplate.mfTrans.events({\n\t'click #mfTransNewSubmit': function() {\n\t\tRouter.go('/translate/' + $('#mfTransNewText').val());\n\t},\n\t'click #mfAllJs': function(event, tpl) {\n\t\t// Make sure we have no conflicts with iron-router\n\t\t// Not really sure why this is necessary; TODO, investigate\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\twindow.location = '/translate/mfAll.js';\n\t}\n});\n\nTemplate.mfTransLang.events({\n\t'click #mfTransLang tr': function(event) {\n\t\tvar tr = $(event.target).parents('tr');\n\t\tvar key = tr.data('key');\n\t\tif (key) changeKey(key);\n\t}\n});\n\nTemplate.mfTransLang.helpers({\n\tstateClass: function() {\n\t\tif (this.fuzzy)\n\t\t\treturn 'fuzzy';\n\t\tif (this.trans)\n\t\t\treturn 'trans';\n\t\telse\n\t\t\treturn 'untrans';\n\t},\n\tisCurrent: function() {\n\t\tif (this.key == Session.get('mfTransKey'))\n\t\t\treturn 'current';\n\t},\n\tmfTransOrig: function() {\n\t\tvar str = mfPkg.mfStrings.findOne({\n\t\t\tkey: Session.get('mfTransKey'),\n\t\t\tlang: this.orig\n\t\t});\n\t\treturn str ? str.text : '';\n\t},\n\tmfTransTrans: function() {\n\t\tvar str = mfPkg.mfStrings.findOne({\n\t\t\tkey: Session.get('mfTransKey'),\n\t\t\tlang: this.trans\n\t\t});\n\t\treturn str ? str.text : '';\n\t},\n\tkeyInfo: function() {\n\t\tvar str = mfPkg.mfStrings.findOne({\n\t\t\tkey: Session.get('mfTransKey'),\n\t\t\tlang: this.orig\n\t\t});\n\t\tif (str && str.template) {\n\t\t\tvar routeName = routeNameFromTemplate(str.template);\n\t\t\tif (routeName)\n\t\t\t\tstr.routeUrl = Router.path(routeName);\n\t\t}\n\t\treturn str || {};\n\t}\n});\n\nvar initialRender = _.once(function() {\n\tvar key = Session.get('mfTransKey'),\n\t\ttr = $('#mfTransLang tr[data-key=\"'+key+'\"]');\n\tif (tr.length)\n\t\t$('#mfTransPreview .tbodyScroll').scrollTop(tr.position().top);\n\n\t$('#mfTransDest').focus();\n});\n\nTemplate.mfTransLang.rendered = function() {\n\tvar tr, key = Session.get('mfTransKey');\n\n\t// For unset or nonexistent key, set to first row\n\tif (!key || !$('tr[data-key=\"' + key + '\"]').length) {\n\t\tkey = $('#mfTransLang tr[data-key]:first-child').data('key');\n\t\tSession.set('mfTransKey', key);\n\t}\n\n\tvar transDest = $('#mfTransDest');\n\tif (typeof transDest.tabOverride === 'function') transDest.tabOverride();\n\tinitialRender();\n};\n","/*! taboverride v4.0.0 | https://github.com/wjbryant/taboverride\nCopyright (c) 2013 Bill Bryant | http://opensource.org/licenses/mit */\n\n/**\n * @fileOverview taboverride\n * @author       Bill Bryant\n * @version      4.0.0\n */\n\n/*jslint browser: true */\n/*global exports, define */\n\n// use CommonJS or AMD if available\n(function (factory) {\n    'use strict';\n\n    var mod;\n\n    if (typeof exports === 'object') {\n        // Node.js/CommonJS\n        factory(exports);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD - register as an anonymous module\n        // files must be concatenated using an AMD-aware tool such as r.js\n        define(['exports'], factory);\n    } else {\n        // no module format - create global variable\n        mod = window.tabOverride = {};\n        factory(mod);\n    }\n}(function (tabOverride) {\n    'use strict';\n\n    /**\n     * The tabOverride namespace object\n     *\n     * @namespace tabOverride\n     */\n\n    var document = window.document,\n        listeners,\n        aTab = '\\t', // the string representing a tab\n        tabKey = 9,\n        untabKey = 9,\n        tabModifierKeys = [],\n        untabModifierKeys = ['shiftKey'],\n        autoIndent = true, // whether each line should be automatically indented\n        inWhitespace = false, // whether the start of the selection is in the leading whitespace on enter\n        textareaElem = document.createElement('textarea'), // temp textarea element to get newline character(s)\n        newline, // the newline character sequence (\\n or \\r\\n)\n        newlineLen, // the number of characters used for a newline (1 or 2)\n        hooks = {};\n\n    /**\n     * Determines whether the specified modifier keys match the modifier keys\n     * that were pressed.\n     *\n     * @param  {string[]} modifierKeys  the modifier keys to check - ex: ['shiftKey']\n     * @param  {Event}    e             the event object for the keydown event\n     * @return {boolean}                whether modifierKeys are valid for the event\n     *\n     * @method tabOverride.utils.isValidModifierKeyCombo\n     */\n    function isValidModifierKeyCombo(modifierKeys, e) {\n        var modifierKeyNames = ['alt', 'ctrl', 'meta', 'shift'],\n            numModKeys = modifierKeys.length,\n            i,\n            j,\n            currModifierKey,\n            isValid = true;\n\n        // check that all required modifier keys were pressed\n        for (i = 0; i < numModKeys; i += 1) {\n            if (!e[modifierKeys[i]]) {\n                isValid = false;\n                break;\n            }\n        }\n\n        // if the requirements were met, check for additional modifier keys\n        if (isValid) {\n            for (i = 0; i < modifierKeyNames.length; i += 1) {\n                currModifierKey = modifierKeyNames[i] + 'Key';\n\n                // if this key was pressed\n                if (e[currModifierKey]) {\n                    // if there are required keys, check whether the current key\n                    // is required\n                    if (numModKeys) {\n                        isValid = false;\n\n                        // if this is a required key, continue\n                        for (j = 0; j < numModKeys; j += 1) {\n                            if (currModifierKey === modifierKeys[j]) {\n                                isValid = true;\n                                break;\n                            }\n                        }\n                    } else {\n                        // no required keys, but one was pressed\n                        isValid = false;\n                    }\n                }\n\n                // an extra key was pressed, don't check anymore\n                if (!isValid) {\n                    break;\n                }\n            }\n        }\n\n        return isValid;\n    }\n\n    /**\n     * Determines whether the tab key combination was pressed.\n     *\n     * @param  {number}  keyCode  the key code of the key that was pressed\n     * @param  {Event}   e        the event object for the key event\n     * @return {boolean}          whether the tab key combo was pressed\n     *\n     * @private\n     */\n    function tabKeyComboPressed(keyCode, e) {\n        return keyCode === tabKey && isValidModifierKeyCombo(tabModifierKeys, e);\n    }\n\n    /**\n     * Determines whether the untab key combination was pressed.\n     *\n     * @param  {number}  keyCode  the key code of the key that was pressed\n     * @param  {Event}   e        the event object for the key event\n     * @return {boolean}          whether the untab key combo was pressed\n     *\n     * @private\n     */\n    function untabKeyComboPressed(keyCode, e) {\n        return keyCode === untabKey && isValidModifierKeyCombo(untabModifierKeys, e);\n    }\n\n    /**\n     * Creates a function to get and set the specified key combination.\n     *\n     * @param  {Function} keyFunc       getter/setter function for the key\n     * @param  {string[]} modifierKeys  the array of modifier keys to manipulate\n     * @return {Function}               a getter/setter function for the specified\n     *                                  key combination\n     *\n     * @private\n     */\n    function createKeyComboFunction(keyFunc, modifierKeys) {\n        return function (keyCode, modifierKeyNames) {\n            var i,\n                keyCombo = '';\n\n            if (arguments.length) {\n                if (typeof keyCode === 'number') {\n                    keyFunc(keyCode);\n\n                    modifierKeys.length = 0; // clear the array\n\n                    if (modifierKeyNames && modifierKeyNames.length) {\n                        for (i = 0; i < modifierKeyNames.length; i += 1) {\n                            modifierKeys.push(modifierKeyNames[i] + 'Key');\n                        }\n                    }\n                }\n\n                return this;\n            }\n\n            for (i = 0; i < modifierKeys.length; i += 1) {\n                keyCombo += modifierKeys[i].slice(0, -3) + '+';\n            }\n\n            return keyCombo + keyFunc();\n        };\n    }\n\n    /**\n     * Event handler to insert or remove tabs and newlines on the keydown event\n     * for the tab or enter key.\n     *\n     * @param {Event} e  the event object\n     *\n     * @method tabOverride.handlers.keydown\n     */\n    function overrideKeyDown(e) {\n        e = e || event;\n\n        // textarea elements can only contain text nodes which don't receive\n        // keydown events, so the event target/srcElement will always be the\n        // textarea element, however, prefer currentTarget in order to support\n        // delegated events in compliant browsers\n        var target = e.currentTarget || e.srcElement, // don't use the \"this\" keyword (doesn't work in old IE)\n            key = e.keyCode, // the key code for the key that was pressed\n            tab, // the string representing a tab\n            tabLen, // the length of a tab\n            text, // initial text in the textarea\n            range, // the IE TextRange object\n            tempRange, // used to calculate selection start and end positions in IE\n            preNewlines, // the number of newline character sequences before the selection start (for IE)\n            selNewlines, // the number of newline character sequences within the selection (for IE)\n            initScrollTop, // initial scrollTop value used to fix scrolling in Firefox\n            selStart, // the selection start position\n            selEnd, // the selection end position\n            sel, // the selected text\n            startLine, // for multi-line selections, the first character position of the first line\n            endLine, // for multi-line selections, the last character position of the last line\n            numTabs, // the number of tabs inserted / removed in the selection\n            startTab, // if a tab was removed from the start of the first line\n            preTab, // if a tab was removed before the start of the selection\n            whitespace, // the whitespace at the beginning of the first selected line\n            whitespaceLen, // the length of the whitespace at the beginning of the first selected line\n            CHARACTER = 'character'; // string constant used for the Range.move methods\n\n        // don't do any unnecessary work\n        if ((target.nodeName && target.nodeName.toLowerCase() !== 'textarea') ||\n                (key !== tabKey && key !== untabKey && (key !== 13 || !autoIndent))) {\n            return;\n        }\n\n        // initialize variables used for tab and enter keys\n        inWhitespace = false; // this will be set to true if enter is pressed in the leading whitespace\n        text = target.value;\n\n        // this is really just for Firefox, but will be used by all browsers that support\n        // selectionStart and selectionEnd - whenever the textarea value property is reset,\n        // Firefox scrolls back to the top - this is used to set it back to the original value\n        // scrollTop is nonstandard, but supported by all modern browsers\n        initScrollTop = target.scrollTop;\n\n        // get the text selection\n        if (typeof target.selectionStart === 'number') {\n            selStart = target.selectionStart;\n            selEnd = target.selectionEnd;\n            sel = text.slice(selStart, selEnd);\n\n        } else if (document.selection) { // IE\n            range = document.selection.createRange();\n            sel = range.text;\n            tempRange = range.duplicate();\n            tempRange.moveToElementText(target);\n            tempRange.setEndPoint('EndToEnd', range);\n            selEnd = tempRange.text.length;\n            selStart = selEnd - sel.length;\n\n            // whenever the value of the textarea is changed, the range needs to be reset\n            // IE <9 (and Opera) use both \\r and \\n for newlines - this adds an extra character\n            // that needs to be accounted for when doing position calculations with ranges\n            // these values are used to offset the selection start and end positions\n            if (newlineLen > 1) {\n                preNewlines = text.slice(0, selStart).split(newline).length - 1;\n                selNewlines = sel.split(newline).length - 1;\n            } else {\n                preNewlines = selNewlines = 0;\n            }\n        } else {\n            return; // cannot access textarea selection - do nothing\n        }\n\n        // tab / untab key - insert / remove tab\n        if (key === tabKey || key === untabKey) {\n\n            // initialize tab variables\n            tab = aTab;\n            tabLen = tab.length;\n            numTabs = 0;\n            startTab = 0;\n            preTab = 0;\n\n            // multi-line selection\n            if (selStart !== selEnd && sel.indexOf('\\n') !== -1) {\n                // for multiple lines, only insert / remove tabs from the beginning of each line\n\n                // find the start of the first selected line\n                if (selStart === 0 || text.charAt(selStart - 1) === '\\n') {\n                    // the selection starts at the beginning of a line\n                    startLine = selStart;\n                } else {\n                    // the selection starts after the beginning of a line\n                    // set startLine to the beginning of the first partially selected line\n                    // subtract 1 from selStart in case the cursor is at the newline character,\n                    // for instance, if the very end of the previous line was selected\n                    // add 1 to get the next character after the newline\n                    // if there is none before the selection, lastIndexOf returns -1\n                    // when 1 is added to that it becomes 0 and the first character is used\n                    startLine = text.lastIndexOf('\\n', selStart - 1) + 1;\n                }\n\n                // find the end of the last selected line\n                if (selEnd === text.length || text.charAt(selEnd) === '\\n') {\n                    // the selection ends at the end of a line\n                    endLine = selEnd;\n                } else if (text.charAt(selEnd - 1) === '\\n') {\n                    // the selection ends at the start of a line, but no\n                    // characters are selected - don't indent this line\n                    endLine = selEnd - 1;\n                } else {\n                    // the selection ends before the end of a line\n                    // set endLine to the end of the last partially selected line\n                    endLine = text.indexOf('\\n', selEnd);\n                    if (endLine === -1) {\n                        endLine = text.length;\n                    }\n                }\n\n                // tab key combo - insert tabs\n                if (tabKeyComboPressed(key, e)) {\n\n                    numTabs = 1; // for the first tab\n\n                    // insert tabs at the beginning of each line of the selection\n                    target.value = text.slice(0, startLine) + tab +\n                        text.slice(startLine, endLine).replace(/\\n/g, function () {\n                            numTabs += 1;\n                            return '\\n' + tab;\n                        }) + text.slice(endLine);\n\n                    // set start and end points\n                    if (range) { // IE\n                        range.collapse();\n                        range.moveEnd(CHARACTER, selEnd + (numTabs * tabLen) - selNewlines - preNewlines);\n                        range.moveStart(CHARACTER, selStart + tabLen - preNewlines);\n                        range.select();\n                    } else {\n                        // the selection start is always moved by 1 character\n                        target.selectionStart = selStart + tabLen;\n                        // move the selection end over by the total number of tabs inserted\n                        target.selectionEnd = selEnd + (numTabs * tabLen);\n                        target.scrollTop = initScrollTop;\n                    }\n                } else if (untabKeyComboPressed(key, e)) {\n                    // if the untab key combo was pressed, remove tabs instead of inserting them\n\n                    if (text.slice(startLine).indexOf(tab) === 0) {\n                        // is this tab part of the selection?\n                        if (startLine === selStart) {\n                            // it is, remove it\n                            sel = sel.slice(tabLen);\n                        } else {\n                            // the tab comes before the selection\n                            preTab = tabLen;\n                        }\n                        startTab = tabLen;\n                    }\n\n                    target.value = text.slice(0, startLine) + text.slice(startLine + preTab, selStart) +\n                        sel.replace(new RegExp('\\n' + tab, 'g'), function () {\n                            numTabs += 1;\n                            return '\\n';\n                        }) + text.slice(selEnd);\n\n                    // set start and end points\n                    if (range) { // IE\n                        // setting end first makes calculations easier\n                        range.collapse();\n                        range.moveEnd(CHARACTER, selEnd - startTab - (numTabs * tabLen) - selNewlines - preNewlines);\n                        range.moveStart(CHARACTER, selStart - preTab - preNewlines);\n                        range.select();\n                    } else {\n                        // set start first for Opera\n                        target.selectionStart = selStart - preTab; // preTab is 0 or tabLen\n                        // move the selection end over by the total number of tabs removed\n                        target.selectionEnd = selEnd - startTab - (numTabs * tabLen);\n                    }\n                } else {\n                    return; // do nothing for invalid key combinations\n                }\n\n            } else { // single line selection\n\n                // tab key combo - insert a tab\n                if (tabKeyComboPressed(key, e)) {\n                    if (range) { // IE\n                        range.text = tab;\n                        range.select();\n                    } else {\n                        target.value = text.slice(0, selStart) + tab + text.slice(selEnd);\n                        target.selectionEnd = target.selectionStart = selStart + tabLen;\n                        target.scrollTop = initScrollTop;\n                    }\n                } else if (untabKeyComboPressed(key, e)) {\n                    // if the untab key combo was pressed, remove a tab instead of inserting one\n\n                    // if the character before the selection is a tab, remove it\n                    if (text.slice(selStart - tabLen).indexOf(tab) === 0) {\n                        target.value = text.slice(0, selStart - tabLen) + text.slice(selStart);\n\n                        // set start and end points\n                        if (range) { // IE\n                            // collapses range and moves it by -1 tab\n                            range.move(CHARACTER, selStart - tabLen - preNewlines);\n                            range.select();\n                        } else {\n                            target.selectionEnd = target.selectionStart = selStart - tabLen;\n                            target.scrollTop = initScrollTop;\n                        }\n                    }\n                } else {\n                    return; // do nothing for invalid key combinations\n                }\n            }\n        } else if (autoIndent) { // Enter key\n            // insert a newline and copy the whitespace from the beginning of the line\n\n            // find the start of the first selected line\n            if (selStart === 0 || text.charAt(selStart - 1) === '\\n') {\n                // the selection starts at the beginning of a line\n                // do nothing special\n                inWhitespace = true;\n                return;\n            }\n\n            // see explanation under \"multi-line selection\" above\n            startLine = text.lastIndexOf('\\n', selStart - 1) + 1;\n\n            // find the end of the first selected line\n            endLine = text.indexOf('\\n', selStart);\n\n            // if no newline is found, set endLine to the end of the text\n            if (endLine === -1) {\n                endLine = text.length;\n            }\n\n            // get the whitespace at the beginning of the first selected line (spaces and tabs only)\n            whitespace = text.slice(startLine, endLine).match(/^[ \\t]*/)[0];\n            whitespaceLen = whitespace.length;\n\n            // the cursor (selStart) is in the whitespace at beginning of the line\n            // do nothing special\n            if (selStart < startLine + whitespaceLen) {\n                inWhitespace = true;\n                return;\n            }\n\n            if (range) { // IE\n                // insert the newline and whitespace\n                range.text = '\\n' + whitespace;\n                range.select();\n            } else {\n                // insert the newline and whitespace\n                target.value = text.slice(0, selStart) + '\\n' + whitespace + text.slice(selEnd);\n                // Opera uses \\r\\n for a newline, instead of \\n,\n                // so use newlineLen instead of a hard-coded value\n                target.selectionEnd = target.selectionStart = selStart + newlineLen + whitespaceLen;\n                target.scrollTop = initScrollTop;\n            }\n        }\n\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n            return false;\n        }\n    }\n\n    /**\n     * Event handler to prevent the default action for the keypress event when\n     * tab or enter is pressed. Opera and Firefox also fire a keypress event\n     * when the tab or enter key is pressed. Opera requires that the default\n     * action be prevented on this event or the textarea will lose focus.\n     *\n     * @param {Event} e  the event object\n     *\n     * @method tabOverride.handlers.keypress\n     */\n    function overrideKeyPress(e) {\n        e = e || event;\n\n        var key = e.keyCode;\n\n        if (tabKeyComboPressed(key, e) || untabKeyComboPressed(key, e) ||\n                (key === 13 && autoIndent && !inWhitespace)) {\n\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Executes all registered extension functions for the specified hook.\n     *\n     * @param {string} hook    the name of the hook for which the extensions are registered\n     * @param {Array}  [args]  the arguments to pass to the extension\n     *\n     * @method tabOverride.utils.executeExtensions\n     */\n    function executeExtensions(hook, args) {\n        var i,\n            extensions = hooks[hook] || [],\n            len = extensions.length;\n\n        for (i = 0; i < len; i += 1) {\n            extensions[i].apply(null, args);\n        }\n    }\n\n    /**\n     * @typedef {Object} tabOverride.utils~handlerObj\n     *\n     * @property {string}   type     the event type\n     * @property {Function} handler  the handler function - passed an Event object\n     */\n\n    /**\n     * @typedef {Object} tabOverride.utils~listenersObj\n     *\n     * @property {Function} add     Adds all the event listeners to the\n     *                              specified element\n     * @property {Function} remove  Removes all the event listeners from\n     *                              the specified element\n     */\n\n    /**\n     * Creates functions to add and remove event listeners in a cross-browser\n     * compatible way.\n     *\n     * @param  {tabOverride.utils~handlerObj[]} handlerList  an array of {@link tabOverride.utils~handlerObj handlerObj} objects\n     * @return {tabOverride.utils~listenersObj}              a listenersObj object used to add and remove the event listeners\n     *\n     * @method tabOverride.utils.createListeners\n     */\n    function createListeners(handlerList) {\n        var i,\n            len = handlerList.length,\n            remove,\n            add;\n\n        function loop(func) {\n            for (i = 0; i < len; i += 1) {\n                func(handlerList[i].type, handlerList[i].handler);\n            }\n        }\n\n        // use the standard event handler registration method when available\n        if (document.addEventListener) {\n            remove = function (elem) {\n                loop(function (type, handler) {\n                    elem.removeEventListener(type, handler, false);\n                });\n            };\n            add = function (elem) {\n                // remove listeners before adding them to make sure they are not\n                // added more than once\n                remove(elem);\n                loop(function (type, handler) {\n                    elem.addEventListener(type, handler, false);\n                });\n            };\n        } else if (document.attachEvent) {\n            // support IE 6-8\n            remove = function (elem) {\n                loop(function (type, handler) {\n                    elem.detachEvent('on' + type, handler);\n                });\n            };\n            add = function (elem) {\n                remove(elem);\n                loop(function (type, handler) {\n                    elem.attachEvent('on' + type, handler);\n                });\n            };\n        }\n\n        return {\n            add: add,\n            remove: remove\n        };\n    }\n\n    /**\n     * Adds the Tab Override event listeners to the specified element.\n     *\n     * Hooks: addListeners - passed the element to which the listeners will\n     * be added.\n     *\n     * @param {Element} elem  the element to which the listeners will be added\n     *\n     * @method tabOverride.utils.addListeners\n     */\n    function addListeners(elem) {\n        executeExtensions('addListeners', [elem]);\n        listeners.add(elem);\n    }\n\n    /**\n     * Removes the Tab Override event listeners from the specified element.\n     *\n     * Hooks: removeListeners - passed the element from which the listeners\n     * will be removed.\n     *\n     * @param {Element} elem  the element from which the listeners will be removed\n     *\n     * @method tabOverride.utils.removeListeners\n     */\n    function removeListeners(elem) {\n        executeExtensions('removeListeners', [elem]);\n        listeners.remove(elem);\n    }\n\n\n    // Initialize Variables\n\n    listeners = createListeners([\n        { type: 'keydown', handler: overrideKeyDown },\n        { type: 'keypress', handler: overrideKeyPress }\n    ]);\n\n    // get the characters used for a newline\n    textareaElem.value = '\\n';\n    newline = textareaElem.value;\n    newlineLen = newline.length;\n    textareaElem = null;\n\n\n    // Public Properties and Methods\n\n    /**\n     * Namespace for utility methods\n     *\n     * @namespace\n     */\n    tabOverride.utils = {\n        executeExtensions: executeExtensions,\n        isValidModifierKeyCombo: isValidModifierKeyCombo,\n        createListeners: createListeners,\n        addListeners: addListeners,\n        removeListeners: removeListeners\n    };\n\n    /**\n     * Namespace for event handler functions\n     *\n     * @namespace\n     */\n    tabOverride.handlers = {\n        keydown: overrideKeyDown,\n        keypress: overrideKeyPress\n    };\n\n    /**\n     * Adds an extension function to be executed when the specified hook is\n     * \"fired.\" The extension function is called for each element and is passed\n     * any relevant arguments for the hook.\n     *\n     * @param  {string}   hook  the name of the hook for which the extension\n     *                          will be registered\n     * @param  {Function} func  the function to be executed when the hook is \"fired\"\n     * @return {Object}         the tabOverride object\n     */\n    tabOverride.addExtension = function (hook, func) {\n        if (hook && typeof hook === 'string' && typeof func === 'function') {\n            if (!hooks[hook]) {\n                hooks[hook] = [];\n            }\n            hooks[hook].push(func);\n        }\n\n        return this;\n    };\n\n    /**\n     * Enables or disables Tab Override for the specified textarea element(s).\n     *\n     * Hooks: set - passed the current element and a boolean indicating whether\n     * Tab Override was enabled or disabled.\n     *\n     * @param  {Element|Element[]} elems          the textarea element(s) for\n     *                                            which to enable or disable\n     *                                            Tab Override\n     * @param  {boolean}           [enable=true]  whether Tab Override should be\n     *                                            enabled for the element(s)\n     * @return {Object}                           the tabOverride object\n     */\n    tabOverride.set = function (elems, enable) {\n        var enableFlag,\n            elemsArr,\n            numElems,\n            setListeners,\n            attrValue,\n            i,\n            elem;\n\n        if (elems) {\n            enableFlag = arguments.length < 2 || enable;\n\n            // don't manipulate param when referencing arguments object\n            // this is just a matter of practice\n            elemsArr = elems;\n            numElems = elemsArr.length;\n\n            if (typeof numElems !== 'number') {\n                elemsArr = [elemsArr];\n                numElems = 1;\n            }\n\n            if (enableFlag) {\n                setListeners = addListeners;\n                attrValue = 'true';\n            } else {\n                setListeners = removeListeners;\n                attrValue = '';\n            }\n\n            for (i = 0; i < numElems; i += 1) {\n                elem = elemsArr[i];\n                if (elem && elem.nodeName && elem.nodeName.toLowerCase() === 'textarea') {\n                    executeExtensions('set', [elem, enableFlag]);\n                    elem.setAttribute('data-taboverride-enabled', attrValue);\n                    setListeners(elem);\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Gets or sets the tab size for all elements that have Tab Override enabled.\n     * 0 represents the tab character.\n     *\n     * @param  {number}        [size]  the tab size\n     * @return {number|Object}         the tab size or the tabOverride object\n     */\n    tabOverride.tabSize = function (size) {\n        var i;\n\n        if (arguments.length) {\n            if (!size) { // size is 0 (or falsy)\n                aTab = '\\t';\n            } else if (typeof size === 'number' && size > 0) {\n                aTab = '';\n                for (i = 0; i < size; i += 1) {\n                    aTab += ' ';\n                }\n            }\n            return this;\n        }\n\n        return (aTab === '\\t') ? 0 : aTab.length;\n    };\n\n    /**\n     * Gets or sets the auto indent setting. True if each line should be\n     * automatically indented (default = true).\n     *\n     * @param  {boolean}        [enable]  whether auto indent should be enabled\n     * @return {boolean|Object}           whether auto indent is enabled or the\n     *                                    tabOverride object\n     */\n    tabOverride.autoIndent = function (enable) {\n        if (arguments.length) {\n            autoIndent = enable ? true : false;\n            return this;\n        }\n\n        return autoIndent;\n    };\n\n    /**\n     * Gets or sets the tab key combination.\n     *\n     * @param  {number}        keyCode             the key code of the key to use for tab\n     * @param  {string[]}      [modifierKeyNames]  the modifier key names - valid names are\n     *                                             'alt', 'ctrl', 'meta', and 'shift'\n     * @return {string|Object}                     the current tab key combination or the\n     *                                             tabOverride object\n     *\n     * @method\n     */\n    tabOverride.tabKey = createKeyComboFunction(function (keyCode) {\n        if (!arguments.length) {\n            return tabKey;\n        }\n        tabKey = keyCode;\n    }, tabModifierKeys);\n\n    /**\n     * Gets or sets the untab key combination.\n     *\n     * @param  {number}        keyCode             the key code of the key to use for untab\n     * @param  {string[]}      [modifierKeyNames]  the modifier key names - valid names are\n     *                                             'alt', 'ctrl', 'meta', and 'shift'\n     * @return {string|Object}                     the current untab key combination or the\n     *                                             tabOverride object\n     *\n     * @method\n     */\n    tabOverride.untabKey = createKeyComboFunction(function (keyCode) {\n        if (!arguments.length) {\n            return untabKey;\n        }\n        untabKey = keyCode;\n    }, untabModifierKeys);\n}));\n","/*! jquery.taboverride v4.0.0 | https://github.com/wjbryant/jquery.taboverride\nCopyright (c) 2013 Bill Bryant | http://opensource.org/licenses/mit */\n\n/**\n * @fileOverview Tab Override jQuery plugin\n * @author       Bill Bryant\n * @version      4.0.0\n */\n\n/*global exports, require, define, jQuery, tabOverride */\n\n/**\n * The jQuery plugin namespace\n *\n * @external \"jQuery.fn\"\n */\n\n// Use CommonJS or AMD if available\n(function ( factory ) {\n\t\"use strict\";\n\n\tif ( typeof exports === \"object\" && typeof require === \"function\" ) {\n\t\t// Node.js/CommonJS\n\t\tfactory( require( \"jquery\" ), require( \"taboverride\" ) );\n\t} else if ( typeof define === \"function\" && define.amd ) {\n\t\t// AMD - Register as an anonymous module\n\t\t// Files must be concatenated using an AMD-aware tool such as r.js\n\t\tdefine( [ \"jquery\", \"taboverride\" ], factory );\n\t} else {\n\t\t// No module format - Use global variables instead\n\t\tfactory( jQuery, tabOverride );\n\t}\n}(function ( $, tabOverride ) {\n\t\"use strict\";\n\n\tvar $fnTabOverride;\n\n\t/**\n\t * Helper function to remove the delegated listeners. This is only used in\n\t * the removeDelegatedListeners and addDelegatedListeners functions.\n\t *\n\t * @see external:\"jQuery.fn\".tabOverride.utils.removeDelegatedListeners\n\t * @private\n\t */\n\tfunction removeDelegatedListenersHelper( $container, selector ) {\n\t\t$container.off({\n\t\t\t\"keydown.tabOverride\": tabOverride.handlers.keydown,\n\t\t\t\"keypress.tabOverride\": tabOverride.handlers.keypress\n\t\t}, selector );\n\t}\n\n\t/**\n\t * Removes the Tab Override event listeners on the container element\n\t * using jQuery delegated events.\n\t *\n\t * Hooks: removeDelegatedListeners - passed the jQuery object for the\n\t * container element(s) and the selector string\n\t *\n\t * @param {Object} $container  the jQuery object for the container element\n\t * @param {string} selector    the selector string to use for the delegated events\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride.utils.removeDelegatedListeners\n\t */\n\tfunction removeDelegatedListeners( $container, selector ) {\n\t\ttabOverride.utils.executeExtensions( \"removeDelegatedListeners\", [ $container, selector ] );\n\t\tremoveDelegatedListenersHelper( $container, selector );\n\t}\n\n\t/**\n\t * Adds the Tab Override event listeners to the container element using\n\t * jQuery delegated events.\n\t *\n\t * Hooks: addDelegatedListeners - passed the jQuery object for the\n\t * container element(s) and the selector string\n\t *\n\t * @param {Object} $container  the jQuery object for the container element\n\t * @param {string} selector    the selector string to use for the delegated events\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride.utils.addDelegatedListeners\n\t */\n\tfunction addDelegatedListeners( $container, selector ) {\n\t\ttabOverride.utils.executeExtensions( \"addDelegatedListeners\", [ $container, selector ] );\n\t\tremoveDelegatedListenersHelper( $container, selector );\n\t\t$container.on({\n\t\t\t\"keydown.tabOverride\": tabOverride.handlers.keydown,\n\t\t\t\"keypress.tabOverride\": tabOverride.handlers.keypress\n\t\t}, selector );\n\t}\n\n\t/**\n\t * The tabOverride method namespace\n\t *\n\t * @namespace external:\"jQuery.fn\".tabOverride\n\t */\n\n\t/**\n\t * Enables/disables Tab Override. If enabled, tabs (or spaces) will be\n\t * inserted in the selected textarea elements when the tab key is pressed.\n\t *\n\t * Hooks: setDelegated - fired when delegated events are used, passed the\n\t * jQuery object for the container element(s), the selector string, and a\n\t * boolean indicating whether Tab Override was enabled or disabled.\n\t *\n\t * @param  {boolean} [enable=true]  whether Tab Override should be enabled\n\t *                                  for the element(s)\n\t * @param  {string}  [selector]     the selector string for delegated events\n\t * @return {Object}                 the jQuery object\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride(2)\n\t */\n\t$fnTabOverride = $.fn.tabOverride = function ( enable, selector ) {\n\n\t\tvar enablePlugin = !arguments.length || enable,\n\t\t\tisDelegated = typeof selector === \"string\",\n\t\t\t$container;\n\n\t\tif ( isDelegated ) {\n\t\t\t$container = this;\n\n\t\t\ttabOverride.utils.executeExtensions( \"setDelegated\", [ $container, selector, enable ] );\n\n\t\t\tif ( enablePlugin ) {\n\t\t\t\taddDelegatedListeners( $container, selector );\n\t\t\t} else {\n\t\t\t\tremoveDelegatedListeners( $container, selector );\n\t\t\t}\n\t\t} else {\n\t\t\t// The jQuery object acts as an array of elements, so it can be passed\n\t\t\t// to tabOverride.set()\n\t\t\ttabOverride.set( this, enablePlugin );\n\t\t}\n\n\t\t// Return the jQuery object\n\t\treturn this;\n\t};\n\n\t/**\n\t * Namespace for utility methods\n\t *\n\t * @namespace external:\"jQuery.fn\".tabOverride.utils\n\t */\n\t$fnTabOverride.utils = {\n\t\taddDelegatedListeners: addDelegatedListeners,\n\t\tremoveDelegatedListeners: removeDelegatedListeners\n\t};\n\n\t/**\n\t * Gets or sets the tab size for all elements that have Tab Override enabled.\n\t * 0 represents the tab character.\n\t *\n\t * @param  {number}          [size]  the tab size\n\t * @return {number|Function}         the tab size or the tabOverride function\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride.tabSize\n\t */\n\t$fnTabOverride.tabSize = tabOverride.tabSize;\n\n\t/**\n\t * Gets or sets the auto indent setting. True if each line should be\n\t * automatically indented (default = false).\n\t *\n\t * @param  {boolean}          [enable]  whether auto indent should be enabled\n\t * @return {boolean|Function}           whether auto indent is enabled or the\n\t *                                      tabOverride function\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride.autoIndent\n\t */\n\t$fnTabOverride.autoIndent = tabOverride.autoIndent;\n\n\t/**\n\t * Gets or sets the tab key combination.\n\t *\n\t * @param  {number}          keyCode             the key code of the key to use for tab\n\t * @param  {string[]}        [modifierKeyNames]  the modifier key names - valid names are\n\t *                                               'alt', 'ctrl', 'meta', and 'shift'\n\t * @return {string|Function}                     the current tab key combination or the\n\t *                                               tabOverride function\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride.tabKey\n\t */\n\t$fnTabOverride.tabKey = tabOverride.tabKey;\n\n\t/**\n\t * Gets or sets the untab key combination.\n\t *\n\t * @param  {number}          keyCode             the key code of the key to use for untab\n\t * @param  {string[]}        [modifierKeyNames]  the modifier key names - valid names are\n\t *                                               'alt', 'ctrl', 'meta', and 'shift'\n\t * @return {string|Function}                     the current untab key combination or the\n\t *                                               tabOverride function\n\t *\n\t * @method external:\"jQuery.fn\".tabOverride.untabKey\n\t */\n\t$fnTabOverride.untabKey = tabOverride.untabKey;\n}));\n"]}