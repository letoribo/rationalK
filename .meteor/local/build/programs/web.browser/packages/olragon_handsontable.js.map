)]}'
{"version":3,"sources":["olragon:handsontable/lib/jquery.handsontable.full.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,sB;AACA,0H;AACA,E;AACA,0C;AACA,kC;AACA,2B;AACA,E;AACA,gD;AACA,G;AACA,6E;;AAEA,wC;AACA,mC;AACA,iC;AACA,I;;AAEA,yD;AACA,oC;AACA,kE;AACA,kB;AACA,kB;AACA,E;AACA,0B;;AAEA,iB;AACA,qC;AACA,qC;AACA,C;;AAEA,kC;AACA,e;;AAEA,oF;AACA,+B;AACA,uD;AACA,gC;;AAEA,yC;AACA,qB;AACA,uB;AACA,yB;AACA,iB;AACA,kB;;AAEA,gC;AACA,yB;AACA,2B;AACA,oB;AACA,K;AACA,c;AACA,I;AACA,C;AACA,G;AACA,4F;AACA,G;;AAEA,8B;AACA,kD;AACA,iB;;AAEA,uD;AACA,4B;AACA,K;AACA,oC;AACA,4B;AACA,K;;AAEA,0B;;AAEA,4B;AACA,4C;AACA,K;;AAEA,2B;AACA,e;AACA,Q;AACA,U;;AAEA,kC;AACA,oC;AACA,mD;AACA,6C;AACA,wB;AACA,S;AACA,O;AACA,K;;AAEA,e;;AAEA,iC;AACA,2C;AACA,K;;AAEA,+C;AACA,qB;;AAEA,2D;AACA,8B;AACA,O;;AAEA,mB;AACA,K;AACA,I;AACA,C;;AAEA,qB;AACA,iC;AACA,kD;AACA,I;AACA,C;;AAEA,oG;AACA,wB;AACA,mB;AACA,6B;AACA,iB;AACA,yD;AACA,8E;AACA,mB;AACA,mB;AACA,yB;AACA,kB;AACA,yB;AACA,wB;AACA,+B;AACA,qB;AACA,Q;AACA,yC;;AAEA,0B;AACA,mF;AACA,gE;AACA,O;;AAEA,+B;;AAEA,yB;AACA,6C;AACA,4B;AACA,S;AACA,O;;AAEA,2B;AACA,+C;AACA,uD;AACA,sC;AACA,W;AACA,S;AACA,O;AACA,oB;AACA,M;AACA,O;AACA,C;;AAEA,E;AACA,2D;AACA,qD;AACA,iD;AACA,G;;AAEA,qC;AACA,e;AACA,+C;;AAEA,S;AACA,sC;AACA,8C;AACA,iB;AACA,mC;AACA,K;;AAEA,M;AACA,sF;AACA,6C;AACA,O;AACA,oC;;AAEA,8B;AACA,4E;AACA,gC;AACA,2B;AACA,O;AACA,M;;AAEA,6B;AACA,2B;AACA,mC;AACA,qC;AACA,wC;AACA,6B;AACA,c;AACA,kF;;AAEA,U;AACA,4B;AACA,oB;AACA,+D;AACA,iC;AACA,U;AACA,iC;AACA,mC;AACA,S;AACA,Q;AACA,Y;AACA,2B;AACA,mC;;AAEA,8E;;AAEA,mE;AACA,4C;AACA,6C;AACA,qB;AACA,a;AACA,W;;AAEA,uD;;AAEA,U;AACA,4B;;AAEA,+C;;AAEA,mE;AACA,4C;AACA,6C;AACA,a;AACA,W;;AAEA,iB;;AAEA,U;AACA,iC;;AAEA,+C;;AAEA,mE;AACA,4C;AACA,8D;AACA,a;AACA,W;AACA,S;AACA,Q;AACA,K;;AAEA,6B;AACA,O;AACA,C;;AAEA,+B;;AAEA,G;AACA,2B;AACA,gF;AACA,sB;AACA,e;AACA,G;AACA,0D;AACA,U;AACA,a;AACA,U;AACA,e;AACA,mB;AACA,qB;AACA,mC;AACA,yD;;AAEA,qI;AACA,2G;AACA,+E;;AAEA,iC;;AAEA,iD;AACA,2C;;AAEA,mE;;AAEA,mG;;AAEA,8E;AACA,8F;AACA,G;AACA,U;AACA,qB;AACA,uB;AACA,+C;AACA,8D;AACA,iE;AACA,sB;AACA,qB;AACA,kB;AACA,I;;AAEA,U;AACA,O;AACA,0C;AACA,qG;AACA,4B;AACA,6B;AACA,gE;AACA,6F;AACA,O;AACA,oE;AACA,gB;;AAEA,2B;;AAEA,uB;AACA,0B;AACA,mD;;AAEA,sB;AACA,4E;AACA,sE;AACA,+E;AACA,a;AACA,kB;AACA,mF;AACA,a;AACA,W;AACA,gB;;AAEA,0B;AACA,sH;AACA,oE;AACA,qD;;AAEA,sB;;AAEA,iE;AACA,2C;AACA,sG;AACA,yJ;AACA,a;;AAEA,4E;AACA,sE;AACA,+E;AACA,a;AACA,kB;AACA,mF;AACA,a;AACA,W;AACA,gB;;AAEA,0B;AACA,mH;AACA,iE;;AAEA,2C;AACA,kD;AACA,mC;AACA,+E;AACA,gB;;AAEA,0B;AACA,2C;;AAEA,4E;AACA,sG;AACA,2D;AACA,a;AACA,W;;AAEA,+D;AACA,4C;AACA,yB;AACA,a;AACA,oE;AACA,W;;AAEA,sD;;AAEA,mC;AACA,+E;AACA,gB;;AAEA,gB;AACA,sE;AACA,gB;AACA,O;;AAEA,2B;AACA,4G;AACA,O;AACA,M;;AAEA,O;AACA,iE;AACA,O;AACA,oC;AACA,wC;;AAEA,+D;AACA,kC;AACA,yC;AACA,4D;AACA,2D;AACA,S;AACA,O;;AAEA,gD;;AAEA,qD;AACA,mD;AACA,qH;AACA,2D;AACA,S;AACA,O;;AAEA,kC;AACA,gD;;AAEA,gD;AACA,mF;AACA,2E;AACA,2D;AACA,S;AACA,O;;AAEA,qD;AACA,8G;AACA,qH;AACA,2D;AACA,S;AACA,O;;AAEA,gD;AACA,qN;AACA,iC;AACA,Y;AACA,U;;AAEA,0E;AACA,qN;AACA,iC;AACA,Y;AACA,U;;AAEA,0C;AACA,0C;;AAEA,6C;AACA,6B;AACA,O;;AAEA,mC;AACA,6B;AACA,6C;AACA,6C;AACA,yC;AACA,yC;;AAEA,6D;AACA,qC;AACA,iC;AACA,kC;AACA,gC;AACA,4B;AACA,W;AACA,0C;AACA,+B;AACA,kC;AACA,gC;AACA,4B;AACA,W;AACA,S;;AAEA,6D;AACA,qC;AACA,iC;AACA,kC;AACA,gC;AACA,4B;AACA,W;AACA,0C;AACA,+B;AACA,kC;AACA,gC;AACA,4B;AACA,W;AACA,S;;AAEA,+B;AACA,8D;AACA,S;AACA,O;AACA,M;;AAEA,O;AACA,+C;AACA,qD;AACA,oC;AACA,6E;AACA,mD;AACA,2C;AACA,qD;AACA,kC;AACA,yF;AACA,O;AACA,wF;AACA,uD;AACA,0B;AACA,uB;AACA,qB;AACA,O;;AAEA,mB;AACA,mB;AACA,c;AACA,e;;AAEA,oD;AACA,uB;AACA,2B;AACA,wD;AACA,wD;AACA,oE;AACA,6F;AACA,2B;AACA,8E;AACA,kD;AACA,e;AACA,4D;AACA,2D;AACA,a;AACA,kB;AACA,iD;AACA,kE;AACA,a;AACA,W;AACA,gB;;AAEA,4B;AACA,wD;AACA,wD;AACA,6F;AACA,2B;AACA,8E;AACA,kD;AACA,e;AACA,4D;AACA,2D;AACA,a;AACA,kB;AACA,iD;AACA,kE;AACA,a;AACA,W;AACA,gB;;AAEA,0B;AACA,gB;AACA,sD;AACA,kC;AACA,kC;;AAEA,iE;AACA,4C;AACA,oE;AACA,mE;AACA,gB;;AAEA,yD;AACA,yB;AACA,uD;AACA,iE;AACA,a;AACA,mE;AACA,yB;AACA,qB;AACA,oB;AACA,c;AACA,W;;;AAGA,sC;AACA,wK;AACA,oB;AACA,a;AACA,oC;AACA,kD;AACA,wC;AACA,6K;AACA,sB;AACA,e;;AAEA,6E;AACA,2B;AACA,wC;AACA,6B;AACA,6B;AACA,4B;AACA,sB;;AAEA,4C;AACA,4I;;AAEA,+B;AACA,wG;AACA,wF;AACA,mB;AACA,iB;;AAEA,gE;AACA,e;;AAEA,4B;;AAEA,0C;AACA,uB;;AAEA,kE;AACA,kC;AACA,sE;AACA,0C;AACA,oC;AACA,mB;AACA,iB;;AAEA,e;AACA,a;;AAEA,0B;AACA,8B;;AAEA,wC;AACA,qB;;AAEA,gE;AACA,gC;AACA,oE;AACA,wC;AACA,kC;AACA,iB;AACA,e;;AAEA,a;AACA,W;AACA,qF;AACA,gB;AACA,O;AACA,K;AACA,I;;AAEA,2E;AACA,sB;;AAEA,qB;AACA,kB;AACA,iB;AACA,M;;AAEA,+C;AACA,oD;AACA,oD;AACA,M;;AAEA,O;AACA,2G;AACA,O;AACA,wB;AACA,2C;AACA,M;;AAEA,O;AACA,iF;AACA,O;AACA,yB;AACA,uC;AACA,4F;AACA,0I;AACA,4C;AACA,M;;AAEA,+B;AACA,2C;AACA,M;;AAEA,O;AACA,gD;AACA,4C;AACA,O;AACA,wD;AACA,sE;AACA,uE;AACA,4D;AACA,M;;AAEA,O;AACA,8C;AACA,4C;AACA,2F;AACA,O;AACA,oE;AACA,wB;AACA,oE;;AAEA,iC;;AAEA,2E;AACA,uC;AACA,oC;AACA,O;;AAEA,gC;AACA,kD;AACA,uE;;AAEA,6B;AACA,+C;AACA,mC;AACA,iE;AACA,+D;AACA,O;;AAEA,wB;AACA,mF;AACA,sD;AACA,sE;AACA,oE;AACA,O;;AAEA,wB;AACA,qJ;AACA,iM;;AAEA,uE;AACA,6C;AACA,O;AACA,uD;AACA,M;;AAEA,O;AACA,qE;AACA,sC;AACA,kC;AACA,O;AACA,2D;AACA,wB;AACA,oD;AACA,O;AACA,6B;AACA,kD;AACA,sC;AACA,O;AACA,M;;AAEA,O;AACA,sD;AACA,wB;AACA,O;AACA,6B;AACA,4H;AACA,kG;;AAEA,sB;AACA,wB;AACA,O;AACA,M;;AAEA,O;AACA,0D;AACA,O;AACA,4E;AACA,gE;AACA,uD;;AAEA,8E;AACA,sD;AACA,6D;AACA,S;AACA,6C;AACA,+C;AACA,yH;AACA,S;AACA,O;AACA,0I;AACA,6C;AACA,iG;AACA,O;;AAEA,+E;AACA,sD;AACA,6D;AACA,S;AACA,6C;AACA,yH;AACA,+C;AACA,S;AACA,O;AACA,0I;AACA,iG;AACA,6C;AACA,O;;AAEA,2C;AACA,2C;AACA,+H;;AAEA,2B;AACA,uB;AACA,O;AACA,2D;AACA,mC;AACA,O;;AAEA,2B;AACA,uB;AACA,O;AACA,2D;AACA,mC;AACA,O;;AAEA,wD;AACA,M;;AAEA,O;AACA,mF;AACA,O;AACA,iD;AACA,gE;AACA,qD;;AAEA,6C;AACA,6C;AACA,mH;;AAEA,6B;AACA,yB;AACA,S;AACA,6D;AACA,qC;AACA,S;;AAEA,6B;AACA,yB;AACA,S;AACA,6D;AACA,qC;AACA,S;;AAEA,sC;AACA,M;;AAEA,O;AACA,gF;AACA,wB;AACA,O;AACA,6B;AACA,sC;AACA,M;;AAEA,O;AACA,gE;AACA,4C;AACA,wB;AACA,O;AACA,sC;AACA,oC;AACA,qB;AACA,O;AACA,4C;AACA,M;;AAEA,O;AACA,mC;AACA,O;AACA,2B;AACA,oC;AACA,e;AACA,O;AACA,qE;AACA,2B;AACA,kD;AACA,+C;AACA,mF;AACA,sD;AACA,O;AACA,oC;AACA,iC;AACA,wD;AACA,M;;AAEA,O;AACA,uB;AACA,O;AACA,4B;AACA,uC;AACA,e;AACA,O;AACA,+D;AACA,kH;AACA,M;;AAEA,O;AACA,uC;AACA,O;AACA,wB;AACA,oC;AACA,e;AACA,O;AACA,qD;AACA,6D;AACA,6B;AACA,wD;AACA,0D;AACA,qD;AACA,qC;AACA,W;AACA,S;AACA,O;AACA,sC;AACA,K;AACA,I;;AAEA,2B;AACA,mD;;AAEA,oC;AACA,gE;AACA,K;;AAEA,6C;;AAEA,iD;AACA,uF;;AAEA,6D;AACA,uB;;AAEA,4C;AACA,0F;AACA,4B;AACA,K;AACA,kD;AACA,I;;AAEA,iJ;AACA,yB;;AAEA,Y;AACA,2B;AACA,wC;AACA,iC;AACA,yB;AACA,Q;AACA,6C;AACA,iG;AACA,mC;AACA,Q;AACA,iC;AACA,Q;AACA,wC;AACA,+D;AACA,0B;AACA,8B;AACA,S;AACA,O;AACA,M;AACA,G;;AAEA,uD;AACA,oD;AACA,+C;;AAEA,mD;AACA,gC;AACA,6B;AACA,O;AACA,Y;AACA,gC;AACA,mD;AACA,wM;AACA,mE;;AAEA,qF;AACA,qH;AACA,2C;AACA,gE;AACA,qC;AACA,a;AACA,yM;AACA,qC;AACA,a;AACA,kB;AACA,wD;AACA,a;;AAEA,4G;AACA,W;AACA,S;;AAEA,wD;AACA,oD;AACA,8F;AACA,sC;AACA,gD;AACA,2E;AACA,e;AACA,8E;AACA,kE;AACA,sG;AACA,oB;AACA,e;AACA,6D;AACA,a;AACA,+B;AACA,sB;AACA,S;AACA,O;AACA,K;AACA,8C;;AAEA,wB;AACA,6B;;AAEA,2B;AACA,mG;AACA,uD;AACA,wK;AACA,kD;AACA,oG;AACA,S;AACA,O;AACA,8F;AACA,K;AACA,G;;AAEA,K;AACA,qE;AACA,4E;AACA,mI;AACA,K;AACA,0C;AACA,+B;;AAEA,gB;AACA,a;AACA,K;;AAEA,yB;AACA,gC;AACA,6B;AACA,iB;AACA,O;;AAEA,0D;AACA,iB;AACA,O;;AAEA,yC;AACA,0D;AACA,8B;AACA,S;AACA,O;;AAEA,6E;AACA,6E;AACA,8B;AACA,S;AACA,O;;AAEA,+D;AACA,K;;AAEA,iE;AACA,6B;AACA,4E;AACA,yC;AACA,+E;AACA,G;;AAEA,0E;AACA,8D;;AAEA,0E;AACA,yC;AACA,2C;AACA,0C;AACA,S;AACA,oB;AACA,K;;AAEA,yC;;AAEA,6H;;AAEA,kF;AACA,wD;AACA,gE;AACA,uC;;AAEA,uI;;AAEA,0B;AACA,W;;AAEA,qB;AACA,a;AACA,wE;AACA,kC;AACA,qB;AACA,K;;;;AAIA,I;;AAEA,yD;AACA,8D;AACA,iB;AACA,K;AACA,U;AACA,c;AACA,iC;AACA,Q;AACA,K;AACA,G;;AAEA,K;AACA,2B;AACA,Y;AACA,qF;AACA,gD;AACA,0B;AACA,mI;AACA,K;AACA,2D;AACA,oD;AACA,S;AACA,Y;AACA,oB;AACA,a;;AAEA,qD;AACA,yC;AACA,uH;AACA,O;AACA,4C;AACA,0K;AACA,O;AACA,4C;AACA,oB;AACA,oB;AACA,a;AACA,uC;AACA,mB;AACA,S;AACA,K;;AAEA,6C;AACA,mB;AACA,K;;AAEA,kD;AACA,oC;AACA,O;AACA,I;;;AAGA,K;AACA,mC;AACA,Y;AACA,sF;AACA,0C;AACA,0B;AACA,mI;AACA,K;AACA,+D;AACA,qD;AACA,S;AACA,Y;AACA,qB;;AAEA,qD;AACA,oB;AACA,oB;AACA,oB;AACA,8C;AACA,mB;AACA,S;AACA,K;;AAEA,6C;AACA,oB;AACA,K;;AAEA,kD;AACA,oC;AACA,O;AACA,I;;AAEA,K;AACA,2C;AACA,K;AACA,6B;AACA,4C;;AAEA,6E;AACA,oC;AACA,K;AACA,4C;AACA,4B;AACA,K;AACA,I;;AAEA,K;AACA,mD;AACA,K;AACA,+B;AACA,mC;AACA,I;;AAEA,K;AACA,+F;AACA,K;AACA,kC;AACA,qD;AACA,I;;AAEA,K;AACA,+G;AACA,oC;AACA,K;AACA,kD;AACA,6C;AACA,I;;AAEA,K;AACA,6C;AACA,kC;AACA,qC;AACA,kC;AACA,iG;AACA,uG;AACA,kD;AACA,0C;AACA,wD;AACA,gC;AACA,uF;AACA,K;AACA,0G;AACA,uE;AACA,wJ;AACA,K;AACA,gM;AACA,I;;AAEA,K;AACA,sC;AACA,2E;AACA,8H;AACA,qI;AACA,0J;AACA,K;AACA,oE;AACA,uD;AACA,I;;AAEA,K;AACA,mC;AACA,2E;AACA,8H;AACA,qI;AACA,0J;AACA,K;AACA,oE;AACA,uD;AACA,I;;AAEA,K;AACA,2E;AACA,Y;AACA,iE;AACA,K;AACA,kG;AACA,iC;AACA,0G;AACA,K;AACA,I;;AAEA,K;AACA,4G;AACA,Y;AACA,mC;AACA,K;AACA,uG;AACA,iC;AACA,2B;AACA,K;AACA,I;;;AAGA,K;AACA,wB;AACA,Y;AACA,K;AACA,6B;AACA,wB;AACA,mE;AACA,2C;AACA,K;AACA,I;;AAEA,K;AACA,yB;AACA,Y;AACA,wB;AACA,K;AACA,mC;AACA,oD;AACA,gI;AACA,6E;AACA,sB;AACA,O;AACA,K;AACA,4B;AACA,gB;AACA,c;AACA,sE;AACA,iB;AACA,wE;AACA,yB;AACA,S;AACA,uB;AACA,O;AACA,K;AACA,U;AACA,+G;AACA,K;;AAEA,6B;AACA,uC;;AAEA,4E;AACA,kC;AACA,K;AACA,8D;AACA,qC;AACA,K;AACA,U;AACA,mC;AACA,K;;AAEA,qE;;AAEA,4B;;AAEA,6B;AACA,sD;;AAEA,wB;AACA,yC;AACA,K;AACA,U;AACA,wE;AACA,wB;AACA,K;;AAEA,4B;;;;AAIA,sC;AACA,mC;AACA,K;AACA,I;;AAEA,K;AACA,kN;AACA,Y;AACA,0C;AACA,0C;AACA,yC;AACA,yC;AACA,2B;AACA,K;AACA,0C;AACA,mC;AACA,8B;AACA,Y;AACA,gI;AACA,K;AACA,I;;AAEA,wE;AACA,6H;AACA,I;;AAEA,K;AACA,oB;AACA,Y;AACA,K;AACA,mD;AACA,gB;;AAEA,+C;AACA,2G;AACA,K;AACA,+C;AACA,2G;AACA,K;;AAEA,yB;AACA,yB;AACA,oD;AACA,O;AACA,Y;AACA,gG;AACA,gF;AACA,6C;AACA,W;AACA,S;AACA,c;AACA,4B;AACA,oD;AACA,oD;AACA,W;AACA,S;AACA,O;AACA,K;;AAEA,mC;AACA,oE;AACA,6D;AACA,K;AACA,wC;AACA,qE;AACA,K;AACA,2C;AACA,0B;AACA,K;;AAEA,8C;AACA,gC;;AAEA,8B;AACA,iC;;AAEA,mB;AACA,wB;;AAEA,kC;AACA,+G;;AAEA,iC;AACA,iD;;AAEA,wC;AACA,6C;AACA,qD;AACA,oD;AACA,gE;AACA,S;AACA,O;AACA,K;;AAEA,+C;AACA,+B;AACA,oC;AACA,6D;AACA,O;AACA,K;;AAEA,2D;;AAEA,oD;AACA,6C;AACA,4F;AACA,6E;AACA,O;AACA,+B;AACA,2E;AACA,4D;AACA,O;AACA,K;;AAEA,+C;AACA,mC;;AAEA,uC;AACA,0B;AACA,O;;AAEA,wD;AACA,K;;AAEA,8C;AACA,iC;;AAEA,sC;AACA,wB;AACA,O;;AAEA,sD;AACA,K;;AAEA,gB;AACA,mD;AACA,K;;AAEA,gB;AACA,8D;AACA,K;;AAEA,6B;AACA,0C;AACA,mE;AACA,2C;AACA,K;AACA,I;;AAEA,+B;AACA,qC;AACA,0C;AACA,kE;AACA,8D;AACA,O;AACA,qB;AACA,2E;AACA,O;AACA,K;AACA,mB;AACA,oD;AACA,K;AACA,I;;AAEA,4B;AACA,wE;;AAEA,gC;;AAEA,uC;AACA,sB;AACA,K;AACA,4C;AACA,8C;AACA,4B;AACA,6M;AACA,O;AACA,K;;;AAGA,yB;AACA,6D;AACA,kC;AACA,O;AACA,K;;AAEA,wB;;AAEA,G;;AAEA,K;AACA,oC;AACA,qB;AACA,K;AACA,kC;AACA,yB;AACA,I;;AAEA,K;AACA,gB;AACA,Y;AACA,K;AACA,4B;AACA,0B;AACA,sB;AACA,I;;AAEA,K;AACA,wC;AACA,8D;AACA,0B;AACA,2B;AACA,8D;AACA,2F;AACA,Y;AACA,K;AACA,wE;AACA,6D;AACA,I;;AAEA,K;AACA,0D;AACA,wB;AACA,wB;AACA,6B;AACA,Y;AACA,sB;AACA,K;AACA,+C;AACA,uF;AACA,I;;AAEA,K;AACA,iD;AACA,gB;AACA,uC;AACA,K;AACA,mC;AACA,2E;AACA,I;;AAEA,K;AACA,wD;AACA,wB;AACA,Y;AACA,qB;AACA,K;AACA,mC;AACA,kC;AACA,I;;AAEA,K;AACA,wD;AACA,yB;AACA,Y;AACA,qB;AACA,K;AACA,oC;AACA,mC;AACA,I;;AAEA,K;AACA,iC;AACA,wB;AACA,wB;AACA,Y;AACA,oC;AACA,K;AACA,4C;AACA,oD;AACA,I;;AAEA,K;AACA,kC;AACA,wB;AACA,yB;AACA,Y;AACA,oC;AACA,K;AACA,gD;AACA,kC;AACA,I;;AAEA,K;AACA,0E;AACA,wB;AACA,Y;AACA,4C;AACA,K;AACA,sC;AACA,iB;AACA,mL;AACA,I;;AAEA,K;AACA,2B;AACA,yB;AACA,Y;AACA,4C;AACA,K;AACA,wC;AACA,iB;AACA,2N;AACA,I;;AAEA,K;AACA,2C;AACA,wB;AACA,Y;AACA,qC;AACA,K;AACA,4C;AACA,iB;AACA,kC;;AAEA,2C;AACA,6B;AACA,K;;AAEA,e;AACA,I;;AAEA,K;AACA,2C;AACA,wB;AACA,Y;AACA,qC;AACA,K;AACA,4C;AACA,mC;AACA,I;;AAEA,K;AACA,0B;AACA,wB;AACA,Y;AACA,oC;AACA,K;AACA,sC;AACA,uJ;AACA,mB;AACA,I;;AAEA,M;AACA,sF;AACA,wB;AACA,wB;AACA,wB;AACA,K;AACA,iD;AACA,kD;AACA,mC;AACA,8C;AACA,K;AACA,I;;AAEA,K;AACA,+D;AACA,wB;AACA,wB;AACA,yB;AACA,K;AACA,sD;AACA,mC;AACA,6B;AACA,8B;AACA,+C;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,sE;AACA,wB;AACA,wB;AACA,wB;AACA,wB;AACA,I;AACA,K;AACA,oD;AACA,kC;AACA,kC;AACA,K;AACA,uC;AACA,mE;AACA,K;AACA,2C;AACA,6E;AACA,I;;AAEA,K;AACA,mE;AACA,wB;AACA,wB;AACA,Y;AACA,qB;AACA,K;AACA,0C;AACA,qC;AACA,uB;;AAEA,iC;AACA,iC;;AAEA,oC;AACA,+G;AACA,K;;AAEA,kC;AACA,kC;AACA,K;AACA,uC;AACA,mE;AACA,K;;AAEA,sF;;AAEA,6B;AACA,6B;AACA,+B;AACA,uC;;AAEA,oF;AACA,mH;;AAEA,+B;AACA,+E;;AAEA,qB;AACA,6D;AACA,qG;AACA,O;AACA,K;;AAEA,mF;;AAEA,0B;AACA,I;;AAEA,K;AACA,2G;AACA,mF;AACA,oC;AACA,wC;AACA,K;AACA,kC;AACA,kE;AACA,G;;AAEA,K;AACA,8I;AACA,sF;AACA,uC;AACA,6C;AACA,K;AACA,kC;AACA,wH;AACA,G;;AAEA,+E;AACA,8C;AACA,uD;AACA,wD;;AAEA,I;;AAEA,6E;;AAEA,mF;;;AAGA,K;AACA,mH;AACA,oB;AACA,K;AACA,4C;AACA,oD;AACA,gD;;AAEA,qC;AACA,oB;AACA,uC;AACA,sB;AACA,kD;AACA,qG;AACA,yD;AACA,4B;AACA,Y;AACA,O;AACA,U;AACA,K;AACA,8C;AACA,I;;AAEA,K;AACA,kH;AACA,mC;AACA,2B;AACA,K;AACA,sC;AACA,yB;AACA,mB;AACA,mE;AACA,2C;AACA,O;AACA,iB;AACA,K;AACA,mG;AACA,2C;AACA,K;AACA,8D;AACA,2C;AACA,K;AACA,wI;AACA,qB;AACA,K;AACA,U;AACA,sC;AACA,K;AACA,I;;AAEA,K;AACA,2E;AACA,uB;AACA,K;AACA,oC;AACA,sC;AACA,I;;AAEA,K;AACA,8E;AACA,uB;AACA,K;AACA,oC;AACA,oH;AACA,wC;AACA,K;AACA,iE;AACA,qC;AACA,oB;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,wH;AACA,mC;AACA,2B;AACA,K;AACA,sC;AACA,yB;AACA,mB;AACA,mE;AACA,2C;AACA,O;AACA,iB;AACA,K;AACA,U;AACA,wB;AACA,mE;;AAEA,oG;AACA,gD;AACA,O;AACA,qG;AACA,6C;AACA,O;AACA,gE;AACA,6C;AACA,O;AACA,0I;AACA,+E;AACA,O;AACA,Y;AACA,wC;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,0E;AACA,wB;AACA,qB;AACA,K;AACA,kD;AACA,sD;AACA,qC;AACA,4D;AACA,uC;AACA,K;AACA,6C;AACA,6B;AACA,8B;AACA,6B;AACA,gB;;AAEA,wB;AACA,6B;AACA,gB;AACA,O;AACA,sC;AACA,oC;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,wB;AACA,wB;AACA,qB;AACA,K;AACA,qC;AACA,uD;AACA,iB;AACA,iB;AACA,K;AACA,+E;AACA,iB;AACA,I;;AAEA,K;AACA,wE;AACA,wB;AACA,qB;AACA,K;AACA,kD;AACA,kB;AACA,sD;AACA,uC;AACA,+D;AACA,yC;AACA,K;AACA,M;AACA,oE;AACA,+C;AACA,8B;AACA,8B;AACA,+B;AACA,gB;;AAEA,wB;AACA,+B;AACA,gB;AACA,O;AACA,uC;AACA,sC;AACA,O;AACA,K;AACA,kB;AACA,I;;AAEA,K;AACA,sB;AACA,wB;AACA,qB;AACA,K;AACA,sC;AACA,yD;AACA,kF;AACA,kB;AACA,I;;AAEA,K;AACA,wC;AACA,qB;AACA,K;AACA,gC;AACA,qC;AACA,I;;AAEA,K;AACA,2C;AACA,qB;AACA,K;AACA,gC;AACA,6E;AACA,kE;AACA,4C;AACA,O;AACA,Y;AACA,6C;AACA,O;AACA,K;AACA,6C;AACA,kE;AACA,4C;AACA,O;AACA,6F;AACA,4C;AACA,O;AACA,Y;AACA,iB;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,uC;AACA,qB;AACA,K;AACA,gC;AACA,0D;AACA,I;;AAEA,K;AACA,yC;AACA,qB;AACA,K;AACA,gC;AACA,6D;AACA,I;;AAEA,K;AACA,qI;AACA,qB;AACA,K;AACA,wC;AACA,yF;AACA,I;;AAEA,K;AACA,sH;AACA,qB;AACA,K;AACA,uC;AACA,wF;AACA,I;;AAEA,K;AACA,2I;AACA,qB;AACA,K;AACA,wC;AACA,4F;AACA,I;;AAEA,K;AACA,yE;AACA,qB;AACA,K;AACA,uC;AACA,4F;AACA,I;;AAEA,K;AACA,gC;AACA,+F;AACA,K;AACA,2C;AACA,oC;AACA,iB;AACA,Y;AACA,oB;AACA,6D;AACA,qC;AACA,gB;AACA,O;AACA,wB;AACA,c;AACA,O;AACA,U;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,mC;AACA,sG;AACA,K;AACA,2C;AACA,mC;AACA,e;AACA,K;;AAEA,oC;AACA,kB;AACA,oB;AACA,mC;AACA,gB;AACA,O;AACA,wB;AACA,c;AACA,O;AACA,U;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,wE;AACA,gC;AACA,sB;AACA,K;AACA,kC;AACA,sD;AACA,I;;AAEA,K;AACA,2E;AACA,mC;AACA,sB;AACA,K;AACA,kC;AACA,sD;AACA,I;;AAEA,K;AACA,mE;AACA,wB;AACA,wB;AACA,6B;AACA,6B;AACA,6F;AACA,Y;AACA,sB;AACA,K;AACA,uE;AACA,4E;AACA,mB;AACA,K;AACA,4E;AACA,mB;AACA,K;AACA,wC;AACA,uF;AACA,qB;AACA,O;AACA,uF;AACA,qB;AACA,O;AACA,K;AACA,qD;AACA,qE;AACA,oI;AACA,sJ;AACA,K;AACA,sB;AACA,wC;AACA,8D;AACA,K;AACA,U;AACA,qF;AACA,K;;AAEA,gC;AACA,gB;AACA,I;;AAEA,+E;AACA,mD;AACA,8C;AACA,qD;AACA,K;AACA,0D;AACA,I;;AAEA,K;AACA,6C;AACA,Y;AACA,K;AACA,mC;AACA,yB;AACA,I;;AAEA,K;AACA,yB;AACA,Y;AACA,K;AACA,8B;;AAEA,8B;AACA,qF;AACA,8B;AACA,K;;;AAGA,iD;AACA,yB;;AAEA,qD;AACA,yC;;AAEA,6B;AACA,uC;AACA,mD;AACA,gD;AACA,8D;AACA,qC;AACA,W;AACA,S;AACA,iE;AACA,mH;AACA,gC;AACA,6B;AACA,S;AACA,O;AACA,K;;;AAGA,4D;AACA,+G;AACA,gB;AACA,mB;AACA,gB;AACA,qB;AACA,yB;AACA,oB;AACA,wB;AACA,I;;AAEA,K;AACA,iE;AACA,K;AACA,yB;AACA,0G;AACA,G;;AAEA,K;AACA,iC;AACA,sB;AACA,K;AACA,oC;AACA,2C;AACA,I;;AAEA,K;AACA,iC;AACA,Y;AACA,qB;AACA,K;AACA,kC;AACA,oB;AACA,I;;AAEA,qC;AACA,8C;AACA,I;;AAEA,yC;AACA,+C;AACA,I;;AAEA,wC;AACA,iD;AACA,I;;AAEA,0D;AACA,kE;AACA,I;;AAEA,mE;AACA,6E;AACA,I;;AAEA,qB;;AAEA,K;AACA,wG;AACA,Y;AACA,K;AACA,6C;AACA,+B;AACA,I;;AAEA,K;AACA,8B;AACA,Y;AACA,K;AACA,qC;AACA,8D;AACA,qC;AACA,K;AACA,I;;AAEA,K;AACA,yB;AACA,K;AACA,gE;AACA,E;;AAEA,qC;;AAEA,6B;AACA,e;AACA,qB;AACA,gB;AACA,iB;AACA,e;AACA,e;AACA,mB;AACA,mB;AACA,oB;AACA,kB;AACA,gB;AACA,W;AACA,a;AACA,a;AACA,oB;AACA,oB;AACA,kB;AACA,kB;AACA,sB;AACA,0B;AACA,uB;AACA,0B;AACA,oB;AACA,mB;AACA,kB;AACA,sB;AACA,8B;AACA,2B;AACA,+B;AACA,6B;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,yB;AACA,8B;AACA,8B;AACA,mB;AACA,4B;AACA,Y;AACA,6D;AACA,qC;AACA,qE;AACA,qB;AACA,O;AACA,K;AACA,gB;AACA,I;AACA,4B;AACA,Y;AACA,6D;AACA,qC;AACA,qE;AACA,qB;AACA,O;AACA,K;AACA,gB;AACA,I;AACA,6B;AACA,qB;AACA,oC;AACA,qB;AACA,4C;AACA,oC;AACA,0C;AACA,2B;AACA,kB;AACA,e;AACA,iB;AACA,qD;AACA,iB;AACA,kC;AACA,sB;AACA,e;AACA,wB;AACA,2B;AACA,6B;AACA,wB;AACA,0B;AACA,kG;AACA,yG;AACA,gB;AACA,E;AACA,+C;;AAEA,oB;AACA,e;;AAEA,uB;AACA,e;AACA,mB;AACA,4B;AACA,M;;AAEA,Y;AACA,6B;AACA,sC;AACA,mC;AACA,2C;AACA,sC;AACA,S;AACA,Q;;AAEA,oC;AACA,sC;AACA,oC;AACA,2C;AACA,sC;AACA,gB;AACA,8C;AACA,S;;;AAGA,Q;;AAEA,gC;AACA,sC;AACA,mC;AACA,2C;AACA,0J;AACA,S;AACA,O;AACA,M;;;;AAIA,qC;AACA,qG;AACA,K;;AAEA,mC;AACA,kF;AACA,K;;AAEA,8B;AACA,wD;AACA,K;;AAEA,G;;AAEA,wB;AACA,+B;AACA,G;;AAEA,W;AACA,G;AACA,+C;AACA,kG;AACA,iB;AACA,G;AACA,0B;AACA,2F;AACA,C;AACA,sB;;;AAGA,gE;AACA,qE;AACA,kD;AACA,iD;AACA,+B;AACA,M;AACA,+C;AACA,uD;AACA,iD;AACA,M;AACA,G;AACA,E;;AAEA,oG;AACA,8D;AACA,0C;AACA,uE;AACA,kB;AACA,K;AACA,2B;AACA,G;AACA,c;AACA,E;;AAEA,G;AACA,yE;AACA,6B;AACA,mL;AACA,qB;AACA,G;AACA,uD;AACA,8B;AACA,0B;AACA,kC;AACA,sF;AACA,U;AACA,gC;AACA,G;;AAEA,wB;AACA,6C;AACA,kB;AACA,K;AACA,2B;AACA,G;AACA,e;AACA,E;;AAEA,G;AACA,4C;AACA,uH;AACA,2E;AACA,0C;AACA,wB;AACA,mB;AACA,G;AACA,0C;AACA,Y;AACA,6B;AACA,yC;AACA,S;AACA,K;AACA,G;AACA,W;AACA,E;;AAEA,yC;AACA,wB;AACA,mD;AACA,uC;AACA,I;;AAEA,mD;AACA,c;AACA,6B;AACA,K;AACA,I;;AAEA,sD;AACA,8B;AACA,I;AACA,C;AACA,M;AACA,+D;AACA,mD;AACA,wE;AACA,I;;AAEA,mD;AACA,gD;AACA,kE;AACA,I;;AAEA,sD;AACA,2D;AACA,wD;AACA,+G;AACA,K;AACA,I;AACA,C;;AAEA,4D;AACA,4B;AACA,+C;AACA,G;AACA,oF;AACA,iC;AACA,kD;AACA,4C;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,yB;AACA,mE;AACA,wD;AACA,mH;AACA,iB;AACA,kB;AACA,G;AACA,E;AACA,6C;AACA,Y;AACA,qC;AACA,+B;AACA,G;AACA,E;;AAEA,qD;;AAEA,G;AACA,6D;AACA,iB;AACA,G;AACA,8D;AACA,2C;AACA,gC;AACA,G;AACA,Q;AACA,yC;AACA,G;AACA,E;;AAEA,G;AACA,mC;AACA,iB;AACA,G;AACA,8D;AACA,gE;AACA,mC;AACA,sE;AACA,8C;AACA,+C;AACA,kC;AACA,K;AACA,U;AACA,wD;AACA,0B;AACA,4D;AACA,K;AACA,I;AACA,C;AACA,Y;AACA,gE;AACA,mC;AACA,sE;AACA,8C;AACA,+C;AACA,2B;AACA,K;AACA,U;AACA,wD;AACA,0B;AACA,4D;AACA,K;AACA,I;AACA,C;;AAEA,G;AACA,8E;AACA,c;AACA,qB;AACA,G;AACA,8C;AACA,kB;AACA,oE;AACA,mD;AACA,mB;AACA,K;AACA,+E;AACA,0D;AACA,4E;AACA,6G;AACA,qG;AACA,4D;AACA,S;AACA,oG;AACA,uD;AACA,S;AACA,c;AACA,0D;AACA,S;AACA,O;AACA,Y;AACA,oE;AACA,O;AACA,K;AACA,6C;AACA,mB;AACA,K;AACA,2B;AACA,G;AACA,c;AACA,E;;AAEA,G;AACA,gH;AACA,E;AACA,4B;AACA,8D;AACA,G;AACA,2C;AACA,iB;AACA,c;AACA,a;AACA,Y;AACA,Q;;AAEA,qC;;AAEA,8F;AACA,4G;AACA,0D;AACA,uC;;AAEA,Y;AACA,0F;AACA,6F;AACA,M;AACA,G;AACA,+B;AACA,6B;AACA,kB;;AAEA,oC;AACA,8E;AACA,iC;AACA,Y;AACA,K;AACA,kC;AACA,gC;AACA,oB;AACA,G;;AAEA,8D;AACA,wD;AACA,wF;AACA,2D;AACA,yD;AACA,G;;AAEA,U;AACA,qB;AACA,kB;AACA,I;AACA,E;;AAEA,mD;AACA,2B;AACA,+B;AACA,6C;AACA,G;AACA,a;AACA,E;;AAEA,oD;AACA,2B;AACA,+B;AACA,8C;AACA,G;AACA,a;AACA,E;;AAEA,iD;AACA,wB;AACA,qD;AACA,G;AACA,Q;AACA,0B;AACA,G;AACA,E;;AAEA,kD;AACA,wB;AACA,sD;AACA,G;AACA,Q;AACA,2B;AACA,G;AACA,E;;AAEA,qD;AACA,0E;AACA,E;;AAEA,+C;AACA,0B;AACA,E;;AAEA,gD;AACA,8F;AACA,yE;AACA,6C;AACA,2D;AACA,sE;AACA,qE;AACA,wC;AACA,8E;AACA,4D;AACA,G;AACA,Q;AACA,6B;AACA,G;AACA,E;;AAEA,gD;AACA,+C;AACA,E;;AAEA,+C;AACA,6C;AACA,E;;AAEA,gE;AACA,gC;AACA,oD;AACA,U;AACA,gD;AACA,G;AACA,E;;AAEA,mE;AACA,mC;AACA,wD;AACA,U;AACA,gD;AACA,G;AACA,E;;;AAGA,c;AACA,wB;;AAEA,mC;AACA,gD;AACA,kC;AACA,gC;AACA,4B;AACA,gD;AACA,6B;AACA,oD;AACA,+D;AACA,uE;;AAEA,oD;AACA,2C;AACA,8B;AACA,6B;AACA,uC;;AAEA,qC;AACA,0F;AACA,qC;AACA,G;;AAEA,oD;AACA,uC;AACA,6B;AACA,K;AACA,6B;AACA,I;;AAEA,K;AACA,yC;AACA,4F;AACA,qB;AACA,K;AACA,qD;AACA,4B;AACA,+B;AACA,K;AACA,wC;AACA,iB;AACA,+C;AACA,sB;AACA,iB;AACA,O;AACA,oC;AACA,4B;AACA,yC;AACA,uC;AACA,4B;AACA,K;AACA,a;AACA,I;;AAEA,K;AACA,+C;AACA,qB;AACA,K;AACA,4D;AACA,yB;AACA,6B;AACA,yC;AACA,+C;AACA,qB;AACA,iB;AACA,O;AACA,oC;;AAEA,qD;AACA,K;AACA,I;;AAEA,K;AACA,sC;AACA,0G;AACA,wB;AACA,wB;AACA,2B;AACA,K;AACA,kE;AACA,4B;AACA,mB;AACA,K;AACA,+B;AACA,iB;AACA,wC;AACA,K;AACA,wC;AACA,uC;AACA,2B;AACA,yC;AACA,wC;AACA,qB;AACA,K;AACA,I;;AAEA,2B;AACA,wF;AACA,iD;AACA,4C;AACA,+B;AACA,iC;;AAEA,8C;AACA,sC;AACA,4B;AACA,6B;AACA,sC;AACA,gC;AACA,iC;AACA,oC;AACA,6B;;AAEA,mE;AACA,+B;AACA,oC;AACA,+B;AACA,yC;;AAEA,mE;;AAEA,qB;AACA,G;;AAEA,K;AACA,gE;AACA,2B;AACA,K;AACA,oD;AACA,0C;AACA,kE;AACA,K;AACA,gC;AACA,I;;AAEA,6D;AACA,wC;AACA,iB;AACA,I;;AAEA,wC;AACA,wC;AACA,iB;AACA,I;;AAEA,iG;AACA,2C;AACA,oB;AACA,I;;AAEA,K;AACA,kE;AACA,K;AACA,2E;AACA,yB;AACA,kC;AACA,oC;AACA,0B;AACA,yF;AACA,Y;AACA,iF;AACA,K;AACA,I;;AAEA,sD;AACA,kB;;AAEA,gF;AACA,sC;AACA,wG;AACA,8C;AACA,Y;AACA,gB;AACA,K;AACA,I;;AAEA,wD;AACA,sD;AACA,6B;AACA,6E;AACA,qC;AACA,K;AACA,I;;AAEA,K;;;AAGA,yB;AACA,wB;AACA,C;;AAEA,yE;;AAEA,iD;AACA,kB;AACA,6C;AACA,G;;AAEA,iC;AACA,iC;AACA,G;;AAEA,sD;;AAEA,4C;AACA,kE;AACA,mC;AACA,2C;AACA,qC;AACA,e;AACA,kB;AACA,4C;AACA,W;AACA,S;;AAEA,4C;AACA,mC;AACA,mD;AACA,iC;AACA,yC;AACA,e;AACA,e;AACA,kB;AACA,gD;AACA,uC;AACA,a;AACA,W;AACA,S;;AAEA,mC;AACA,Q;;AAEA,oC;AACA,yB;AACA,qB;AACA,2B;AACA,oC;AACA,S;;AAEA,oC;AACA,6D;AACA,c;AACA,yD;AACA,O;;AAEA,gD;AACA,M;AACA,sD;AACA,+C;AACA,qB;AACA,iD;;AAEA,+D;AACA,uD;AACA,qB;AACA,W;;AAEA,iD;AACA,kD;AACA,uF;AACA,kB;AACA,+E;AACA,W;;AAEA,oD;AACA,S;AACA,O;AACA,M;AACA,+B;AACA,+C;AACA,oB;AACA,gD;AACA,+D;AACA,O;AACA,M;AACA,0C;AACA,qB;AACA,sB;AACA,2C;AACA,qB;AACA,kB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,uB;AACA,sB;AACA,wB;AACA,uB;AACA,kB;AACA,gC;AACA,Q;;AAEA,gB;AACA,mC;AACA,oD;AACA,uE;AACA,uC;AACA,6E;AACA,6E;AACA,6E;;AAEA,c;AACA,6C;AACA,O;;;;AAIA,kC;AACA,qC;AACA,c;AACA,8C;AACA,O;AACA,M;;AAEA,U;AACA,+B;AACA,qC;AACA,uB;AACA,wB;AACA,G;AACA,E;;AAEA,G;AACA,qC;AACA,2B;AACA,G;AACA,8C;AACA,iB;;;AAGA,0D;AACA,2B;AACA,yC;;;AAGA,iE;AACA,qB;AACA,4L;AACA,G;;AAEA,iE;AACA,kD;;AAEA,8C;AACA,6B;AACA,+C;AACA,gC;AACA,+C;AACA,gC;;AAEA,yB;;;AAGA,wE;;AAEA,yF;AACA,qD;AACA,2B;AACA,6B;AACA,2G;AACA,K;AACA,K;;AAEA,yF;AACA,+D;AACA,kC;AACA,K;AACA,K;;AAEA,kB;AACA,kC;AACA,uB;AACA,I;;AAEA,4F;AACA,wF;AACA,kC;AACA,K;;AAEA,wB;;AAEA,qE;AACA,0B;AACA,K;AACA,K;;AAEA,6F;AACA,4B;;AAEA,sB;AACA,mD;AACA,K;;AAEA,gI;AACA,iD;AACA,4B;AACA,4H;AACA,S;AACA,2C;AACA,0C;AACA,S;AACA,+B;AACA,O;AACA,K;;AAEA,mE;;AAEA,8C;AACA,8B;AACA,K;AACA,U;AACA,+B;AACA,K;AACA,K;;;;AAIA,6E;AACA,0C;AACA,a;AACA,K;;AAEA,6D;AACA,qG;AACA,2B;AACA,K;;AAEA,wC;AACA,qF;AACA,8B;AACA,mD;AACA,sC;AACA,qE;AACA,gD;AACA,O;AACA,4C;AACA,iC;AACA,K;AACA,I;;AAEA,oB;AACA,8B;AACA,2B;AACA,e;AACA,iB;AACA,yB;AACA,oC;AACA,oC;AACA,sG;AACA,U;AACA,sD;AACA,0E;AACA,S;AACA,O;AACA,O;AACA,8B;AACA,wB;AACA,e;AACA,iB;AACA,yB;AACA,qC;AACA,oC;AACA,oG;AACA,U;AACA,wD;AACA,yE;AACA,S;AACA,O;AACA,O;AACA,8B;AACA,6B;AACA,+D;AACA,iE;AACA,O;AACA,8B;AACA,wB;AACA,e;AACA,iB;AACA,oB;AACA,oC;AACA,O;AACA,M;AACA,I;AACA,qC;AACA,kC;AACA,uC;AACA,kC;;AAEA,2B;AACA,wB;AACA,iC;AACA,M;AACA,iB;AACA,qC;AACA,iC;AACA,kC;AACA,qC;AACA,mC;AACA,4C;AACA,M;AACA,+B;AACA,wC;AACA,M;AACA,+C;AACA,6B;AACA,mB;AACA,oC;AACA,uC;AACA,0C;AACA,W;AACA,O;AACA,0E;AACA,iB;AACA,M;AACA,gC;;AAEA,mB;AACA,oC;AACA,uC;AACA,0C;AACA,W;AACA,O;AACA,6E;AACA,iB;AACA,M;AACA,sC;AACA,qC;AACA,2C;;AAEA,6C;AACA,8D;AACA,mE;;AAEA,4D;;AAEA,yE;AACA,wG;;AAEA,M;AACA,2B;AACA,4C;AACA,6C;AACA,M;AACA,uD;AACA,wB;AACA,yB;;AAEA,yB;;AAEA,mF;;AAEA,yD;;AAEA,mD;;AAEA,kG;AACA,sB;AACA,S;AACA,kC;AACA,mD;AACA,mD;AACA,W;AACA,S;AACA,c;AACA,iD;AACA,iC;AACA,uF;AACA,iE;AACA,a;AACA,iC;AACA,uF;AACA,iE;AACA,a;AACA,W;AACA,gB;AACA,qD;AACA,W;AACA,S;;AAEA,oF;;AAEA,gC;AACA,O;AACA,M;AACA,yD;AACA,uE;AACA,4F;AACA,M;AACA,S;AACA,uD;AACA,yB;AACA,iE;AACA,0B;AACA,+D;AACA,kG;AACA,c;AACA,iD;AACA,S;AACA,c;AACA,0B;AACA,iC;AACA,+B;AACA,4G;AACA,+D;AACA,W;;AAEA,8B;AACA,+B;AACA,4G;AACA,+D;AACA,W;AACA,S;AACA,O;;AAEA,kF;AACA,8B;AACA,M;AACA,6C;AACA,6B;AACA,4E;AACA,M;AACA,kC;AACA,+B;AACA,M;AACA,8B;AACA,yB;AACA,M;AACA,qC;AACA,iD;AACA,M;AACA,uC;AACA,mD;AACA,M;AACA,8D;AACA,uE;AACA,M;AACA,sC;AACA,6C;AACA,M;AACA,wC;AACA,+C;AACA,M;AACA,oD;AACA,qD;AACA,8F;AACA,iH;AACA,O;AACA,oE;AACA,M;AACA,uD;AACA,wD;AACA,uG;AACA,0H;AACA,O;AACA,uE;AACA,K;AACA,I;;AAEA,+E;;AAEA,+C;AACA,0B;;AAEA,8F;AACA,gL;AACA,iD;AACA,gC;AACA,K;AACA,K;;AAEA,gG;AACA,gL;AACA,iD;AACA,gC;AACA,K;AACA,K;;;AAGA,qF;AACA,6C;AACA,oC;AACA,6C;AACA,sB;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,yE;AACA,wC;AACA,kB;AACA,G;AACA,sF;AACA,kB;AACA,G;AACA,e;AACA,E;;AAEA,6D;AACA,qD;AACA,iD;AACA,E;;AAEA,kE;AACA,iE;AACA,iK;AACA,G;AACA,E;;AAEA,4D;AACA,iE;AACA,gK;AACA,G;AACA,E;;AAEA,uD;AACA,+C;AACA,wC;AACA,oE;AACA,E;;AAEA,G;AACA,sC;AACA,wC;AACA,2B;AACA,G;AACA,+E;AACA,4C;AACA,6C;AACA,gE;AACA,gB;AACA,G;AACA,Q;AACA,c;AACA,G;AACA,E;;AAEA,G;AACA,+B;AACA,wC;AACA,G;AACA,qE;AACA,iC;AACA,E;;AAEA,G;AACA,oC;AACA,a;AACA,Y;AACA,G;AACA,uE;AACA,0C;AACA,0C;;AAEA,6B;AACA,+B;;AAEA,iB;AACA,0E;AACA,U;AACA,8I;AACA,G;;AAEA,wB;AACA,6B;;AAEA,sB;;AAEA,sE;AACA,E;;AAEA,G;AACA,uC;AACA,a;AACA,Y;AACA,G;AACA,uE;AACA,yC;AACA,4C;;AAEA,6B;AACA,+B;;AAEA,iB;AACA,0E;AACA,U;AACA,8I;AACA,G;AACA,wB;;AAEA,6B;AACA,sB;AACA,sE;AACA,E;;AAEA,G;AACA,kJ;AACA,6B;AACA,mB;AACA,G;AACA,qF;AACA,8D;AACA,6C;AACA,qC;AACA,E;;AAEA,G;AACA,mJ;AACA,4B;AACA,mB;AACA,G;AACA,qF;AACA,gE;AACA,8C;AACA,uC;AACA,E;;AAEA,iE;AACA,mC;AACA,E;;AAEA,wD;AACA,oB;AACA,4B;AACA,E;;AAEA,G;AACA,+F;AACA,G;AACA,0B;AACA,e;;AAEA,0C;AACA,yB;;AAEA,mB;AACA,wB;;AAEA,+C;AACA,6C;AACA,6D;AACA,O;;AAEA,yC;AACA,K;;AAEA,G;;AAEA,iC;AACA,8C;;AAEA,0B;;AAEA,O;AACA,wC;AACA,iC;AACA,oC;AACA,O;AACA,wD;AACA,qD;AACA,2C;AACA,mD;AACA,O;AACA,uD;AACA,M;;AAEA,O;AACA,mD;AACA,sD;AACA,sC;AACA,O;AACA,mD;AACA,iB;AACA,4C;AACA,yD;AACA,gD;AACA,S;AACA,yD;AACA,O;AACA,+C;AACA,mD;AACA,O;AACA,Y;AACA,uF;AACA,O;;AAEA,oB;AACA,4E;AACA,O;;AAEA,6C;AACA,K;;AAEA,I;;;AAGA,iB;;AAEA,wB;AACA,e;;AAEA,mE;AACA,oB;AACA,+C;AACA,0B;;AAEA,2D;;AAEA,qB;;AAEA,4B;;AAEA,iC;;AAEA,sC;AACA,iB;AACA,S;;AAEA,iE;;AAEA,uB;AACA,iB;AACA,S;;AAEA,2D;;AAEA,qD;;AAEA,2C;AACA,uC;AACA,sJ;;AAEA,4C;AACA,yG;AACA,oC;AACA,uB;AACA,e;AACA,a;;AAEA,iG;;AAEA,sC;;AAEA,gC;AACA,iC;AACA,6D;;AAEA,2C;AACA,+D;AACA,8C;AACA,mB;AACA,wB;;AAEA,uC;;AAEA,0E;AACA,6D;AACA,mB;;AAEA,kD;;AAEA,yC;AACA,6D;AACA,6E;AACA,wB;;AAEA,yC;AACA,0E;AACA,6D;AACA,mB;;AAEA,oD;;AAEA,yC;AACA,6D;AACA,6E;AACA,wB;;AAEA,0C;AACA,0E;AACA,6D;AACA,mB;;AAEA,qD;;AAEA,yC;AACA,6D;AACA,6E;AACA,wB;;AAEA,yC;AACA,yE;AACA,6D;AACA,mB;;AAEA,oD;;AAEA,yC;AACA,6D;AACA,6E;AACA,wB;;AAEA,kC;AACA,uI;AACA,uC;AACA,iG;AACA,mB;AACA,wB;AACA,mI;AACA,mB;AACA,yC;AACA,6D;AACA,6E;AACA,wB;;AAEA,wC;AACA,qC;AACA,yC;AACA,uC;AACA,yC;AACA,wB;;AAEA,0C;AACA,oC;AACA,wF;AACA,wB;;AAEA,uD;AACA,4C;;AAEA,iF;AACA,+D;AACA,qB;;AAEA,4D;;AAEA,0B;;AAEA,mE;AACA,wC;AACA,4B;AACA,8D;AACA,qB;;AAEA,mB;;AAEA,sE;AACA,oF;AACA,wB;;AAEA,qC;AACA,4C;AACA,sE;AACA,mB;AACA,yC;AACA,wB;;AAEA,mC;AACA,uD;AACA,wF;AACA,mB;AACA,wB;AACA,wF;AACA,mB;AACA,mE;AACA,6D;AACA,6E;AACA,wB;;AAEA,kC;AACA,uD;AACA,+G;AACA,mB;AACA,wB;AACA,+G;AACA,mB;AACA,mE;AACA,6D;AACA,6E;AACA,wB;;AAEA,sC;AACA,4E;AACA,oE;AACA,6D;AACA,6E;AACA,wB;;AAEA,wC;AACA,2E;AACA,sE;AACA,6D;AACA,6E;AACA,wB;AACA,e;;AAEA,W;AACA,S;AACA,O;;AAEA,uE;AACA,iC;AACA,S;;AAEA,uE;AACA,sD;AACA,S;;AAEA,gD;AACA,qD;AACA,4B;AACA,S;AACA,O;;AAEA,4D;;AAEA,kD;AACA,yB;AACA,S;;AAEA,iD;AACA,qI;;AAEA,uB;AACA,yF;AACA,S;AACA,c;AACA,yH;AACA,S;AACA,O;;AAEA,yC;AACA,uB;AACA,wC;AACA,S;AACA,c;AACA,0C;AACA,S;AACA,O;;AAEA,2C;AACA,uB;AACA,6E;AACA,S;AACA,c;AACA,+D;AACA,S;AACA,O;;AAEA,4C;AACA,uB;AACA,uC;AACA,S;AACA,c;AACA,yC;AACA,S;AACA,O;;AAEA,2C;AACA,uB;AACA,wC;AACA,S;AACA,c;AACA,0C;AACA,S;AACA,O;AACA,M;;AAEA,O;AACA,wC;AACA,sC;AACA,O;AACA,oD;AACA,uC;AACA,M;;AAEA,wC;AACA,0B;AACA,M;;AAEA,O;AACA,4D;AACA,O;AACA,sC;;AAEA,oD;;AAEA,2D;AACA,wB;AACA,iC;AACA,W;AACA,W;;AAEA,e;AACA,O;;AAEA,4C;AACA,4C;AACA,yC;AACA,0C;AACA,2D;AACA,0D;;AAEA,+D;AACA,2E;;AAEA,8E;;AAEA,M;;AAEA,uC;AACA,qC;AACA,M;;AAEA,+C;AACA,iD;AACA,gD;AACA,O;AACA,M;;AAEA,4E;;AAEA,yB;AACA,sB;AACA,0B;AACA,S;AACA,O;AACA,Y;AACA,6E;AACA,O;AACA,M;;AAEA,wD;AACA,+C;AACA,M;;AAEA,iE;AACA,8C;AACA,M;;AAEA,W;AACA,I;;AAEA,iB;;AAEA,G;AACA,oG;AACA,G;AACA,0B;AACA,e;;AAEA,+B;;AAEA,4B;;AAEA,O;AACA,0C;AACA,mC;AACA,yC;AACA,O;AACA,iE;AACA,0D;AACA,M;;AAEA,O;AACA,6D;AACA,2C;AACA,O;AACA,0C;AACA,6C;AACA,4B;AACA,O;;AAEA,2C;AACA,yF;AACA,O;;AAEA,mD;AACA,8E;AACA,O;;AAEA,+C;AACA,K;;AAEA,I;;;AAGA,iB;;AAEA,yB;;AAEA,G;AACA,2D;AACA,0B;AACA,oB;AACA,G;AACA,0D;AACA,oC;AACA,6C;AACA,iD;AACA,mD;AACA,oD;AACA,2D;AACA,4C;AACA,E;;AAEA,oD;AACA,6C;AACA,kB;AACA,wB;AACA,sB;AACA,wB;AACA,yB;AACA,kB;AACA,iB;AACA,oB;AACA,uB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,uB;AACA,qB;AACA,mB;AACA,oB;AACA,mB;AACA,uB;AACA,gB;AACA,I;;AAEA,yC;AACA,E;;AAEA,oD;;AAEA,yC;;AAEA,gG;AACA,E;;AAEA,G;AACA,6B;AACA,e;AACA,mB;AACA,G;AACA,kD;AACA,yB;AACA,kB;AACA,kB;AACA,wB;;AAEA,kB;AACA,2B;AACA,kB;AACA,O;AACA,Y;AACA,gC;AACA,O;;AAEA,qB;AACA,gB;;AAEA,Y;AACA,8B;AACA,G;AACA,E;;AAEA,G;AACA,wE;AACA,e;AACA,oB;AACA,G;AACA,+D;AACA,2B;AACA,uB;AACA,a;AACA,wB;AACA,iC;AACA,iE;AACA,sD;AACA,G;AACA,qB;AACA,E;;AAEA,G;AACA,wD;AACA,kB;AACA,kB;AACA,mB;AACA,G;AACA,0E;AACA,2D;AACA,yD;;AAEA,e;AACA,O;AACA,Q;;AAEA,kC;AACA,iB;AACA,oC;AACA,wE;AACA,K;AACA,mB;AACA,G;AACA,c;AACA,C;;AAEA,gF;AACA,2D;AACA,yD;;AAEA,e;AACA,O;AACA,Q;;AAEA,kC;AACA,iB;AACA,oC;AACA,+E;AACA,K;AACA,mB;AACA,G;AACA,c;AACA,C;;AAEA,G;AACA,wC;AACA,yC;AACA,W;AACA,qB;AACA,G;AACA,8C;AACA,qB;AACA,qD;AACA,8C;AACA,yC;AACA,0F;AACA,iG;AACA,E;;AAEA,G;AACA,qF;AACA,gE;AACA,G;AACA,gD;AACA,mC;AACA,E;;AAEA,G;AACA,gI;AACA,8D;AACA,6E;AACA,sC;AACA,uC;AACA,yC;AACA,G;AACA,wD;AACA,wC;AACA,iC;AACA,sC;AACA,e;AACA,E;;AAEA,G;AACA,4E;AACA,wE;AACA,gG;AACA,G;AACA,2D;AACA,4B;AACA,sC;AACA,+B;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,yE;AACA,wE;AACA,gG;AACA,G;AACA,+D;AACA,8B;AACA,wC;AACA,iE;AACA,2B;AACA,8C;AACA,6B;AACA,W;AACA,gB;AACA,6B;AACA,W;AACA,S;AACA,oE;AACA,O;AACA,Y;AACA,qC;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,kC;AACA,mG;AACA,oD;AACA,mB;AACA,G;AACA,gD;AACA,gC;AACA,2C;AACA,G;AACA,Q;AACA,e;AACA,G;AACA,E;;AAEA,qD;AACA,gB;;AAEA,uC;AACA,8B;AACA,U;AACA,uB;AACA,sC;;AAEA,+C;AACA,mC;;AAEA,kC;AACA,8D;AACA,gE;AACA,O;;;AAGA,K;;AAEA,4E;;AAEA,G;;AAEA,mB;AACA,E;;AAEA,G;AACA,oC;AACA,+B;AACA,8B;AACA,kC;AACA,G;AACA,2E;AACA,+B;;AAEA,4D;;AAEA,4B;AACA,4D;AACA,uD;AACA,G;;AAEA,wB;AACA,E;;AAEA,+D;AACA,O;AACA,U;AACA,O;AACA,U;AACA,iB;AACA,e;;AAEA,mD;AACA,wD;AACA,sB;AACA,wB;AACA,e;AACA,O;AACA,iC;AACA,K;AACA,G;AACA,gB;AACA,E;;AAEA,gD;AACA,W;AACA,wB;AACA,oB;AACA,sB;AACA,Q;AACA,G;AACA,E;;AAEA,6D;AACA,W;AACA,8B;AACA,oB;AACA,2B;AACA,Q;AACA,G;AACA,E;;AAEA,G;AACA,yD;AACA,8D;AACA,+B;AACA,qB;AACA,G;AACA,kD;AACA,+C;;AAEA,+C;AACA,C;;AAEA,G;AACA,+E;AACA,8D;AACA,+B;AACA,qB;AACA,G;AACA,yD;AACA,sG;AACA,E;;AAEA,+B;AACA,gB;AACA,iB;AACA,kB;AACA,e;AACA,a;AACA,a;AACA,a;AACA,U;AACA,Y;AACA,a;AACA,mB;AACA,mB;AACA,oB;AACA,U;AACA,W;AACA,gB;AACA,c;AACA,c;AACA,Y;AACA,Y;AACA,gB;AACA,S;AACA,kB;AACA,iB;AACA,e;AACA,iB;AACA,U;AACA,U;AACA,U;AACA,U;AACA,U;AACA,U;AACA,U;AACA,U;AACA,U;AACA,W;AACA,W;AACA,W;AACA,Q;AACA,Q;AACA,Q;AACA,O;AACA,E;;AAEA,G;AACA,qD;AACA,+C;AACA,iB;AACA,qB;AACA,G;AACA,+C;AACA,kE;AACA,E;;AAEA,4C;AACA,sB;;AAEA,+D;AACA,sB;AACA,G;;AAEA,4B;AACA,+B;;AAEA,oC;AACA,sC;AACA,yB;AACA,2B;AACA,O;;AAEA,mC;AACA,K;AACA,G;;AAEA,oB;;AAEA,E;;AAEA,qD;AACA,sB;AACA,yC;AACA,I;AACA,E;;AAEA,G;AACA,gH;AACA,kE;AACA,E;AACA,iH;AACA,4C;AACA,E;AACA,mG;AACA,E;AACA,sH;AACA,mC;AACA,E;AACA,E;AACA,8G;AACA,+H;AACA,sB;AACA,G;AACA,qF;;AAEA,gF;;AAEA,+C;;AAEA,0D;;AAEA,uB;;AAEA,wD;;AAEA,O;AACA,kI;;AAEA,iE;;AAEA,8G;;AAEA,iB;;AAEA,gD;AACA,yD;AACA,S;;AAEA,0D;;AAEA,8C;AACA,4D;AACA,oC;AACA,sF;AACA,S;;AAEA,O;;AAEA,qF;;AAEA,kE;;AAEA,I;;AAEA,gD;AACA,gD;;AAEA,mC;AACA,2M;AACA,K;;AAEA,gB;AACA,G;;AAEA,E;;AAEA,4D;AACA,kB;AACA,oC;AACA,G;AACA,4F;;AAEA,mD;AACA,I;AACA,wD;AACA,a;AACA,gB;AACA,Y;AACA,4G;AACA,oB;AACA,Y;AACA,gB;AACA,sD;AACA,Y;AACA,mB;AACA,yD;AACA,Y;AACA,mB;AACA,0D;AACA,Y;AACA,Y;AACA,0D;AACA,Y;AACA,M;AACA,E;;AAEA,oD;AACA,oC;AACA,E;;AAEA,wD;AACA,Q;AACA,qE;AACA,sD;AACA,4B;AACA,G;AACA,Q;AACA,8B;AACA,G;AACA,E;;AAEA,8C;AACA,oB;AACA,uB;AACA,G;;AAEA,0D;AACA,2C;;AAEA,iB;AACA,E;;AAEA,8C;AACA,oB;AACA,uB;AACA,G;;AAEA,wD;AACA,0C;;AAEA,iB;AACA,E;;AAEA,0B;AACA,e;;AAEA,K;AACA,6H;AACA,qF;AACA,2D;AACA,I;AACA,oB;AACA,gB;AACA,wB;AACA,iB;AACA,K;AACA,kE;AACA,6B;AACA,qB;AACA,qC;AACA,uD;;AAEA,6B;AACA,qE;AACA,K;AACA,U;AACA,2B;AACA,K;AACA,qB;AACA,I;;AAEA,0D;AACA,qE;;AAEA,uE;AACA,e;AACA,6B;AACA,kB;AACA,0B;AACA,oC;AACA,qE;AACA,yD;AACA,W;AACA,gB;AACA,6B;AACA,W;AACA,S;AACA,O;AACA,K;AACA,U;AACA,kB;AACA,K;AACA,kB;AACA,I;;AAEA,4F;AACA,gB;AACA,yC;AACA,kB;AACA,kB;AACA,K;AACA,+D;AACA,yB;AACA,uC;AACA,mC;AACA,8B;AACA,2C;AACA,mD;;AAEA,sB;AACA,W;AACA,gB;AACA,6E;AACA,W;AACA,S;AACA,O;AACA,K;AACA,mB;AACA,I;;AAEA,0D;AACA,2C;AACA,wC;AACA,0G;AACA,K;AACA,6B;AACA,yC;AACA,sD;AACA,kB;AACA,yD;;AAEA,mD;AACA,mD;AACA,sD;AACA,S;;AAEA,O;AACA,K;AACA,U;AACA,wC;AACA,K;AACA,I;;AAEA,6D;AACA,sE;AACA,iF;AACA,sC;AACA,K;AACA,U;AACA,iB;AACA,K;AACA,I;;AAEA,8D;AACA,Y;AACA,+D;AACA,0C;AACA,Y;AACA,iB;AACA,K;AACA,sE;AACA,e;AACA,I;;AAEA,0D;AACA,wD;AACA,iB;AACA,yC;AACA,wB;AACA,O;AACA,oB;AACA,K;AACA,2B;AACA,I;;AAEA,K;AACA,gD;AACA,iG;AACA,K;AACA,6F;AACA,W;AACA,4C;AACA,+B;AACA,qB;;AAEA,kB;AACA,iB;AACA,K;;AAEA,0E;AACA,wC;AACA,K;;AAEA,yB;AACA,sD;AACA,iF;;AAEA,+C;AACA,iB;AACA,4C;AACA,yB;AACA,S;AACA,O;AACA,uD;AACA,4D;AACA,O;AACA,Y;AACA,iB;AACA,8D;AACA,O;;AAEA,gD;AACA,kC;AACA,O;AACA,Y;AACA,8C;AACA,O;;AAEA,4B;AACA,qB;AACA,K;;;AAGA,8G;AACA,sE;;AAEA,+B;AACA,I;;AAEA,K;AACA,+C;AACA,uG;AACA,2C;AACA,K;AACA,6F;AACA,qF;AACA,mF;AACA,oH;AACA,wF;AACA,K;AACA,wC;AACA,8B;AACA,mB;AACA,+B;AACA,qB;;AAEA,kB;AACA,iB;AACA,K;;AAEA,yB;;AAEA,sD;AACA,iF;AACA,4G;AACA,4E;AACA,wC;AACA,+C;AACA,yB;AACA,W;AACA,6B;AACA,S;AACA,qC;AACA,mD;AACA,O;AACA,Y;AACA,wC;AACA,gD;AACA,S;AACA,oD;AACA,sE;AACA,O;;AAEA,4B;AACA,qB;AACA,K;;AAEA,8G;AACA,sE;;AAEA,+B;AACA,I;;AAEA,K;AACA,oC;AACA,oH;AACA,kH;AACA,K;AACA,uE;AACA,kB;AACA,iB;AACA,K;AACA,oC;AACA,sB;AACA,K;;AAEA,4E;;AAEA,0G;AACA,8D;;AAEA,4G;;AAEA,0C;AACA,a;AACA,K;;AAEA,+B;AACA,qD;AACA,4C;AACA,O;;AAEA,oB;AACA,8C;;AAEA,2E;;AAEA,sE;AACA,I;;AAEA,K;AACA,uC;AACA,0H;AACA,wH;AACA,K;AACA,uE;AACA,qF;AACA,kG;AACA,K;AACA,kB;AACA,iB;AACA,K;AACA,oC;AACA,sB;AACA,K;;AAEA,4E;;AAEA,4G;;AAEA,0C;AACA,a;AACA,K;;AAEA,+B;AACA,sE;AACA,oC;AACA,K;AACA,mD;;AAEA,2E;AACA,sE;AACA,I;;AAEA,K;AACA,uC;AACA,2E;AACA,8H;AACA,qI;AACA,0J;AACA,K;AACA,6F;AACA,4E;;AAEA,kD;AACA,uD;AACA,8C;;AAEA,qD;AACA,c;AACA,wB;AACA,kE;AACA,U;AACA,K;AACA,4C;AACA,mF;;AAEA,mB;AACA,I;;AAEA,K;AACA,oC;AACA,wE;AACA,8H;AACA,qI;AACA,0J;AACA,K;AACA,6F;AACA,4E;;AAEA,wD;AACA,uD;AACA,8C;;AAEA,qD;AACA,c;AACA,wB;AACA,kE;AACA,U;AACA,K;AACA,qF;;AAEA,mB;AACA,I;;AAEA,K;AACA,6C;AACA,wB;AACA,yB;AACA,K;AACA,6D;AACA,sE;AACA,6D;AACA,mC;AACA,qC;AACA,iB;AACA,oB;AACA,O;AACA,4D;AACA,6B;AACA,yC;AACA,sB;AACA,S;AACA,O;AACA,iB;AACA,K;AACA,0C;AACA,S;AACA,qE;AACA,6C;AACA,Q;AACA,wB;AACA,2C;AACA,6C;AACA,0C;AACA,mB;AACA,sC;AACA,iB;AACA,iB;AACA,S;AACA,wC;AACA,Y;AACA,e;AACA,Y;AACA,K;AACA,U;AACA,sE;AACA,K;AACA,I;;AAEA,sF;;AAEA,K;AACA,sG;AACA,wB;AACA,yB;AACA,qB;AACA,K;AACA,qE;AACA,wE;AACA,iC;AACA,K;AACA,c;AACA,I;;AAEA,K;AACA,yC;AACA,wB;AACA,yB;AACA,0B;AACA,8D;AACA,K;AACA,4E;AACA,8F;AACA,6D;AACA,mC;AACA,qC;AACA,gE;;AAEA,mD;AACA,8B;AACA,S;AACA,6B;AACA,O;AACA,6B;AACA,K;AACA,0C;AACA,+C;AACA,iC;AACA,Y;AACA,e;AACA,mB;AACA,K;AACA,U;AACA,yC;AACA,K;AACA,I;;AAEA,K;AACA,2G;AACA,0F;AACA,sE;AACA,K;AACA,mF;AACA,8C;AACA,oD;AACA,uB;AACA,8B;AACA,Y;;AAEA,mD;AACA,8E;AACA,0B;;AAEA,qB;AACA,kB;AACA,K;;AAEA,qB;AACA,I;;AAEA,K;AACA,0B;AACA,K;AACA,sD;AACA,yD;AACA,2D;AACA,2C;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,2B;AACA,oB;AACA,K;AACA,uD;AACA,2B;AACA,I;;AAEA,K;AACA,gC;AACA,mD;AACA,+C;AACA,2D;AACA,oB;AACA,K;AACA,gF;AACA,2C;AACA,mG;AACA,wC;AACA,wC;AACA,4D;AACA,e;AACA,8D;AACA,yD;AACA,O;AACA,uB;AACA,K;AACA,kB;AACA,I;;AAEA,K;AACA,gD;AACA,8D;AACA,0D;AACA,qB;AACA,K;AACA,kE;AACA,qF;AACA,I;;AAEA,K;AACA,gH;AACA,8D;AACA,0D;AACA,qB;AACA,K;AACA,0E;AACA,gG;AACA,I;;AAEA,iB;;AAEA,0B;AACA,e;;AAEA,I;AACA,qE;AACA,K;AACA,yG;AACA,mC;AACA,wB;AACA,qE;AACA,c;AACA,gD;AACA,O;;AAEA,K;;AAEA,kC;AACA,0E;AACA,K;;AAEA,gF;AACA,yE;AACA,K;;AAEA,kF;AACA,wE;AACA,K;;AAEA,+C;AACA,6E;AACA,K;AACA,G;;AAEA,iB;AACA,G;AACA,wB;AACA,iD;AACA,iD;AACA,sB;AACA,sB;AACA,uD;AACA,yF;AACA,sF;AACA,G;AACA,0B;AACA,e;;AAEA,qF;;AAEA,gE;;AAEA,+C;AACA,yC;AACA,K;;AAEA,uD;;AAEA,0C;AACA,iC;AACA,wD;AACA,4C;AACA,2D;AACA,6C;AACA,wD;AACA,+B;AACA,K;AACA,U;AACA,4K;AACA,K;;AAEA,I;;AAEA,+E;AACA,qD;AACA,gE;;AAEA,iB;;AAEA,0B;;AAEA,sD;AACA,sD;;AAEA,oD;AACA,kD;AACA,2J;AACA,yH;;AAEA,uD;AACA,qC;AACA,+B;AACA,4B;AACA,I;;AAEA,K;AACA,0B;AACA,mD;AACA,mD;AACA,wB;AACA,wB;AACA,yD;AACA,2F;AACA,wF;AACA,K;AACA,6F;;AAEA,sF;AACA,kF;;AAEA,6F;;AAEA,0B;AACA,oD;;;AAGA,kE;AACA,4E;AACA,mJ;AACA,+H;AACA,K;;;;AAIA,oC;AACA,6D;;AAEA,0C;AACA,mD;AACA,4E;AACA,uG;AACA,S;AACA,Q;;AAEA,+F;;AAEA,yE;AACA,wD;AACA,6B;AACA,S;;AAEA,K;AACA,I;;AAEA,2D;AACA,qE;AACA,gF;AACA,iB;;AAEA,G;AACA,oB;AACA,iD;AACA,iD;AACA,sB;AACA,sB;AACA,uD;AACA,yF;AACA,sF;AACA,G;AACA,0B;;AAEA,e;;AAEA,sD;AACA,sD;AACA,kC;AACA,oD;;AAEA,yF;;AAEA,2D;;AAEA,gE;AACA,4C;AACA,K;AACA,kE;AACA,+C;AACA,K;;AAEA,iG;;AAEA,mF;;AAEA,8H;AACA,2B;AACA,4B;AACA,K;AACA,uI;AACA,4B;AACA,K;AACA,8C;AACA,oC;AACA,4B;AACA,K;AACA,U;AACA,kL;AACA,K;;AAEA,kC;AACA,oE;AACA,+B;AACA,S;AACA,K;AACA,U;AACA,wE;AACA,mD;AACA,iF;AACA,S;;AAEA,sE;AACA,mD;AACA,gF;AACA,S;;AAEA,gE;AACA,2B;AACA,+E;AACA,S;AACA,c;AACA,iF;AACA,S;AACA,S;AACA,K;;AAEA,wF;AACA,mC;AACA,qC;AACA,Q;;AAEA,wD;;AAEA,2D;;AAEA,qH;;AAEA,6C;;AAEA,qD;AACA,oD;AACA,4D;;AAEA,qE;AACA,sE;AACA,gD;AACA,8D;;AAEA,uE;;AAEA,kE;;AAEA,2D;AACA,mD;AACA,yC;AACA,iB;;AAEA,oE;AACA,6D;AACA,gE;AACA,iB;;AAEA,e;;AAEA,a;AACA,W;AACA,S;AACA,S;AACA,K;;AAEA,I;;AAEA,mD;AACA,6D;AACA,wE;;AAEA,iB;;AAEA,G;AACA,wB;AACA,iD;AACA,iD;AACA,sB;AACA,sB;AACA,uD;AACA,yF;AACA,sF;AACA,G;AACA,0B;;AAEA,e;;AAEA,wF;AACA,+C;AACA,2D;AACA,iD;AACA,O;AACA,gG;AACA,iD;AACA,K;AACA,6F;AACA,I;;AAEA,8G;AACA,2D;AACA,sE;;AAEA,iB;AACA,wB;;AAEA,e;;AAEA,yF;AACA,+D;;AAEA,yB;;AAEA,a;AACA,+D;AACA,sD;;AAEA,wF;;AAEA,6C;;AAEA,I;;AAEA,mD;AACA,6D;AACA,wE;;AAEA,iB;AACA,0B;;AAEA,6E;;AAEA,gE;;AAEA,8C;AACA,G;;AAEA,gE;AACA,qD;;AAEA,iB;;AAEA,0B;AACA,e;;AAEA,8B;AACA,4C;AACA,6B;AACA,4D;AACA,8B;AACA,I;;AAEA,iC;AACA,6B;AACA,iD;;AAEA,yB;AACA,+B;;AAEA,gB;AACA,G;;AAEA,0D;AACA,4B;AACA,kC;AACA,iC;AACA,K;;AAEA,G;;AAEA,2C;;AAEA,6C;AACA,0D;AACA,I;;AAEA,qD;AACA,0D;AACA,I;;AAEA,yC;AACA,sD;AACA,I;;AAEA,0C;AACA,uD;AACA,I;;AAEA,6F;AACA,iB;AACA,mB;AACA,mB;AACA,qB;AACA,uC;AACA,yC;;AAEA,iD;AACA,I;;AAEA,2C;AACA,qC;AACA,sB;AACA,uC;AACA,K;;AAEA,oC;AACA,yB;AACA,O;;AAEA,0C;AACA,qC;AACA,0C;AACA,mB;AACA,K;;AAEA,sC;AACA,I;;AAEA,6D;AACA,0H;AACA,2C;AACA,c;;AAEA,2B;AACA,qB;AACA,wB;AACA,qB;AACA,O;AACA,2B;AACA,qB;AACA,wB;AACA,qB;AACA,O;;AAEA,mF;AACA,K;AACA,U;AACA,mF;AACA,K;AACA,I;;AAEA,6D;AACA,wD;AACA,a;AACA,K;;AAEA,qF;AACA,gC;;AAEA,kD;;AAEA,uF;;AAEA,+D;;AAEA,gB;AACA,wB;AACA,iB;;AAEA,4H;AACA,I;;AAEA,4F;;AAEA,mB;AACA,sD;AACA,+C;AACA,kC;AACA,wC;AACA,S;;AAEA,yB;AACA,Q;AACA,K;;AAEA,2B;AACA,a;AACA,K;;AAEA,wD;AACA,sB;AACA,6D;AACA,kC;AACA,a;AACA,a;AACA,K;;AAEA,yD;;AAEA,iC;;AAEA,6B;AACA,oC;AACA,e;;AAEA,O;;;AAGA,iB;AACA,mH;AACA,Q;;AAEA,oD;;AAEA,oC;;AAEA,8D;AACA,wB;AACA,sE;AACA,yD;AACA,qC;AACA,W;AACA,c;AACA,uD;AACA,iC;AACA,O;;AAEA,K;AACA,I;;AAEA,oD;AACA,mD;AACA,yB;AACA,I;;AAEA,0D;AACA,2D;AACA,a;AACA,K;;AAEA,2G;;AAEA,mD;AACA,mB;;AAEA,oD;;AAEA,iC;AACA,K;AACA,U;AACA,mB;AACA,2B;;AAEA,mD;;AAEA,gC;AACA,K;;AAEA,I;;AAEA,6C;AACA,wB;AACA,I;;AAEA,gD;AACA,2D;AACA,I;;AAEA,+C;;AAEA,iB;;AAEA,wB;AACA,sE;;AAEA,yC;AACA,oB;AACA,0B;AACA,4D;AACA,sB;AACA,mC;;AAEA,uD;AACA,qB;AACA,O;AACA,I;;AAEA,6C;AACA,8B;AACA,I;;AAEA,qD;AACA,mC;AACA,I;;AAEA,yD;;AAEA,wB;AACA,0C;;AAEA,+C;AACA,8I;;AAEA,uD;;AAEA,4D;AACA,iF;AACA,a;AACA,K;;AAEA,wG;AACA,4G;AACA,uC;AACA,a;AACA,K;;AAEA,4B;AACA,gC;AACA,8F;AACA,2C;AACA,S;AACA,c;;AAEA,gD;AACA,qE;AACA,2C;AACA,S;AACA,c;;AAEA,0B;AACA,mD;AACA,gG;AACA,4G;AACA,8B;AACA,kD;AACA,yB;AACA,kB;AACA,wD;AACA,W;AACA,2C;AACA,S;AACA,4D;AACA,c;;AAEA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,qB;AACA,gJ;AACA,S;AACA,c;;AAEA,8B;AACA,2B;AACA,yB;AACA,wB;AACA,4I;AACA,c;AACA,K;;AAEA,+D;AACA,I;;;;AAIA,yC;AACA,qH;;AAEA,4D;AACA,I;;AAEA,0C;AACA,8C;;AAEA,gC;;AAEA,mD;AACA,0G;AACA,K;;AAEA,+D;AACA,I;;AAEA,0C;AACA,0B;AACA,iF;AACA,I;;AAEA,qD;AACA,oC;;AAEA,uD;;AAEA,kE;;AAEA,6C;AACA,iC;AACA,kC;;AAEA,yD;AACA,+E;;AAEA,0D;AACA,qC;AACA,sC;AACA,8C;;AAEA,oD;;AAEA,gE;;AAEA,oB;AACA,2D;AACA,+B;AACA,W;AACA,I;;AAEA,yD;AACA,6D;AACA,mE;AACA,wB;AACA,c;AACA,qB;AACA,O;AACA,Y;AACA,mE;AACA,sB;AACA,O;AACA,K;AACA,I;;AAEA,oD;AACA,iD;AACA,mB;;AAEA,4B;AACA,iB;AACA,uH;AACA,8C;AACA,c;AACA,oB;AACA,qH;AACA,8C;AACA,c;AACA,kB;AACA,yH;AACA,8C;AACA,c;AACA,e;AACA,+D;AACA,6C;AACA,c;AACA,K;;AAEA,sE;AACA,I;;;AAGA,wD;AACA,0D;AACA,a;AACA,K;;AAEA,sC;AACA,0D;AACA,mC;;AAEA,mB;AACA,iH;AACA,a;AACA,K;AACA,2F;;AAEA,yD;AACA,6E;AACA,8D;AACA,iE;;AAEA,+C;AACA,gE;AACA,gE;AACA,kD;AACA,2B;;AAEA,sG;AACA,2B;AACA,iB;AACA,2I;AACA,c;AACA,kB;AACA,6I;AACA,c;AACA,oB;AACA,yI;AACA,c;AACA,K;;AAEA,sB;AACA,kB;AACA,K;AACA,uB;AACA,mB;AACA,K;AACA,gF;AACA,mB;AACA,K;AACA,iF;AACA,oB;AACA,K;;;AAGA,wD;AACA,8E;AACA,Y;AACA,mE;AACA,K;;AAEA,kD;AACA,oD;;AAEA,oC;;;AAGA,4G;AACA,gH;;AAEA,uE;AACA,0H;AACA,mF;AACA,2H;;AAEA,yD;AACA,kB;AACA,K;AACA,0D;AACA,gC;AACA,mB;AACA,O;AACA,K;;AAEA,uF;AACA,2F;;AAEA,yC;AACA,6C;AACA,+H;AACA,0C;AACA,4H;AACA,a;;AAEA,+C;AACA,I;;AAEA,iD;AACA,sB;;AAEA,6E;AACA,iD;AACA,gC;AACA,O;;AAEA,gF;AACA,iD;AACA,gC;AACA,O;;AAEA,gE;AACA,iC;AACA,O;;AAEA,uD;AACA,kC;AACA,O;AACA,I;;AAEA,8C;AACA,8B;AACA,I;;;AAGA,+C;AACA,+E;;AAEA,iB;;AAEA,0B;;AAEA,4E;;AAEA,8B;;AAEA,oC;AACA,uB;;AAEA,6D;AACA,sD;AACA,8D;AACA,wD;AACA,2D;AACA,kD;AACA,6D;AACA,sD;;AAEA,sC;AACA,+D;AACA,K;AACA,I;;AAEA,yD;AACA,6C;AACA,I;;AAEA,iD;AACA,oB;AACA,qE;;AAEA,0B;AACA,sB;;AAEA,uD;AACA,qB;AACA,O;;AAEA,I;;AAEA,qD;AACA,8B;AACA,I;;AAEA,6D;AACA,8B;;AAEA,mC;AACA,I;;AAEA,2D;AACA,yD;AACA,+D;;AAEA,qD;AACA,+C;;AAEA,oD;AACA,6C;;AAEA,mD;AACA,wC;;AAEA,0D;AACA,yD;;AAEA,uD;AACA,kE;;AAEA,8C;;AAEA,uD;AACA,sD;AACA,qD;AACA,4D;;AAEA,8B;;AAEA,oD;AACA,I;;AAEA,iE;AACA,wB;AACA,0C;;AAEA,uD;;AAEA,iF;AACA,a;AACA,K;;AAEA,+C;;AAEA,2B;AACA,0B;AACA,qB;AACA,4D;AACA,c;AACA,8B;AACA,4I;AACA,c;AACA,K;AACA,I;;AAEA,iD;AACA,iE;;AAEA,8D;AACA,oC;AACA,0B;AACA,6D;;AAEA,gC;AACA,I;;AAEA,gD;AACA,0B;AACA,iF;AACA,I;;AAEA,kD;AACA,yB;AACA,oE;;AAEA,iE;AACA,I;;AAEA,yD;AACA,4D;AACA,8C;AACA,I;;AAEA,4D;AACA,gE;AACA,4D;AACA,K;AACA,I;;AAEA,qE;AACA,gB;AACA,0B;AACA,0B;;AAEA,gD;AACA,iD;;AAEA,Y;AACA,iD;AACA,0E;;AAEA,mB;AACA,2C;AACA,0C;AACA,iE;AACA,8D;AACA,S;AACA,O;AACA,+C;AACA,8C;AACA,kE;AACA,S;AACA,O;;AAEA,qC;AACA,iM;AACA,2L;;AAEA,sE;AACA,yE;AACA,qC;AACA,0B;AACA,wB;AACA,Y;;AAEA,oM;AACA,wI;;AAEA,uJ;AACA,gH;AACA,wH;AACA,qD;AACA,S;;AAEA,yO;;AAEA,O;AACA,K;AACA,I;;;AAGA,4D;;AAEA,qE;AACA,sC;AACA,sD;AACA,sF;AACA,gF;AACA,I;AACA,4E;AACA,e;AACA,O;AACA,I;AACA,4E;AACA,oG;AACA,gD;AACA,yH;AACA,O;AACA,I;AACA,M;;AAEA,6D;AACA,8C;AACA,8E;;AAEA,2B;AACA,2B;AACA,iC;AACA,gC;AACA,I;;AAEA,2D;;AAEA,8B;AACA,kB;AACA,K;;AAEA,e;AACA,mD;AACA,M;;AAEA,wB;AACA,I;;AAEA,uD;AACA,oB;;AAEA,+F;AACA,4B;AACA,gE;AACA,8B;AACA,6B;AACA,O;AACA,gG;AACA,4B;AACA,+D;AACA,8B;AACA,6B;AACA,O;AACA,6F;AACA,4B;AACA,gE;AACA,8B;AACA,6B;AACA,O;AACA,+F;AACA,4B;AACA,+D;AACA,8B;AACA,6B;AACA,O;;AAEA,wF;AACA,sC;AACA,oC;AACA,+B;AACA,6C;AACA,2C;AACA,S;AACA,6B;AACA,6C;AACA,4C;AACA,U;;AAEA,gF;AACA,uC;AACA,kG;AACA,iC;AACA,iC;AACA,W;;AAEA,O;AACA,O;;AAEA,oF;AACA,mJ;AACA,qB;AACA,O;AACA,O;;AAEA,gI;AACA,iF;AACA,+B;AACA,O;AACA,O;;AAEA,8H;AACA,+E;AACA,+B;AACA,O;AACA,O;;AAEA,I;;AAEA,oD;AACA,8B;;AAEA,sE;AACA,I;;AAEA,2D;AACA,uF;;;;AAIA,iB;;AAEA,wB;;AAEA,0D;AACA,0E;;AAEA,uD;AACA,mE;;AAEA,mB;AACA,uB;AACA,K;;AAEA,I;;AAEA,0D;;AAEA,iD;AACA,iD;AACA,kD;AACA,qD;AACA,qD;AACA,kD;;AAEA,uD;AACA,kE;;AAEA,iB;;;AAGA,0B;AACA,sE;;AAEA,Q;;AAEA,2C;AACA,uC;AACA,iB;AACA,Y;AACA,8G;AACA,K;;AAEA,wB;AACA,qI;AACA,K;;AAEA,0E;;AAEA,8B;AACA,oB;;AAEA,uD;AACA,6B;AACA,M;;AAEA,I;;AAEA,qD;AACA,oF;;AAEA,oD;AACA,qE;AACA,iD;AACA,+C;AACA,iC;AACA,kC;AACA,qC;AACA,+C;AACA,0C;;AAEA,oB;AACA,0B;AACA,6B;AACA,4B;AACA,wB;AACA,uB;AACA,oC;AACA,+B;AACA,kC;AACA,O;AACA,M;AACA,gD;;AAEA,uD;;AAEA,O;AACA,qF;AACA,O;AACA,kF;AACA,iD;AACA,gC;AACA,O;;AAEA,0B;AACA,I;;AAEA,sD;AACA,2C;AACA,8B;AACA,yD;AACA,qE;AACA,I;;AAEA,2C;AACA,8D;AACA,0B;AACA,I;;AAEA,yE;AACA,0B;AACA,mF;AACA,I;;AAEA,qD;AACA,iD;AACA,yB;AACA,yB;;AAEA,gH;AACA,0E;;AAEA,wC;AACA,uD;AACA,kD;AACA,kE;AACA,8D;;AAEA,6B;AACA,iE;AACA,K;AACA,2C;AACA,I;;AAEA,qD;AACA,0C;AACA,I;;;AAGA,+C;AACA,0D;AACA,iB;;AAEA,G;AACA,+D;AACA,G;AACA,0B;AACA,e;;AAEA,8E;;AAEA,6D;AACA,oF;;AAEA,4C;AACA,yC;AACA,0C;;AAEA,2B;AACA,0C;;AAEA,uB;AACA,I;;AAEA,+F;;AAEA,6E;;AAEA,sB;;AAEA,mB;AACA,mB;AACA,mB;AACA,iB;AACA,iB;AACA,2B;AACA,uB;AACA,0B;AACA,gB;AACA,wB;AACA,S;AACA,Q;AACA,wB;AACA,yC;AACA,oC;AACA,wG;AACA,iC;AACA,S;AACA,wC;AACA,O;AACA,M;;AAEA,2C;AACA,uE;AACA,K;AACA,wB;AACA,8B;AACA,K;;AAEA,gE;;AAEA,gD;AACA,8C;AACA,I;;AAEA,0C;;AAEA,uE;AACA,oD;AACA,mD;AACA,iC;AACA,Q;AACA,iD;AACA,yD;AACA,mD;AACA,Q;AACA,K;;AAEA,gD;AACA,a;AACA,K;;AAEA,wC;;AAEA,oH;;AAEA,oB;;AAEA,kE;AACA,oC;AACA,wB;AACA,O;AACA,Y;AACA,oD;AACA,+C;AACA,yD;AACA,O;AACA,K;AACA,qE;AACA,mC;AACA,oD;AACA,sC;AACA,O;AACA,K;;AAEA,iC;AACA,4B;AACA,gC;AACA,O;AACA,Y;AACA,4C;AACA,O;;AAEA,6B;AACA,uC;;AAEA,+B;AACA,8B;AACA,K;AACA,I;;AAEA,mD;;AAEA,4D;;AAEA,0E;;AAEA,+C;;AAEA,+D;AACA,2B;;AAEA,qC;AACA,oC;AACA,gD;AACA,Y;AACA,mC;AACA,iD;AACA,K;;AAEA,oF;;AAEA,I;;AAEA,oD;;AAEA,+D;AACA,2B;;AAEA,2E;AACA,I;;AAEA,oD;;AAEA,2B;;AAEA,2E;AACA,I;;AAEA,uE;AACA,oE;AACA,uD;AACA,a;AACA,K;;AAEA,kF;;AAEA,I;;AAEA,iF;AACA,4E;;AAEA,iH;AACA,gG;AACA,2E;AACA,K;;AAEA,oC;AACA,yE;AACA,0D;AACA,6E;AACA,yD;AACA,4F;AACA,sG;AACA,6B;AACA,O;AACA,K;;AAEA,0F;AACA,I;;AAEA,0D;AACA,kB;AACA,uD;AACA,0B;AACA,gC;AACA,O;AACA,O;;AAEA,I;;AAEA,+D;AACA,0E;;;;AAIA,iB;;;;;;;AAOA,0B;AACA,sF;;AAEA,mD;AACA,kF;;AAEA,qF;AACA,qD;AACA,mC;AACA,e;AACA,O;;AAEA,sB;AACA,sB;AACA,I;;AAEA,2D;AACA,4F;;AAEA,qD;AACA,0D;AACA,6B;AACA,c;AACA,kB;AACA,O;AACA,M;;AAEA,sE;AACA,iF;AACA,uD;AACA,kE;;AAEA,I;;AAEA,sB;AACA,0C;AACA,oB;AACA,wC;AACA,+C;;AAEA,gL;AACA,yB;;AAEA,sD;AACA,4E;AACA,e;AACA,O;;AAEA,8B;AACA,yB;AACA,O;;AAEA,+D;AACA,mD;AACA,uB;AACA,sB;AACA,K;AACA,I;;AAEA,sD;AACA,4D;AACA,qF;AACA,I;;AAEA,mD;AACA,kF;;AAEA,+C;AACA,iB;;;AAGA,qD;AACA,oB;;AAEA,mC;AACA,oE;AACA,2D;AACA,uF;;AAEA,kB;AACA,gI;;AAEA,iC;AACA,sE;AACA,kF;AACA,W;AACA,S;AACA,O;AACA,O;;AAEA,iB;AACA,sB;AACA,K;AACA,2D;AACA,6C;AACA,W;;AAEA,I;;AAEA,oD;AACA,mF;AACA,I;;AAEA,8D;AACA,uB;;AAEA,yD;AACA,sB;;AAEA,0D;AACA,wC;AACA,S;;AAEA,2D;;AAEA,kB;;AAEA,yD;AACA,6C;AACA,c;;AAEA,yF;AACA,iD;;AAEA,qE;;AAEA,uC;AACA,+C;AACA,kB;AACA,sE;AACA,W;;AAEA,W;AACA,O;;AAEA,sC;;AAEA,Y;AACA,iC;AACA,K;;AAEA,I;;AAEA,uE;AACA,+D;AACA,yE;;AAEA,oI;AACA,uB;;AAEA,8C;AACA,sB;AACA,qF;AACA,kD;AACA,O;AACA,yB;AACA,uB;AACA,K;AACA,U;AACA,2C;AACA,K;;AAEA,2B;;AAEA,iE;AACA,qE;AACA,sG;AACA,0G;;AAEA,8C;AACA,uD;AACA,K;;AAEA,2B;AACA,0B;AACA,6F;AACA,I;;AAEA,gF;AACA,gC;AACA,iE;AACA,K;AACA,2F;AACA,I;;AAEA,+E;AACA,oC;AACA,0C;AACA,Y;AACA,mC;AACA,K;AACA,I;;AAEA,K;AACA,mC;AACA,iB;AACA,mB;AACA,yB;AACA,gE;AACA,K;AACA,gF;;AAEA,6B;AACA,mB;AACA,kC;AACA,kB;AACA,iB;AACA,mB;AACA,S;AACA,qB;;AAEA,2B;AACA,wE;AACA,uB;AACA,O;AACA,oB;AACA,K;;AAEA,sE;AACA,+B;;AAEA,yB;AACA,gD;AACA,c;AACA,4E;AACA,O;;;AAGA,wC;AACA,iE;;AAEA,6B;AACA,qB;AACA,0B;AACA,6B;AACA,0B;AACA,S;AACA,K;;AAEA,0C;;AAEA,mC;AACA,kC;;AAEA,6B;AACA,kB;AACA,oC;AACA,iB;AACA,sC;AACA,uC;AACA,oB;AACA,8C;AACA,mB;AACA,gB;AACA,mB;AACA,S;AACA,O;AACA,O;;AAEA,+E;AACA,iD;AACA,K;;AAEA,kB;AACA,I;;AAEA,8D;AACA,+F;AACA,2E;AACA,8G;AACA,sG;AACA,gF;AACA,+F;AACA,e;AACA,I;;;AAGA,+D;AACA,0E;;AAEA,iB;;AAEA,wB;;AAEA,0E;;AAEA,yD;AACA,oF;;AAEA,oD;AACA,mD;AACA,kD;AACA,6C;AACA,iC;AACA,kC;;AAEA,iD;AACA,oD;;AAEA,I;;AAEA,uD;AACA,kE;;AAEA,iB;;AAEA,0B;;AAEA,wE;;AAEA,2C;AACA,mD;AACA,6D;AACA,uC;AACA,uD;AACA,I;;AAEA,8C;AACA,6E;;;AAGA,0D;AACA,gB;;AAEA,4C;AACA,kF;AACA,Y;AACA,oD;AACA,K;;AAEA,wC;;AAEA,gC;AACA,0C;AACA,6D;AACA,qC;AACA,uE;AACA,+C;AACA,O;AACA,K;AACA,I;;AAEA,qE;;AAEA,6B;;AAEA,yC;AACA,kE;AACA,mE;AACA,O;AACA,K;AACA,mD;AACA,yC;AACA,K;;AAEA,2B;;AAEA,I;;AAEA,iD;AACA,6B;AACA,I;;AAEA,sD;AACA,8B;AACA,I;;AAEA,0C;AACA,wB;AACA,4C;;AAEA,2B;AACA,gD;;AAEA,0E;;AAEA,wC;AACA,gD;AACA,S;;AAEA,yC;AACA,+B;AACA,c;;AAEA,kD;;AAEA,sE;;AAEA,oC;AACA,4C;AACA,S;;AAEA,yC;AACA,+B;AACA,c;AACA,K;AACA,I;;AAEA,mE;AACA,2D;AACA,6D;AACA,mE;AACA,wB;AACA,c;AACA,qB;AACA,O;AACA,Y;AACA,mE;AACA,sB;AACA,O;AACA,K;AACA,I;;AAEA,6C;AACA,sH;AACA,uD;AACA,wE;AACA,oD;AACA,kD;AACA,2B;;AAEA,2B;AACA,iB;AACA,2I;AACA,c;AACA,kB;AACA,6I;AACA,c;AACA,oB;AACA,yI;AACA,c;AACA,K;;AAEA,wC;;AAEA,wD;AACA,iE;AACA,Y;AACA,sD;AACA,K;;AAEA,uC;AACA,wC;AACA,2D;AACA,8D;AACA,+B;AACA,6B;;AAEA,4D;AACA,I;;AAEA,8C;AACA,uC;AACA,+D;AACA,I;;AAEA,8C;AACA,wB;AACA,I;;AAEA,mD;AACA,8D;;AAEA,iB;;AAEA,0B;;AAEA,kF;;AAEA,kD;AACA,qF;;AAEA,uC;AACA,sC;;AAEA,I;;;AAGA,uD;AACA,kE;;;AAGA,iB;AACA,0B;;AAEA,e;;AAEA,yE;;AAEA,kE;;AAEA,+D;;AAEA,sE;;AAEA,0C;;AAEA,gE;AACA,sD;AACA,O;;AAEA,uE;AACA,mD;;AAEA,mD;AACA,Y;AACA,qD;AACA,K;;AAEA,I;;AAEA,qD;AACA,gE;;AAEA,iB;;AAEA,G;AACA,yB;AACA,0C;AACA,+D;AACA,G;AACA,4D;AACA,uB;AACA,e;AACA,G;AACA,6C;AACA,E;AACA,G;AACA,4D;AACA,0C;AACA,8D;AACA,G;AACA,0C;;AAEA,2B;AACA,wF;;AAEA,4B;AACA,sB;AACA,0D;AACA,sC;AACA,qC;AACA,c;AACA,O;AACA,0D;AACA,yE;AACA,qB;AACA,c;AACA,O;AACA,K;;AAEA,oB;AACA,G;AACA,E;;AAEA,G;AACA,8B;AACA,0C;AACA,8D;AACA,G;AACA,iE;AACA,mC;AACA,6H;AACA,U;AACA,mB;AACA,G;AACA,E;;AAEA,G;AACA,yF;AACA,G;;AAEA,0G;;AAEA,iC;AACA,kD;AACA,wD;AACA,+C;AACA,E;;AAEA,6B;AACA,8C;AACA,mD;AACA,E;;AAEA,yB;AACA,+G;AACA,+C;AACA,E;;AAEA,4B;AACA,6C;AACA,mD;AACA,2C;AACA,oB;AACA,E;;AAEA,yB;AACA,0C;AACA,6G;AACA,E;;AAEA,iC;AACA,kD;AACA,6G;AACA,E;;AAEA,6B;AACA,8C;AACA,oD;AACA,iB;AACA,E;;AAEA,6B;AACA,8C;AACA,8G;AACA,+C;AACA,E;;AAEA,sE;AACA,0B;AACA,8B;AACA,8B;AACA,oC;AACA,sC;AACA,8C;AACA,8C;AACA,sC;AACA,qC;AACA,E;;AAEA,oG;AACA,2B;AACA,c;AACA,2C;AACA,oD;AACA,G;AACA,E;;AAEA,G;AACA,oF;AACA,E;AACA,sC;AACA,iC;AACA,G;AACA,8B;AACA,kB;AACA,qB;AACA,qB;AACA,oB;AACA,mB;AACA,M;AACA,O;AACA,yB;AACA,uC;AACA,0C;AACA,kD;AACA,+B;AACA,mD;AACA,c;AACA,wD;AACA,O;AACA,M;AACA,oD;AACA,uC;AACA,2D;AACA,c;AACA,mD;AACA,O;AACA,M;AACA,iC;AACA,oB;AACA,qB;AACA,4D;AACA,sB;AACA,O;;AAEA,wC;AACA,8C;AACA,O;AACA,Y;AACA,6C;AACA,O;AACA,2E;AACA,+E;AACA,wC;;AAEA,6B;AACA,uC;AACA,6B;;AAEA,kD;;AAEA,sC;AACA,kD;AACA,6C;AACA,kD;AACA,c;AACA,sC;AACA,O;;AAEA,yC;AACA,8C;AACA,oD;AACA,qD;AACA,oD;AACA,uC;AACA,c;AACA,8C;AACA,O;;AAEA,M;AACA,iC;AACA,mC;AACA,M;AACA,wC;;AAEA,uC;AACA,4C;AACA,+C;AACA,gB;AACA,qD;AACA,kC;AACA,0C;AACA,W;AACA,S;AACA,O;;AAEA,uC;AACA,4C;AACA,+C;AACA,gB;AACA,qD;AACA,kC;AACA,0C;AACA,W;AACA,S;AACA,O;;AAEA,sC;AACA,2C;AACA,6C;AACA,gB;AACA,mD;AACA,iC;AACA,wC;AACA,W;AACA,S;AACA,O;;AAEA,sC;AACA,2C;AACA,6C;AACA,gB;AACA,mD;AACA,iC;AACA,wC;AACA,W;AACA,S;AACA,O;;AAEA,4B;AACA,sC;AACA,4C;AACA,+B;AACA,O;AACA,M;AACA,8C;AACA,e;AACA,6B;;AAEA,sC;;AAEA,iC;AACA,gC;AACA,oD;AACA,qD;AACA,qD;AACA,sC;AACA,O;;AAEA,qB;AACA,sC;AACA,0C;AACA,4C;AACA,2C;AACA,8C;AACA,O;;AAEA,e;AACA,M;;AAEA,U;AACA,6C;AACA,mC;AACA,M;AACA,4B;AACA,sC;AACA,0C;AACA,4C;AACA,2C;AACA,8C;AACA,M;AACA,kB;AACA,G;;AAEA,E;;AAEA,G;AACA,2C;AACA,c;AACA,E;AACA,2G;AACA,mC;AACA,E;AACA,sC;AACA,kC;AACA,uC;AACA,G;AACA,sB;AACA,oB;AACA,e;;AAEA,6B;AACA,qC;AACA,G;;AAEA,sB;AACA,2B;AACA,mE;AACA,6B;AACA,4D;AACA,mB;AACA,O;AACA,yD;AACA,sC;AACA,8D;AACA,wB;AACA,wB;AACA,W;AACA,qC;AACA,qC;AACA,4D;AACA,wG;AACA,gC;AACA,oG;AACA,a;AACA,W;AACA,gB;AACA,kE;AACA,uE;AACA,+B;AACA,a;AACA,kB;AACA,0D;AACA,gC;AACA,a;AACA,W;AACA,S;AACA,yB;AACA,iB;AACA,S;AACA,O;AACA,iB;AACA,M;;AAEA,+B;AACA,0C;AACA,wD;AACA,6D;AACA,sB;AACA,wB;AACA,W;AACA,0B;AACA,wC;AACA,yC;AACA,yD;AACA,a;AACA,kB;AACA,yB;AACA,a;AACA,W;AACA,mF;AACA,sB;AACA,W;AACA,gB;AACA,uB;AACA,W;AACA,S;AACA,2B;AACA,sB;AACA,S;AACA,O;AACA,iB;AACA,K;AACA,I;AACA,W;AACA,G;AACA,e;AACA,iI;AACA,4E;AACA,e;AACA,G;AACA,8B;AACA,e;AACA,U;AACA,8B;AACA,sB;AACA,wC;AACA,8C;AACA,wB;AACA,O;;AAEA,4B;;AAEA,sB;AACA,K;AACA,I;AACA,K;;AAEA,2B;AACA,sB;AACA,c;AACA,C;;AAEA,6C;AACA,iB;AACA,W;AACA,a;;AAEA,0B;AACA,yB;AACA,2B;AACA,uD;;AAEA,oD;AACA,yB;;AAEA,gD;AACA,yD;AACA,4C;AACA,G;AACA,Q;AACA,+C;AACA,mC;AACA,6B;AACA,6B;AACA,2B;AACA,4B;AACA,mC;;AAEA,yD;AACA,4C;AACA,gD;AACA,qF;AACA,yD;AACA,qB;AACA,O;AACA,M;AACA,kC;AACA,4B;AACA,6B;AACA,8B;AACA,4C;;AAEA,+C;AACA,wB;AACA,K;AACA,U;AACA,8B;AACA,6C;AACA,yC;AACA,Q;AACA,e;AACA,K;AACA,G;;AAEA,2C;AACA,2B;AACA,8B;AACA,wB;AACA,K;AACA,+E;AACA,wB;AACA,K;;AAEA,qB;AACA,4K;AACA,wI;AACA,O;;AAEA,2C;AACA,8B;AACA,6C;AACA,Y;AACA,K;;AAEA,a;AACA,a;AACA,a;AACA,O;AACA,+F;AACA,8C;;AAEA,8E;AACA,gC;AACA,iC;AACA,c;AACA,O;AACA,sC;AACA,gC;AACA,mC;AACA,c;AACA,O;AACA,K;AACA,I;;AAEA,sG;;AAEA,2E;AACA,E;;AAEA,qC;AACA,gF;AACA,yD;AACA,W;AACA,gB;AACA,G;AACA,E;;AAEA,8E;AACA,yD;AACA,gB;AACA,4B;AACA,4C;AACA,0E;AACA,iD;AACA,G;AACA,c;AACA,E;;AAEA,oD;AACA,2D;AACA,0D;AACA,G;AACA,8B;AACA,E;;AAEA,mD;AACA,8B;AACA,I;;AAEA,gD;AACA,6B;AACA,E;;AAEA,kD;AACA,+B;AACA,E;;AAEA,yD;AACA,c;AACA,gE;AACA,uC;AACA,sC;AACA,kB;AACA,K;AACA,G;AACA,+D;AACA,sC;AACA,qC;AACA,kB;AACA,K;AACA,G;AACA,iE;AACA,wC;AACA,uC;AACA,kB;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,wD;AACA,kB;AACA,0B;AACA,4B;AACA,uE;AACA,oC;AACA,O;AACA,W;AACA,G;AACA,E;;AAEA,+D;AACA,kB;AACA,4B;AACA,4B;AACA,4F;AACA,yE;AACA,2C;AACA,O;AACA,W;AACA,G;AACA,E;;AAEA,gD;;AAEA,yD;AACA,8C;AACA,oD;AACA,wB;AACA,6B;AACA,K;;AAEA,6G;AACA,+E;;AAEA,G;;AAEA,E;;AAEA,yD;AACA,0B;AACA,E;;;;AAIA,6B;AACA,0B;AACA,c;AACA,c;AACA,uB;AACA,kB;AACA,kC;AACA,kC;AACA,wB;AACA,U;AACA,qC;AACA,4B;AACA,wB;AACA,U;AACA,sC;AACA,kC;AACA,wB;AACA,U;AACA,yC;AACA,uD;AACA,gC;AACA,yB;AACA,iD;AACA,e;AACA,yB;AACA,iE;AACA,e;AACA,wB;AACA,U;AACA,yC;AACA,uD;AACA,gC;AACA,yB;AACA,iE;AACA,e;AACA,wB;AACA,U;AACA,mC;AACA,6E;AACA,U;AACA,mC;AACA,kC;AACA,S;AACA,M;;AAEA,kB;AACA,gC;AACA,yC;AACA,wB;AACA,U;AACA,mC;AACA,6B;AACA,wB;AACA,U;AACA,oC;AACA,gC;AACA,wB;AACA,U;AACA,0B;AACA,0B;AACA,0B;AACA,yB;AACA,M;;AAEA,sB;AACA,uC;AACA,yB;AACA,0B;AACA,4D;AACA,6C;AACA,c;AACA,gC;AACA,U;AACA,4C;AACA,yB;AACA,6B;AACA,2D;AACA,c;AACA,gC;AACA,U;AACA,0C;AACA,yB;AACA,8B;AACA,4D;AACA,6C;AACA,c;AACA,gC;AACA,S;AACA,M;;AAEA,uC;AACA,+D;AACA,uB;AACA,4D;AACA,K;;AAEA,2C;AACA,kB;AACA,+B;AACA,2C;AACA,wC;AACA,0D;AACA,2D;AACA,8D;AACA,sC;AACA,sE;AACA,qB;AACA,iB;AACA,a;AACA,S;AACA,kB;AACA,K;;AAEA,iC;AACA,2B;AACA,uB;AACA,S;AACA,gD;AACA,0B;AACA,wD;AACA,S;AACA,0B;AACA,K;;AAEA,wB;;AAEA,wB;;AAEA,+B;AACA,8B;AACA,gC;AACA,2B;AACA,S;AACA,sB;AACA,S;;AAEA,qC;AACA,mD;AACA,qC;AACA,qC;AACA,S;AACA,4B;AACA,S;;AAEA,6B;AACA,kE;AACA,4C;AACA,qC;AACA,a;AACA,S;AACA,K;;AAEA,sD;AACA,wE;AACA,4D;AACA,oD;AACA,a;AACA,S;AACA,K;;AAEA,yD;AACA,wE;AACA,4D;AACA,8C;AACA,uB;AACA,a;AACA,S;AACA,K;;AAEA,wC;AACA,2B;AACA,6B;AACA,uC;AACA,gB;AACA,wC;AACA,S;;AAEA,qC;AACA,mD;AACA,K;AACA,oC;;AAEA,qC;AACA,yB;AACA,uB;AACA,qB;AACA,oC;;AAEA,sB;AACA,qC;AACA,oC;AACA,gB;AACA,+D;AACA,S;;AAEA,uB;AACA,4B;AACA,S;;AAEA,6B;AACA,uC;AACA,mF;AACA,0C;AACA,wC;;AAEA,6C;AACA,kC;AACA,sI;AACA,+C;;AAEA,uC;AACA,uC;AACA,6C;AACA,sC;;AAEA,2C;AACA,gD;AACA,sC;;AAEA,2C;AACA,gD;AACA,sC;AACA,yB;;AAEA,6F;AACA,qB;AACA,wB;AACA,iB;;AAEA,8B;AACA,mC;AACA,0C;AACA,qB;AACA,iB;AACA,2C;AACA,6B;AACA,c;AACA,gB;AACA,0B;;AAEA,2D;;AAEA,2B;AACA,+D;AACA,6C;AACA,qC;AACA,4E;AACA,wC;;AAEA,8C;AACA,uC;AACA,kB;AACA,6C;AACA,gD;AACA,4D;AACA,qC;AACA,4C;AACA,4F;AACA,0B;AACA,kB;AACA,6C;AACA,iC;AACA,4D;AACA,+D;AACA,wF;AACA,kB;AACA,oD;AACA,kD;AACA,wE;AACA,sE;AACA,sE;AACA,4B;AACA,qE;AACA,mE;AACA,mE;AACA,qB;AACA,iB;AACA,oF;AACA,a;AACA,S;AACA,mC;AACA,8B;;AAEA,oE;;AAEA,uC;AACA,K;AACA,gC;;AAEA,+D;AACA,sC;AACA,6B;AACA,0C;AACA,kC;AACA,8C;AACA,qC;AACA,uD;AACA,8C;AACA,qB;AACA,iB;AACA,a;AACA,S;AACA,wB;AACA,K;;AAEA,wC;AACA,6B;AACA,4C;AACA,kC;AACA,8C;AACA,qC;AACA,uD;AACA,gD;AACA,qB;AACA,iB;AACA,a;AACA,S;AACA,wB;AACA,K;;AAEA,iC;AACA,6B;AACA,kD;AACA,gB;AACA,uB;AACA,sE;AACA,4D;AACA,2C;AACA,0B;AACA,iB;AACA,a;AACA,2E;AACA,S;AACA,oC;AACA,8B;AACA,kC;AACA,oC;AACA,wC;AACA,a;AACA,S;AACA,oB;AACA,K;AACA,kC;;AAEA,oB;AACA,sB;AACA,kC;AACA,Y;AACA,sC;AACA,0B;AACA,gC;AACA,4C;AACA,iC;AACA,iB;AACA,a;AACA,wB;AACA,U;AACA,K;;AAEA,sF;AACA,oD;AACA,uC;AACA,0C;AACA,4B;AACA,4B;;AAEA,uD;AACA,iC;AACA,qC;AACA,0C;AACA,sC;AACA,+C;AACA,8F;AACA,wB;AACA,2C;AACA,uC;AACA,oH;AACA,6C;AACA,qB;AACA,iB;AACA,oB;AACA,4F;AACA,mC;AACA,+B;AACA,a;AACA,S;;AAEA,2D;AACA,mB;AACA,S;;AAEA,kD;AACA,iC;AACA,8C;AACA,0G;AACA,mE;AACA,a;AACA,S;AACA,K;;AAEA,iB;AACA,wB;AACA,iC;AACA,Y;AACA,mC;AACA,8D;AACA,U;AACA,K;;AAEA,sD;AACA,mC;AACA,gE;AACA,0B;AACA,+B;;AAEA,8B;AACA,6C;AACA,2B;AACA,sB;AACA,kC;AACA,0B;AACA,oC;AACA,sD;AACA,wB;AACA,mC;AACA,gF;AACA,8B;AACA,qB;AACA,qC;AACA,wB;AACA,sC;AACA,+C;AACA,0E;AACA,wB;AACA,mC;AACA,8E;AACA,8B;AACA,qB;AACA,mC;AACA,iB;AACA,a;AACA,gB;AACA,S;AACA,sB;AACA,K;AACA,4B;AACA,kC;;AAEA,qC;AACA,oC;AACA,wC;AACA,4C;AACA,0C;AACA,C;;AAEA,6C;;AAEA,2B;AACA,Y;AACA,c;AACA,gC;AACA,qB;AACA,uB;AACA,4B;AACA,4B;AACA,uB;AACA,6B;AACA,0B;AACA,0B;AACA,yB;AACA,4B;AACA,yB;AACA,wB;AACA,gC;AACA,4B;AACA,qB;AACA,yB;AACA,8B;AACA,uB;AACA,yB;AACA,uB;AACA,wB;AACA,2B;AACA,2B;AACA,4B;AACA,4B;AACA,uB;AACA,yB;AACA,yB;AACA,yB;AACA,yB;AACA,wB;AACA,yB;AACA,+B;AACA,4B;AACA,kC;AACA,+B;AACA,+B;AACA,qC;AACA,gC;AACA,kC;AACA,6B;AACA,wC;AACA,+B;AACA,8B;;AAEA,kB;AACA,yB;AACA,0B;AACA,oB;AACA,mB;AACA,K;AACA,I;;AAEA,gB;AACA,mC;AACA,4B;AACA,kC;AACA,kC;AACA,kC;AACA,kC;AACA,wC;AACA,8C;AACA,mD;AACA,I;;AAEA,8B;;AAEA,yB;AACA,2B;AACA,yB;;AAEA,G;;AAEA,6D;AACA,kB;AACA,sC;AACA,uC;AACA,O;AACA,uC;AACA,K;AACA,6B;AACA,I;;AAEA,gE;AACA,sD;AACA,4B;AACA,sD;AACA,6B;AACA,O;AACA,K;AACA,U;AACA,gD;AACA,0B;AACA,0B;AACA,O;;AAEA,4C;;AAEA,+C;AACA,yB;AACA,O;;AAEA,sB;;AAEA,0C;AACA,qI;AACA,O;AACA,K;AACA,gB;AACA,I;;AAEA,+D;;AAEA,0B;;AAEA,oD;AACA,6B;AACA,uC;AACA,O;;AAEA,Y;AACA,wB;AACA,kC;;AAEA,K;;AAEA,I;;AAEA,mE;AACA,uB;;AAEA,8C;AACA,wB;AACA,wB;AACA,K;;AAEA,0C;;AAEA,6C;;AAEA,iE;;AAEA,mC;AACA,qC;AACA,wB;AACA,gB;AACA,S;;AAEA,O;;AAEA,K;;AAEA,kB;AACA,I;;AAEA,oF;AACA,8C;AACA,wB;AACA,wB;AACA,K;;AAEA,8E;AACA,qF;AACA,I;;AAEA,mG;AACA,+B;AACA,mB;AACA,8D;AACA,gC;AACA,6D;;AAEA,oC;AACA,0F;AACA,W;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,2D;AACA,0C;AACA,6B;AACA,uC;AACA,mE;AACA,kD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,wF;AACA,8C;AACA,wB;AACA,wB;AACA,K;;AAEA,uF;AACA,8F;AACA,c;AACA,I;;AAEA,uG;AACA,Y;AACA,6B;;AAEA,4F;AACA,mB;AACA,8D;AACA,gC;AACA,mE;AACA,+B;AACA,qB;AACA,W;;AAEA,oC;AACA,0F;AACA,W;;AAEA,8D;AACA,4G;AACA,W;AACA,S;AACA,O;AACA,K;;AAEA,c;AACA,I;;AAEA,K;AACA,wH;AACA,yF;AACA,mF;AACA,wB;AACA,K;AACA,uD;AACA,kC;AACA,2B;AACA,K;AACA,I;;AAEA,K;AACA,2E;AACA,wB;AACA,K;AACA,yD;AACA,2B;AACA,I;;AAEA,K;AACA,2E;AACA,wB;AACA,K;AACA,2D;AACA,oD;AACA,I;;AAEA,K;AACA,yC;AACA,qB;AACA,K;AACA,yD;AACA,mC;AACA,I;;AAEA,yB;;AAEA,K;;AAEA,wD;AACA,sF;;AAEA,0B;;AAEA,yC;AACA,qB;AACA,yE;;AAEA,mC;AACA,0B;AACA,qC;;AAEA,4D;AACA,0C;AACA,wC;AACA,wB;AACA,6B;AACA,0B;AACA,wB;AACA,4B;AACA,iC;AACA,2C;AACA,Y;;AAEA,gF;AACA,8E;AACA,0E;;AAEA,sE;AACA,S;AACA,c;AACA,yC;AACA,mF;AACA,iF;AACA,6E;;AAEA,+C;;AAEA,6C;AACA,S;AACA,O;AACA,M;;AAEA,gD;AACA,kB;AACA,sE;AACA,O;AACA,M;;AAEA,gD;AACA,yB;AACA,2C;;AAEA,2B;AACA,+C;AACA,O;;AAEA,qF;AACA,qD;;AAEA,sC;AACA,uB;AACA,qB;AACA,sC;AACA,kF;AACA,+B;AACA,2B;AACA,uB;AACA,S;AACA,4B;AACA,0B;AACA,gC;AACA,uB;AACA,Y;AACA,S;AACA,kC;AACA,4D;AACA,gC;AACA,S;AACA,O;;AAEA,4C;AACA,gC;AACA,uE;AACA,O;;AAEA,wC;;AAEA,8B;AACA,wC;AACA,4E;AACA,gD;;AAEA,gE;AACA,qC;AACA,qC;;AAEA,oE;;AAEA,kD;AACA,kD;;AAEA,mH;AACA,gB;AACA,+B;AACA,sC;AACA,W;AACA,S;AACA,O;;AAEA,mD;AACA,wC;AACA,yD;AACA,wC;;AAEA,mB;AACA,M;;AAEA,8C;AACA,0B;AACA,wC;AACA,2D;AACA,oC;AACA,wC;AACA,sD;AACA,qF;AACA,W;AACA,S;AACA,O;AACA,M;;AAEA,iD;AACA,6E;AACA,0C;AACA,O;AACA,mB;AACA,M;;AAEA,qC;AACA,0B;AACA,kI;AACA,0G;AACA,O;AACA,wC;AACA,M;;AAEA,2C;AACA,sB;AACA,qB;;AAEA,2C;AACA,0C;AACA,kH;;AAEA,uC;AACA,0C;AACA,oC;;AAEA,2C;AACA,uC;;AAEA,6C;AACA,2E;AACA,gF;AACA,+C;;AAEA,2C;AACA,K;AACA,G;;AAEA,0D;;AAEA,oE;AACA,6E;;AAEA,iB;;AAEA,G;AACA,8E;AACA,e;AACA,G;AACA,sC;AACA,oB;;AAEA,iC;AACA,wB;AACA,+D;AACA,oC;;AAEA,kD;;AAEA,kC;AACA,8B;;AAEA,+D;;AAEA,qD;AACA,sD;AACA,oD;AACA,c;AACA,+C;AACA,iD;AACA,O;AACA,sE;;AAEA,iC;AACA,yD;;AAEA,wD;AACA,Q;;AAEA,uE;AACA,kD;AACA,O;;AAEA,kC;AACA,mD;;AAEA,kE;AACA,kE;AACA,uD;AACA,O;AACA,Y;AACA,2B;;AAEA,mE;AACA,mE;AACA,wD;AACA,K;AACA,I;;AAEA,iD;AACA,wB;;AAEA,oC;AACA,iC;AACA,gC;;AAEA,a;AACA,4E;AACA,+C;AACA,Y;AACA,sE;AACA,K;;AAEA,8B;;AAEA,I;;AAEA,6C;AACA,wB;;AAEA,uD;;AAEA,kD;AACA,a;AACA,K;;AAEA,kG;;AAEA,+B;AACA,sB;;AAEA,oC;;AAEA,iG;AACA,I;;AAEA,sC;AACA,wB;;AAEA,0B;;AAEA,oD;AACA,oD;AACA,K;;AAEA,mD;AACA,kD;AACA,K;;AAEA,gG;AACA,6F;AACA,K;;AAEA,I;;AAEA,sC;AACA,wB;AACA,yB;AACA,0F;;AAEA,6B;AACA,I;;AAEA,iD;AACA,wB;;AAEA,2D;AACA,8E;AACA,gE;AACA,sC;AACA,gD;AACA,O;AACA,O;;AAEA,gC;AACA,+E;AACA,wB;AACA,K;;AAEA,gC;AACA,sD;AACA,4D;AACA,K;AACA,I;;AAEA,0C;AACA,wB;AACA,oD;AACA,+B;AACA,4B;AACA,S;AACA,W;AACA,G;;AAEA,mC;AACA,4B;AACA,4D;AACA,4D;;AAEA,0B;AACA,iB;AACA,O;AACA,yC;AACA,iB;AACA,O;AACA,yC;AACA,kB;AACA,O;AACA,iD;AACA,iD;AACA,e;AACA,K;AACA,G;;AAEA,gC;AACA,4B;AACA,0B;AACA,iB;AACA,O;AACA,0B;AACA,iB;AACA,O;AACA,0B;AACA,kB;AACA,O;;AAEA,iC;AACA,iC;;AAEA,mD;AACA,mD;;AAEA,e;AACA,K;AACA,G;;AAEA,2B;AACA,wB;;AAEA,mD;AACA,a;AACA,K;;AAEA,mF;AACA,kC;;AAEA,qC;AACA,sG;AACA,uF;AACA,K;;AAEA,+D;AACA,qB;AACA,2B;AACA,kB;AACA,gC;AACA,c;AACA,c;AACA,mC;AACA,K;;AAEA,0D;;AAEA,sB;AACA,sE;AACA,uF;AACA,K;;AAEA,kF;AACA,I;;AAEA,sC;AACA,wB;;AAEA,gH;AACA,wC;AACA,K;;AAEA,e;AACA,I;;AAEA,wC;AACA,wB;AACA,qF;AACA,2D;AACA,8C;AACA,mB;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,uD;AACA,iF;AACA,K;AACA,I;;AAEA,8B;AACA,qD;AACA,G;;AAEA,gD;AACA,wB;;AAEA,4B;AACA,a;AACA,K;;;AAGA,uD;AACA,6C;AACA,2C;AACA,O;AACA,K;;AAEA,kC;AACA,gI;AACA,K;;;;AAIA,oC;;AAEA,I;;AAEA,gD;AACA,wB;;AAEA,4B;AACA,a;AACA,K;;AAEA,yE;;AAEA,6C;;AAEA,uD;;AAEA,2D;AACA,2C;AACA,O;AACA,K;;AAEA,oC;;AAEA,I;;AAEA,yD;AACA,wB;AACA,kC;AACA,uB;AACA,mB;AACA,a;AACA,K;;AAEA,8C;AACA,iD;AACA,iC;AACA,0E;AACA,sC;AACA,c;AACA,O;AACA,K;;AAEA,4B;AACA,wD;AACA,mC;AACA,0B;AACA,gG;AACA,a;AACA,K;AACA,I;AACA,C;AACA,mD;;AAEA,iD;AACA,2C;AACA,G;AACA,2D;AACA,qD;AACA,G;AACA,+D;AACA,uE;;AAEA,gD;AACA,+C;;;AAGA,0B;AACA,e;;AAEA,4D;AACA,6C;AACA,uB;AACA,K;;AAEA,yB;AACA,2B;AACA,8B;AACA,8B;AACA,yB;;AAEA,iC;AACA,qB;AACA,G;;AAEA,8D;AACA,6C;AACA,uB;AACA,K;;AAEA,yB;AACA,4B;AACA,8B;AACA,6B;AACA,+B;AACA,yB;;AAEA,iC;AACA,qB;AACA,G;;AAEA,+C;AACA,8C;AACA,4B;;AAEA,6B;AACA,gC;AACA,6E;AACA,c;AACA,+E;AACA,O;AACA,K;;AAEA,uD;AACA,kB;AACA,G;;AAEA,0C;AACA,2E;AACA,0E;AACA,Y;AACA,kE;AACA,oE;AACA,wD;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,iD;AACA,6B;AACA,2B;AACA,2B;AACA,6B;AACA,iC;;AAEA,sE;;;AAGA,wB;;AAEA,uD;AACA,4B;AACA,O;;AAEA,2B;AACA,c;AACA,S;AACA,2B;AACA,mC;AACA,+C;AACA,0D;AACA,Y;AACA,iC;AACA,8C;AACA,0F;AACA,qF;;AAEA,uG;AACA,W;AACA,U;AACA,S;AACA,2B;AACA,mC;AACA,+C;AACA,4D;AACA,Y;AACA,iC;AACA,8C;AACA,0F;AACA,qF;;AAEA,iH;AACA,W;AACA,U;AACA,8B;AACA,S;AACA,0B;AACA,4C;AACA,+C;AACA,0D;AACA,Y;AACA,iC;AACA,8C;AACA,uF;AACA,+E;;AAEA,8G;AACA,W;AACA,U;AACA,S;AACA,2B;AACA,6C;AACA,+C;AACA,4D;AACA,Y;AACA,iC;AACA,8C;AACA,uF;AACA,+E;;AAEA,oG;AACA,W;AACA,U;AACA,8B;AACA,S;AACA,4B;AACA,6B;AACA,+C;AACA,qE;AACA,kE;AACA,Y;AACA,iC;AACA,8C;AACA,0F;AACA,qF;AACA,uD;AACA,W;AACA,U;AACA,S;AACA,4B;AACA,gC;AACA,+C;AACA,qE;AACA,kE;AACA,Y;AACA,iC;AACA,8C;AACA,uF;AACA,+E;AACA,oD;AACA,W;AACA,U;AACA,8B;AACA,S;AACA,sB;AACA,uB;AACA,iC;AACA,wB;AACA,Y;AACA,iC;AACA,qE;AACA,W;AACA,U;AACA,S;AACA,sB;AACA,uB;AACA,iC;AACA,wB;AACA,Y;AACA,iC;AACA,qE;AACA,W;AACA,U;AACA,8B;AACA,S;AACA,gC;AACA,6B;AACA,oC;AACA,yF;AACA,qC;AACA,sD;AACA,a;AACA,yB;AACA,Y;AACA,iC;AACA,yF;;AAEA,4B;AACA,4D;AACA,kF;AACA,e;;AAEA,0B;AACA,W;AACA,U;AACA,8B;AACA,S;AACA,2B;AACA,4B;AACA,oB;AACA,oB;AACA,e;AACA,mC;AACA,qC;AACA,qF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,oF;AACA,kB;AACA,+B;AACA,gB;AACA,e;AACA,mC;AACA,uC;AACA,uF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,sF;AACA,kB;AACA,+B;AACA,gB;AACA,e;AACA,mC;AACA,sC;AACA,sF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,qF;AACA,kB;AACA,+B;AACA,gB;AACA,e;AACA,mC;AACA,wC;AACA,wF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,uF;AACA,kB;AACA,+B;AACA,gB;AACA,oC;AACA,e;AACA,mC;AACA,oC;AACA,oF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,iF;AACA,kB;AACA,+B;AACA,gB;AACA,e;AACA,mC;AACA,uC;AACA,uF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,oF;AACA,kB;AACA,+B;AACA,gB;AACA,e;AACA,mC;AACA,uC;AACA,uF;;AAEA,iC;AACA,4D;AACA,mB;AACA,+B;AACA,kB;AACA,uC;AACA,oF;AACA,kB;AACA,+B;AACA,e;AACA,a;AACA,W;AACA,S;AACA,O;AACA,M;;AAEA,6B;;AAEA,kE;;AAEA,2B;;AAEA,0C;AACA,mK;AACA,M;;AAEA,8D;AACA,+B;;AAEA,qD;AACA,4D;AACA,sE;AACA,8B;AACA,uB;AACA,S;AACA,S;;AAEA,0B;AACA,M;;AAEA,qD;AACA,iF;AACA,wD;AACA,iF;AACA,wD;AACA,yE;;AAEA,K;;AAEA,wD;AACA,+E;AACA,uD;AACA,iF;AACA,wD;AACA,yE;;AAEA,K;;AAEA,0B;AACA,0B;AACA,0C;;AAEA,qD;AACA,+E;AACA,yD;AACA,uB;AACA,K;;AAEA,wD;AACA,kF;AACA,4D;AACA,uB;AACA,K;;AAEA,iC;AACA,yE;AACA,K;;AAEA,6D;AACA,qC;;AAEA,qD;AACA,6C;AACA,oC;AACA,uC;AACA,S;AACA,S;;AAEA,gC;AACA,M;;AAEA,4F;;AAEA,G;;AAEA,M;AACA,uC;AACA,oB;AACA,e;AACA,gB;AACA,K;AACA,+D;AACA,mB;AACA,2E;AACA,gD;AACA,K;;AAEA,a;AACA,mB;AACA,kE;AACA,Y;AACA,sD;AACA,K;;;AAGA,gB;AACA,2C;AACA,uD;AACA,qB;AACA,kD;AACA,O;AACA,iE;AACA,K;;AAEA,uC;AACA,4B;AACA,qB;AACA,iC;AACA,K;;AAEA,gB;AACA,I;;AAEA,uD;;AAEA,6C;AACA,iD;;AAEA,sB;;AAEA,6B;AACA,iD;;AAEA,kE;AACA,gE;;AAEA,gD;AACA,4J;AACA,iB;AACA,S;AACA,O;AACA,mC;AACA,sD;;AAEA,6B;;AAEA,wC;;AAEA,iJ;AACA,K;AACA,gE;;AAEA,sI;AACA,I;;AAEA,uD;AACA,+C;AACA,8E;AACA,gF;AACA,I;;AAEA,yD;AACA,oC;AACA,mF;AACA,qF;AACA,uC;AACA,K;AACA,I;;AAEA,+D;AACA,2B;;AAEA,iD;AACA,wD;;AAEA,+I;AACA,a;AACA,K;;AAEA,kD;AACA,uD;AACA,e;AACA,O;AACA,sD;AACA,+E;;AAEA,8F;AACA,6B;AACA,K;AACA,I;;AAEA,yD;AACA,8B;AACA,gE;AACA,+E;AACA,I;;AAEA,uD;AACA,oB;;AAEA,kC;AACA,iC;;AAEA,oB;AACA,kB;AACA,wB;AACA,uB;AACA,qB;AACA,uB;AACA,gB;AACA,S;AACA,uB;AACA,kE;AACA,S;AACA,Q;AACA,0B;AACA,uC;AACA,mD;AACA,Q;AACA,0D;AACA,+D;AACA,O;AACA,M;;AAEA,yD;;;AAGA,6D;AACA,2E;AACA,8C;AACA,O;;AAEA,2B;AACA,2B;;AAEA,qD;AACA,I;;AAEA,iD;AACA,oB;AACA,8B;AACA,6B;AACA,2B;AACA,I;;AAEA,gD;AACA,mC;AACA,kC;AACA,iB;AACA,yB;AACA,O;;AAEA,K;AACA,0B;AACA,I;;AAEA,8D;AACA,gC;AACA,e;AACA,sB;AACA,K;;AAEA,I;;AAEA,gD;AACA,gC;AACA,wC;;AAEA,uB;AACA,iC;AACA,I;;AAEA,mF;AACA,2B;AACA,uC;AACA,gD;;AAEA,sC;AACA,wC;AACA,K;;AAEA,+B;AACA,4B;;AAEA,gC;AACA,mD;AACA,Y;AACA,qD;AACA,K;;AAEA,+B;AACA,kD;;AAEA,6E;AACA,gC;AACA,S;;AAEA,Y;AACA,4B;AACA,mD;;;AAGA,+E;AACA,wC;AACA,W;;AAEA,c;AACA,sD;AACA,uD;;AAEA,+E;AACA,wC;AACA,W;AACA,O;AACA,K;;;AAGA,8B;AACA,4C;AACA,K;;AAEA,oC;AACA,yE;AACA,K;;AAEA,mC;AACA,iI;AACA,K;;;AAGA,I;;AAEA,6E;AACA,wC;;AAEA,0B;AACA,iD;AACA,oC;AACA,sC;AACA,O;AACA,Y;AACA,oC;AACA,K;;AAEA,kD;AACA,mD;AACA,sD;;AAEA,mE;AACA,gD;;AAEA,gC;AACA,iD;;AAEA,K;AACA,I;;AAEA,sE;;AAEA,uD;AACA,2B;;AAEA,2C;;AAEA,4B;;AAEA,8C;AACA,+B;AACA,+B;AACA,yC;AACA,c;;AAEA,6C;AACA,wB;AACA,qD;AACA,S;AACA,c;;AAEA,kD;;AAEA,yB;;AAEA,iD;;AAEA,gB;;AAEA,4E;;AAEA,S;;AAEA,+B;AACA,yC;;AAEA,c;;AAEA,gD;AACA,yB;;AAEA,gD;;AAEA,gB;;AAEA,4E;;AAEA,S;;AAEA,+B;AACA,yC;;AAEA,c;AACA,mD;AACA,wB;AACA,iC;AACA,uD;;AAEA,mD;AACA,0D;AACA,W;AACA,S;AACA,+B;AACA,yC;;AAEA,c;;AAEA,kD;AACA,wB;;AAEA,kF;AACA,iD;AACA,iD;;AAEA,4B;AACA,sD;;AAEA,6D;AACA,+C;AACA,iD;AACA,a;AACA,W;AACA,iC;AACA,2C;AACA,S;AACA,c;AACA,K;;AAEA,wC;;AAEA,6C;;AAEA,gG;AACA,uC;AACA,c;AACA,kC;AACA,O;;AAEA,K;;;AAGA,uC;;AAEA,6C;AACA,kD;;AAEA,8F;AACA,6C;AACA,c;AACA,wC;AACA,O;;AAEA,K;;AAEA,iD;AACA,4B;AACA,4F;;AAEA,sB;AACA,e;AACA,O;;AAEA,8F;AACA,+C;AACA,c;AACA,0C;AACA,O;AACA,K;;AAEA,iD;;AAEA,4B;AACA,0E;;AAEA,sB;AACA,e;AACA,O;;AAEA,8F;AACA,+C;AACA,c;AACA,0C;AACA,O;;AAEA,K;;AAEA,4D;AACA,iD;AACA,6D;AACA,mE;AACA,gD;AACA,6D;;AAEA,sD;AACA,uC;AACA,K;AACA,I;;AAEA,kC;AACA,yD;AACA,iC;AACA,wB;AACA,O;AACA,K;AACA,G;;AAEA,uC;AACA,yD;AACA,iC;AACA,iB;AACA,O;AACA,K;AACA,G;;AAEA,qD;AACA,mB;;AAEA,uC;AACA,uC;AACA,4B;AACA,c;AACA,kD;AACA,O;AACA,K;;AAEA,sC;;AAEA,+B;AACA,0B;AACA,K;;AAEA,yB;AACA,wC;AACA,K;;AAEA,iB;AACA,gB;AACA,8B;AACA,wC;AACA,+C;AACA,oE;AACA,W;AACA,gB;AACA,6D;AACA,W;AACA,sB;AACA,8B;AACA,W;AACA,2C;AACA,+C;AACA,yD;AACA,W;AACA,0B;AACA,2B;AACA,W;AACA,0B;AACA,S;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,sE;AACA,0D;AACA,4D;;AAEA,kB;AACA,kC;AACA,8B;AACA,wB;AACA,6C;AACA,2B;AACA,6B;AACA,gC;AACA,6B;AACA,M;;AAEA,4E;AACA,uD;AACA,Y;AACA,mD;AACA,yD;AACA,c;AACA,yD;AACA,O;AACA,K;;AAEA,gF;AACA,2D;AACA,Y;AACA,0D;AACA,K;AACA,I;;AAEA,kE;AACA,c;AACA,wE;AACA,0D;AACA,4D;AACA,6D;AACA,8D;;AAEA,kB;AACA,mB;AACA,uC;AACA,oB;AACA,yC;AACA,2B;AACA,6B;AACA,4C;AACA,yC;AACA,M;;AAEA,6E;AACA,iD;AACA,Y;AACA,mD;AACA,mD;AACA,c;AACA,mD;AACA,O;AACA,K;;AAEA,gF;AACA,qD;AACA,Y;AACA,oD;AACA,K;;AAEA,I;;AAEA,uE;AACA,mD;AACA,I;;AAEA,uF;AACA,oE;AACA,I;;AAEA,2F;AACA,oE;AACA,I;;AAEA,2E;;AAEA,uC;AACA,I;;AAEA,oF;AACA,kB;AACA,mF;AACA,Y;AACA,+D;AACA,K;AACA,I;;AAEA,wF;AACA,kB;AACA,kE;AACA,Y;AACA,+C;AACA,K;AACA,I;;AAEA,uF;AACA,kB;AACA,gE;AACA,Y;AACA,gE;AACA,K;AACA,I;;AAEA,yB;;AAEA,8D;AACA,Y;AACA,yC;AACA,0C;AACA,K;AACA,I;;AAEA,mD;AACA,0D;AACA,I;;AAEA,kD;AACA,wD;AACA,I;;AAEA,kD;AACA,yD;AACA,I;;AAEA,8C;AACA,wB;AACA,0B;AACA,6B;AACA,K;AACA,I;;AAEA,+C;AACA,uB;AACA,2B;AACA,sB;AACA,+B;AACA,+B;AACA,K;AACA,I;;AAEA,+C;AACA,oB;AACA,mC;AACA,kC;AACA,6B;AACA,iB;AACA,yB;AACA,sD;AACA,gC;AACA,S;AACA,O;AACA,K;;AAEA,6B;AACA,6B;;AAEA,I;;AAEA,uE;AACA,mE;AACA,4B;;AAEA,+D;AACA,uD;AACA,2D;AACA,2B;AACA,c;AACA,O;AACA,K;;AAEA,uB;AACA,I;;AAEA,sD;AACA,0B;AACA,6C;AACA,K;AACA,I;;AAEA,8C;;AAEA,2B;;AAEA,8D;AACA,a;AACA,K;;AAEA,gC;AACA,wB;AACA,gD;;AAEA,wC;AACA,0E;AACA,iC;AACA,c;AACA,4B;AACA,O;AACA,K;;AAEA,gH;AACA,G;;AAEA,mB;AACA,wB;AACA,gE;AACA,mG;;AAEA,6B;AACA,kC;AACA,wE;AACA,O;AACA,oC;AACA,sC;AACA,qC;AACA,kC;AACA,K;AACA,G;;AAEA,4C;AACA,sD;AACA,oD;;AAEA,sE;;AAEA,yC;;AAEA,iB;;AAEA,6B;;AAEA,yD;AACA,4D;AACA,yD;AACA,wB;AACA,M;AACA,uD;AACA,oC;AACA,uE;AACA,M;AACA,uC;AACA,0C;AACA,wC;AACA,4B;AACA,M;AACA,uC;;AAEA,wC;AACA,gE;AACA,kH;AACA,yE;AACA,wC;AACA,gD;AACA,W;AACA,6B;AACA,gC;AACA,S;AACA,O;;AAEA,uG;AACA,M;AACA,oC;AACA,8D;AACA,iH;AACA,M;AACA,oD;AACA,4D;AACA,6C;AACA,4D;;AAEA,6C;AACA,gE;AACA,+C;AACA,kC;AACA,wC;AACA,M;AACA,yC;AACA,2D;;AAEA,sB;AACA,iD;;AAEA,0D;AACA,iE;AACA,uC;;AAEA,0D;AACA,uE;AACA,O;;AAEA,yB;;AAEA,iE;;AAEA,yE;AACA,mB;AACA,sB;AACA,M;AACA,kD;AACA,mE;AACA,+B;AACA,0E;AACA,yB;AACA,uE;AACA,c;;AAEA,qD;AACA,S;AACA,8D;AACA,kC;AACA,S;AACA,M;;AAEA,U;AACA,uB;AACA,iH;AACA,M;AACA,mC;AACA,sE;AACA,mB;;AAEA,yB;AACA,6B;AACA,O;AACA,+C;AACA,yC;AACA,yC;AACA,M;AACA,wC;AACA,mD;AACA,wB;AACA,M;AACA,qD;AACA,6B;AACA,sE;AACA,kD;;AAEA,2D;AACA,0B;AACA,O;AACA,wB;AACA,K;;;AAGA,I;AACA,C;;;AAGA,wB;AACA,wB;AACA,0D;;AAEA,0B;AACA,qD;AACA,qC;AACA,K;AACA,I;AACA,wE;AACA,gC;AACA,2E;AACA,K;AACA,I;AACA,+D;AACA,wB;AACA,2C;AACA,a;AACA,K;;AAEA,kE;;AAEA,+B;AACA,6B;AACA,yB;AACA,mF;AACA,2D;;AAEA,Q;AACA,kD;AACA,qE;AACA,Q;AACA,6B;AACA,qB;AACA,O;AACA,O;;AAEA,+B;AACA,4B;AACA,yB;AACA,+B;AACA,Q;AACA,kD;AACA,sF;AACA,Q;AACA,6B;AACA,mF;AACA,2B;AACA,O;AACA,O;AACA,I;;AAEA,2C;AACA,0F;AACA,uD;;;AAGA,G;AACA,+B;AACA,E;AACA,uB;AACA,gF;AACA,iF;AACA,E;AACA,iG;AACA,e;AACA,G;AACA,0B;AACA,yC;AACA,c;AACA,Y;AACA,Y;AACA,iB;AACA,gB;AACA,c;AACA,e;AACA,4C;AACA,2C;AACA,qD;;AAEA,yC;AACA,6C;;AAEA,+C;AACA,wB;AACA,qH;AACA,I;;AAEA,+C;AACA,wB;AACA,yB;AACA,kG;AACA,6B;AACA,I;;AAEA,oC;AACA,oB;AACA,mB;;AAEA,+F;AACA,uC;AACA,uB;AACA,kD;AACA,6B;AACA,wC;AACA,6C;AACA,+C;AACA,K;AACA,G;;AAEA,6C;AACA,yC;AACA,wB;AACA,oB;AACA,sE;AACA,K;AACA,U;AACA,0C;AACA,K;AACA,G;;AAEA,iC;AACA,wB;AACA,gD;AACA,+C;AACA,gD;AACA,yC;AACA,6E;AACA,uC;AACA,0C;AACA,4C;AACA,G;;AAEA,uC;AACA,iD;AACA,G;;AAEA,iC;AACA,mD;AACA,kD;AACA,G;;AAEA,8C;AACA,oC;AACA,kD;AACA,oB;AACA,c;AACA,qC;AACA,0C;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,mD;AACA,qC;AACA,oC;AACA,uB;AACA,c;AACA,0D;AACA,O;AACA,K;AACA,gB;AACA,I;;AAEA,gC;;AAEA,wB;AACA,gB;;AAEA,iF;AACA,yC;AACA,oD;AACA,mB;AACA,0B;AACA,mE;AACA,oD;AACA,6B;AACA,mE;AACA,a;AACA,a;AACA,kB;AACA,qD;AACA,a;AACA,W;AACA,S;AACA,O;;AAEA,kF;AACA,oE;AACA,8C;AACA,0C;AACA,2B;;AAEA,8B;AACA,4B;AACA,O;AACA,O;;AAEA,mE;AACA,oB;AACA,oE;AACA,O;AACA,O;;;AAGA,iE;AACA,oB;AACA,6B;AACA,wB;;AAEA,iF;AACA,gH;;AAEA,wC;AACA,6C;;AAEA,iD;;AAEA,8E;;AAEA,sD;AACA,O;AACA,O;;AAEA,mD;AACA,I;;AAEA,gC;AACA,yB;AACA,I;;AAEA,wD;AACA,mC;AACA,sD;AACA,2B;AACA,O;AACA,K;AACA,I;;AAEA,iC;AACA,oC;AACA,I;;AAEA,iC;AACA,wB;;AAEA,uE;;AAEA,+B;AACA,6E;;AAEA,iF;;AAEA,8D;AACA,iE;AACA,+D;AACA,kE;AACA,c;AACA,wC;AACA,O;;AAEA,kC;AACA,8B;AACA,oD;AACA,sC;AACA,wB;AACA,S;AACA,O;;AAEA,Y;AACA,8B;AACA,sC;AACA,K;AACA,I;;AAEA,mC;AACA,4E;AACA,8C;AACA,mE;AACA,gE;AACA,O;AACA,6C;AACA,K;AACA,e;AACA,I;;AAEA,kE;AACA,kD;AACA,qD;;AAEA,e;AACA,4C;;AAEA,8F;AACA,4C;;AAEA,wF;AACA,6C;AACA,+B;;AAEA,4C;AACA,0C;AACA,Q;;AAEA,qB;AACA,Q;;AAEA,0C;AACA,M;;AAEA,kE;AACA,oD;AACA,uD;;AAEA,8C;AACA,iC;;AAEA,uB;AACA,wC;AACA,gC;AACA,O;;AAEA,mC;AACA,+B;AACA,O;AACA,Y;AACA,0F;AACA,+C;AACA,gE;AACA,W;;AAEA,iG;AACA,gE;AACA,O;;AAEA,0C;AACA,M;AACA,C;AACA,4D;;AAEA,oE;AACA,iD;AACA,iD;AACA,G;;AAEA,2D;AACA,2D;AACA,G;AACA,kE;;AAEA,4E;AACA,4E;AACA,+C;;AAEA,iB;;;;AAIA,G;AACA,iC;AACA,E;AACA,uB;AACA,6E;AACA,8E;AACA,E;AACA,mG;AACA,e;AACA,G;AACA,0B;AACA,2C;AACA,e;AACA,gB;AACA,kB;AACA,c;AACA,a;AACA,Y;AACA,gB;AACA,iB;AACA,4C;AACA,2C;AACA,qD;;;;AAIA,2C;AACA,+C;;AAEA,4C;AACA,wB;AACA,+G;AACA,I;;AAEA,4C;AACA,wB;AACA,yB;AACA,+F;AACA,6B;AACA,I;;AAEA,oC;AACA,oB;AACA,mB;;AAEA,+F;AACA,uC;AACA,uB;AACA,kD;AACA,iC;AACA,2C;AACA,wC;AACA,0D;AACA,+C;AACA,K;AACA,G;;AAEA,oC;AACA,0D;AACA,G;;AAEA,iC;AACA,wB;AACA,gD;AACA,+C;AACA,uC;AACA,yC;AACA,6E;AACA,4C;AACA,G;;AAEA,mC;AACA,yC;AACA,G;;AAEA,iC;AACA,mD;AACA,kD;AACA,G;;AAEA,8C;AACA,oC;AACA,kD;AACA,oB;AACA,c;AACA,qC;AACA,0C;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,mD;AACA,qC;AACA,oC;AACA,uB;AACA,c;AACA,0D;AACA,O;AACA,K;AACA,gB;AACA,I;;AAEA,gC;AACA,wB;AACA,gB;AACA,qB;AACA,iC;;AAEA,kF;AACA,wC;AACA,kD;AACA,iB;AACA,yB;AACA,mD;AACA,W;AACA,S;AACA,O;AACA,O;;AAEA,kF;AACA,uE;AACA,0C;AACA,2B;;AAEA,wC;AACA,sD;AACA,gC;AACA,iF;AACA,iD;AACA,8C;AACA,mD;AACA,yF;AACA,a;AACA,yB;AACA,qC;AACA,kB;AACA,uD;AACA,S;AACA,mB;;AAEA,8C;AACA,6B;AACA,O;AACA,O;;AAEA,oE;AACA,oB;AACA,4E;AACA,2E;AACA,gC;AACA,+B;AACA,O;AACA,O;;AAEA,iE;AACA,oB;AACA,6B;AACA,wB;;AAEA,kC;AACA,0C;AACA,+C;;AAEA,gD;;AAEA,qF;AACA,S;;AAEA,sD;AACA,O;AACA,O;;AAEA,mD;AACA,I;;AAEA,gC;AACA,yB;AACA,I;;AAEA,iC;AACA,iC;AACA,I;;AAEA,iC;AACA,wB;AACA,6E;;AAEA,mC;AACA,sE;;AAEA,2E;;AAEA,2D;AACA,2D;AACA,sD;AACA,sD;AACA,c;AACA,qC;AACA,O;;AAEA,kC;AACA,8B;AACA,iD;AACA,sC;AACA,wB;AACA,S;AACA,O;AACA,K;AACA,U;AACA,8B;AACA,mC;AACA,K;AACA,I;;;AAGA,6C;AACA,gC;;AAEA,O;AACA,qH;AACA,4F;AACA,O;AACA,iE;;AAEA,6C;AACA,iB;AACA,I;;AAEA,+C;AACA,mD;AACA,gF;AACA,0C;AACA,K;AACA,iB;AACA,I;AACA,C;AACA,gE;;AAEA,sE;AACA,iD;AACA,mD;AACA,G;AACA,2D;AACA,6D;AACA,G;AACA,8E;;AAEA,iD;;AAEA,iB;;AAEA,G;AACA,8B;AACA,E;AACA,uB;AACA,2E;AACA,iF;AACA,E;AACA,mG;AACA,e;AACA,G;AACA,0B;AACA,2C;;AAEA,iB;AACA,kB;AACA,qB;AACA,gB;AACA,e;AACA,c;AACA,mB;AACA,mB;AACA,8C;AACA,6C;AACA,uD;;AAEA,0C;AACA,8C;;AAEA,4C;AACA,0B;AACA,6G;AACA,M;;AAEA,4C;AACA,yB;AACA,2B;AACA,+F;AACA,+B;AACA,M;;AAEA,sC;AACA,sB;AACA,qB;;AAEA,iG;AACA,yC;AACA,yB;AACA,oD;AACA,kC;AACA,+C;AACA,4C;AACA,4D;AACA,iD;AACA,O;AACA,K;;AAEA,sC;AACA,4D;AACA,K;;AAEA,mC;AACA,0B;AACA,kD;AACA,iD;AACA,yC;AACA,2C;AACA,6E;AACA,8C;AACA,K;;AAEA,qC;AACA,yC;AACA,K;;AAEA,mC;AACA,qD;AACA,oD;AACA,K;;AAEA,6C;AACA,sC;AACA,oD;AACA,sB;AACA,gB;AACA,uC;AACA,yC;AACA,S;AACA,O;AACA,mB;AACA,M;;AAEA,qD;AACA,uC;AACA,sC;AACA,yB;AACA,gB;AACA,4D;AACA,S;AACA,O;AACA,kB;AACA,M;;AAEA,kC;AACA,0B;AACA,kB;AACA,uB;AACA,mC;;AAEA,mF;AACA,sC;AACA,mD;AACA,mB;AACA,2B;AACA,qD;AACA,a;AACA,W;AACA,S;AACA,S;;AAEA,oF;AACA,sE;AACA,4C;AACA,6B;;AAEA,0C;AACA,wD;AACA,kC;AACA,kF;AACA,gD;AACA,qD;AACA,wF;AACA,e;AACA,2B;AACA,uC;AACA,oB;AACA,yD;AACA,W;AACA,qB;;AAEA,gD;AACA,gC;AACA,S;AACA,S;;AAEA,qE;AACA,sB;AACA,gF;AACA,6D;AACA,kC;AACA,iC;AACA,S;AACA,S;;AAEA,mE;AACA,sB;AACA,+B;AACA,0B;;AAEA,qC;AACA,4C;AACA,iD;;AAEA,gD;;AAEA,oF;AACA,W;;AAEA,wD;AACA,S;AACA,S;;AAEA,qD;AACA,M;;AAEA,kC;AACA,2B;AACA,M;;AAEA,mC;AACA,iC;AACA,M;;AAEA,mC;AACA,0B;AACA,6E;;AAEA,sC;;AAEA,mE;;AAEA,yE;;AAEA,2D;AACA,yD;AACA,sD;AACA,oD;AACA,gB;AACA,qC;AACA,S;;AAEA,qC;AACA,gC;AACA,iD;AACA,wC;AACA,0B;AACA,W;AACA,S;AACA,c;AACA,sC;AACA,wB;;AAEA,S;AACA,O;AACA,Y;AACA,gC;AACA,mC;AACA,O;AACA,M;;AAEA,gD;AACA,mE;;AAEA,8C;AACA,oB;AACA,M;;AAEA,mD;AACA,+C;AACA,uD;AACA,oD;AACA,4C;AACA,S;AACA,O;AACA,oB;AACA,M;AACA,G;;AAEA,4D;;AAEA,qE;AACA,mD;AACA,mD;AACA,K;;AAEA,6D;AACA,4D;AACA,K;;AAEA,+E;;AAEA,gD;;AAEA,iB;;AAEA,wC;;AAEA,gD;AACA,sD;;AAEA,sD;;AAEA,mB;AACA,wB;AACA,8D;;AAEA,wB;AACA,6B;AACA,sE;AACA,O;AACA,oC;AACA,gC;;AAEA,+B;AACA,6B;AACA,K;AACA,G;;AAEA,4B;AACA,wB;;AAEA,yC;;AAEA,gD;AACA,4C;AACA,M;;AAEA,iD;AACA,2C;AACA,M;;AAEA,+C;AACA,qF;AACA,wC;AACA,oD;AACA,0B;AACA,O;;AAEA,gD;AACA,O;AACA,G;;AAEA,2C;AACA,wB;AACA,2C;;AAEA,uD;AACA,6B;AACA,6C;;;AAGA,uB;AACA,mB;AACA,oC;AACA,gE;AACA,kB;AACA,gE;AACA,W;AACA,gB;;AAEA,sB;AACA,oC;AACA,mE;AACA,kB;AACA,mE;AACA,W;AACA,gB;;AAEA,uB;AACA,4G;AACA,gB;AACA,O;AACA,K;;AAEA,sC;AACA,kB;;AAEA,uD;AACA,6D;;AAEA,qB;AACA,K;;AAEA,O;AACA,2E;AACA,+E;AACA,O;AACA,6D;AACA,mC;;AAEA,+C;AACA,+C;;AAEA,gF;AACA,gE;AACA,yB;AACA,kB;AACA,qD;AACA,W;AACA,S;;AAEA,oB;AACA,S;;AAEA,K;;AAEA,O;AACA,yG;AACA,kC;AACA,O;AACA,oD;AACA,+C;AACA,+C;AACA,Q;AACA,K;;AAEA,6B;AACA,kD;AACA,c;AACA,oC;AACA,uE;AACA,O;AACA,K;AACA,G;;AAEA,qB;AACA,wB;;AAEA,2B;AACA,qC;AACA,kC;AACA,K;AACA,G;;AAEA,6B;AACA,wB;;AAEA,kE;AACA,yC;AACA,0C;AACA,2C;AACA,G;;AAEA,wB;AACA,wB;AACA,8C;;AAEA,wD;AACA,wD;;AAEA,wD;AACA,wD;;AAEA,8D;AACA,+B;AACA,mC;AACA,O;AACA,O;AACA,G;;AAEA,0B;AACA,wB;AACA,iD;;AAEA,2D;AACA,2D;;AAEA,2D;AACA,2D;;AAEA,wD;AACA,G;;AAEA,6B;AACA,wB;;AAEA,qC;;AAEA,4D;AACA,wC;AACA,O;;AAEA,G;AACA,K;;;AAGA,E;AACA,E;AACA,oC;AACA,E;AACA,K;;;AAGA,0B;;AAEA,gB;;AAEA,mC;AACA,2F;AACA,I;;AAEA,mC;AACA,8E;AACA,2E;AACA,iC;AACA,I;;AAEA,oC;AACA,mB;AACA,oB;AACA,I;;AAEA,kB;;AAEA,0C;AACA,oE;AACA,uC;AACA,0B;AACA,sB;AACA,K;;AAEA,I;;AAEA,iD;;AAEA,yD;;AAEA,wD;;AAEA,oE;;AAEA,I;;AAEA,+B;AACA,uD;AACA,I;;AAEA,+B;AACA,4D;AACA,sE;AACA,K;;AAEA,qB;AACA,I;;AAEA,C;;;AAGA,0B;AACA,0C;AACA,sB;;;AAGA,6B;AACA,0B;AACA,mE;;AAEA,0C;;AAEA,4B;AACA,mC;AACA,e;AACA,O;;AAEA,8B;AACA,qE;AACA,O;;AAEA,8C;;AAEA,8B;;AAEA,M;;AAEA,4C;AACA,0B;;AAEA,6C;AACA,M;;AAEA,6C;AACA,0B;;AAEA,qD;AACA,M;;AAEA,sC;AACA,0B;;AAEA,uC;AACA,oC;AACA,c;AACA,oC;AACA,O;;AAEA,M;;AAEA,iB;AACA,8C;AACA,8C;AACA,+C;AACA,M;;AAEA,iC;AACA,2C;AACA,8C;AACA,O;AACA,K;;AAEA,yB;AACA,0B;;AAEA,mC;AACA,6C;AACA,sD;AACA,S;AACA,O;AACA,K;;AAEA,4B;AACA,0B;;AAEA,mC;AACA,6C;AACA,yD;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,4D;AACA,+D;AACA,wE;AACA,Y;;AAEA,G;AACA,8B;AACA,G;AACA,wB;AACA,+C;AACA,sB;AACA,6B;AACA,0B;AACA,4B;AACA,kC;AACA,gE;AACA,kB;AACA,qE;AACA,4B;AACA,O;AACA,O;;AAEA,uF;;AAEA,iC;AACA,e;AACA,O;;AAEA,4E;AACA,0B;AACA,O;;AAEA,kE;AACA,mD;AACA,oE;AACA,kE;AACA,iF;AACA,0B;AACA,O;;AAEA,uF;;AAEA,iC;AACA,e;AACA,O;;AAEA,+E;AACA,0B;AACA,O;;AAEA,kE;AACA,mD;AACA,oF;AACA,2B;;AAEA,gE;AACA,sE;AACA,O;;AAEA,kB;AACA,2D;AACA,6F;AACA,O;;AAEA,6F;AACA,0B;AACA,O;AACA,I;;AAEA,4D;AACA,iC;AACA,oC;AACA,oC;AACA,K;AACA,I;;AAEA,K;AACA,yC;AACA,K;AACA,sD;AACA,iC;AACA,0C;;AAEA,mC;AACA,sB;AACA,8C;AACA,sC;AACA,wC;AACA,S;;;;AAIA,K;AACA,I;;AAEA,K;AACA,yC;AACA,K;AACA,sD;AACA,iC;AACA,4C;;AAEA,mC;AACA,sB;AACA,8C;AACA,sC;AACA,sC;AACA,S;;;;AAIA,K;AACA,I;;AAEA,K;AACA,4C;AACA,sB;AACA,K;AACA,iE;AACA,uC;AACA,I;;AAEA,K;AACA,4C;AACA,sB;AACA,K;AACA,iE;AACA,yC;AACA,I;;AAEA,K;AACA,wB;AACA,K;AACA,uD;AACA,gC;AACA,kC;AACA,I;;AAEA,8C;AACA,I;AACA,6D;AACA,I;AACA,6D;AACA,I;;AAEA,2D;AACA,2B;AACA,I;AACA,gG;AACA,2F;AACA,2D;AACA,0D;AACA,0D;;AAEA,sD;AACA,2B;AACA,K;;AAEA,wD;;AAEA,wD;;AAEA,sD;AACA,8C;AACA,mF;AACA,oE;AACA,qG;;AAEA,4C;;AAEA,O;;AAEA,gD;AACA,mF;AACA,oE;AACA,qG;;AAEA,4C;AACA,O;AACA,K;;AAEA,I;AACA,6F;AACA,2D;;AAEA,sD;AACA,2B;AACA,K;;AAEA,0D;;AAEA,wD;;AAEA,I;;AAEA,oE;AACA,uB;AACA,yB;AACA,I;AACA,mG;AACA,8F;AACA,2D;AACA,0D;AACA,I;AACA,8F;AACA,2D;AACA,8D;AACA,I;;AAEA,kE;AACA,uB;AACA,qB;AACA,I;AACA,mG;AACA,8F;AACA,qC;AACA,sD;;AAEA,iE;;AAEA,wD;AACA,sB;AACA,I;AACA,8F;AACA,2D;AACA,+D;AACA,I;;AAEA,uE;AACA,uB;AACA,yB;AACA,I;AACA,sG;AACA,iG;AACA,2D;AACA,0D;AACA,I;AACA,iG;AACA,2D;AACA,8D;AACA,I;;AAEA,8E;AACA,uB;AACA,qB;AACA,sC;AACA,2B;AACA,I;AACA,sG;AACA,iG;AACA,wB;AACA,oE;AACA,2C;;AAEA,mC;AACA,2D;;AAEA,oD;;AAEA,K;;AAEA,2C;AACA,mC;AACA,2D;AACA,kF;AACA,K;;AAEA,wD;AACA,sB;AACA,I;AACA,iG;AACA,2D;AACA,0D;AACA,I;AACA,iB;;AAEA,wB;;AAEA,kB;AACA,wB;AACA,yG;;AAEA,sB;AACA,6B;AACA,gE;;AAEA,wC;;AAEA,2D;AACA,uD;AACA,O;AACA,Y;AACA,4B;AACA,iC;;AAEA,+C;;AAEA,8D;AACA,0D;AACA,O;AACA,K;AACA,G;;AAEA,kC;AACA,wB;;AAEA,qE;;AAEA,iB;AACA,4G;AACA,iC;AACA,yC;AACA,O;AACA,iD;AACA,iC;AACA,yC;AACA,O;AACA,K;AACA,G;;AAEA,0C;AACA,wB;AACA,8B;AACA,uC;AACA,K;AACA,G;;AAEA,2C;AACA,+B;AACA,sC;AACA,M;;AAEA,+B;AACA,sC;AACA,M;;AAEA,0C;AACA,iD;AACA,M;;AAEA,0C;AACA,iD;AACA,M;;AAEA,oC;AACA,uC;AACA,M;AACA,G;;AAEA,kD;AACA,yB;AACA,yB;AACA,oC;AACA,oC;AACA,8B;AACA,G;;AAEA,4C;AACA,sD;;AAEA,iB;;AAEA,G;AACA,kG;AACA,e;AACA,G;AACA,yB;AACA,yB;AACA,uB;AACA,C;;AAEA,G;AACA,mE;AACA,G;AACA,8D;AACA,+B;AACA,E;;AAEA,G;AACA,6B;AACA,G;AACA,0D;AACA,2B;AACA,E;;AAEA,G;AACA,4D;AACA,W;AACA,W;AACA,G;AACA,gD;AACA,gB;AACA,gB;;AAEA,gC;AACA,wB;AACA,oC;AACA,G;AACA,wC;AACA,2B;AACA,uC;AACA,G;;AAEA,iC;AACA,yB;AACA,qC;AACA,G;AACA,uC;AACA,0B;AACA,sC;AACA,G;;AAEA,8B;AACA,E;;AAEA,iB;AACA,a;;AAEA,0C;AACA,4C;AACA,2C;AACA,6F;AACA,sC;AACA,mC;AACA,oC;AACA,a;AACA,K;AACA,U;AACA,wE;AACA,K;;AAEA,0D;AACA,wB;AACA,yC;AACA,O;AACA,6B;AACA,yC;AACA,O;;AAEA,wB;AACA,wC;AACA,O;AACA,6B;AACA,wC;AACA,O;AACA,O;;AAEA,0C;AACA,I;;AAEA,mD;AACA,wB;AACA,uD;;AAEA,mE;AACA,6C;AACA,O;;AAEA,qE;AACA,2C;AACA,yD;AACA,O;AACA,O;AACA,K;;AAEA,sD;AACA,uD;AACA,yB;AACA,K;;AAEA,8D;AACA,yB;AACA,K;;AAEA,oE;AACA,yB;AACA,K;;AAEA,mD;AACA,C;;AAEA,gD;;AAEA,sC;AACA,qD;;AAEA,wC;AACA,4C;AACA,sB;;AAEA,uD;;AAEA,sB;AACA,oC;AACA,e;AACA,O;;AAEA,iC;AACA,K;;AAEA,2B;AACA,wE;AACA,e;AACA,O;;AAEA,gI;AACA,6C;AACA,2C;AACA,0E;AACA,wE;AACA,gF;AACA,sD;AACA,8D;AACA,mC;AACA,8C;AACA,qF;AACA,uF;AACA,U;;AAEA,sE;AACA,wC;AACA,kF;AACA,S;AACA,S;;AAEA,gJ;AACA,M;;AAEA,sC;AACA,mC;AACA,2D;AACA,qE;AACA,6G;AACA,mC;AACA,2C;AACA,iB;AACA,S;;AAEA,kJ;;AAEA,yE;AACA,8G;AACA,S;AACA,O;AACA,K;;AAEA,gC;AACA,mD;AACA,qD;AACA,uC;AACA,4D;AACA,M;;AAEA,oF;;AAEA,+G;AACA,2G;;AAEA,O;AACA,uD;AACA,O;AACA,wC;;AAEA,4C;AACA,iD;AACA,iD;;AAEA,iD;AACA,gD;AACA,wD;AACA,iC;AACA,iC;AACA,mC;AACA,mC;AACA,uE;AACA,uE;;AAEA,4H;;AAEA,6D;AACA,uI;AACA,O;AACA,M;;AAEA,G;;;;AAIA,mB;AACA,yB;AACA,mE;;AAEA,6C;;AAEA,yD;;AAEA,sD;;AAEA,mC;AACA,gC;;AAEA,K;;AAEA,G;;AAEA,4C;AACA,sD;;AAEA,gD;AACA,uC;AACA,0B;;AAEA,e;;AAEA,mD;AACA,6D;AACA,0C;AACA,0C;AACA,2B;;AAEA,sB;AACA,mE;AACA,O;;AAEA,yB;AACA,yE;AACA,O;;AAEA,+D;AACA,iE;AACA,oE;AACA,wE;AACA,wE;AACA,iF;AACA,+D;;AAEA,2B;AACA,gC;AACA,4B;AACA,4B;AACA,4B;AACA,c;;AAEA,2C;AACA,W;;AAEA,6B;AACA,6E;AACA,W;AACA,S;AACA,O;;AAEA,yB;;AAEA,M;;AAEA,I;;AAEA,0F;AACA,+D;AACA,I;;AAEA,sE;;AAEA,iG;AACA,mB;AACA,K;;AAEA,sD;AACA,mB;AACA,K;;AAEA,6E;AACA,I;;AAEA,qE;;AAEA,6C;;AAEA,+D;AACA,sE;AACA,mF;;AAEA,Y;AACA,uC;AACA,+B;AACA,Q;;AAEA,yD;AACA,6C;AACA,Q;;AAEA,0C;AACA,kC;AACA,Q;;AAEA,+D;AACA,mD;AACA,Q;;AAEA,gD;AACA,wC;AACA,Q;;AAEA,oE;AACA,wD;AACA,O;AACA,K;;AAEA,O;;;;AAIA,qG;;AAEA,8K;;AAEA,sC;AACA,uD;AACA,Y;AACA,0D;AACA,K;AACA,I;;;;AAIA,+D;;AAEA,yG;AACA,6C;AACA,4D;AACA,I;;AAEA,mB;AACA,wB;;AAEA,wD;;AAEA,wB;AACA,0D;AACA,Y;AACA,6B;AACA,K;;AAEA,G;;AAEA,4C;AACA,sD;;;AAGA,iB;AACA,+B;;AAEA,sB;;AAEA,4C;AACA,wD;AACA,6I;AACA,uB;AACA,O;AACA,K;AACA,I;;AAEA,wC;AACA,wD;AACA,iE;AACA,uB;AACA,e;AACA,O;AACA,K;AACA,oB;AACA,I;;AAEA,+C;AACA,wD;AACA,uD;AACA,0B;AACA,c;AACA,O;AACA,K;AACA,I;;AAEA,oB;;AAEA,C;;;AAGA,G;AACA,6C;AACA,e;AACA,G;AACA,wC;AACA,2D;;AAEA,yC;AACA,qE;AACA,kE;AACA,K;AACA,G;AACA,C;;AAEA,G;AACA,0C;AACA,G;AACA,2D;AACA,kC;AACA,+B;AACA,E;;AAEA,wD;AACA,uC;AACA,W;AACA,G;;AAEA,6B;AACA,6C;AACA,qD;;AAEA,uB;AACA,gC;AACA,gC;AACA,mI;AACA,0D;AACA,qD;AACA,E;;AAEA,qE;AACA,2F;AACA,a;AACA,a;AACA,0C;AACA,G;AACA,Q;AACA,W;AACA,mC;AACA,G;AACA,E;;AAEA,4D;AACA,6B;AACA,E;;AAEA,8D;AACA,iF;AACA,+D;AACA,E;;AAEA,oE;AACA,6D;;AAEA,a;AACA,+C;AACA,+C;AACA,+C;AACA,K;AACA,U;AACA,oC;AACA,oC;;AAEA,gC;AACA,K;AACA,G;AACA,Q;AACA,kC;AACA,kC;AACA,G;AACA,E;;AAEA,qF;AACA,+C;AACA,wF;AACA,oB;AACA,O;AACA,mB;AACA,K;AACA,+C;AACA,wF;AACA,oB;AACA,O;AACA,mB;AACA,K;AACA,6C;AACA,+H;AACA,M;;AAEA,kB;AACA,mB;AACA,kB;AACA,I;;;AAGA,uC;;AAEA,kC;AACA,qE;AACA,K;AACA,2H;AACA,mK;AACA,8E;;AAEA,iG;AACA,mD;AACA,sG;AACA,iD;AACA,yC;AACA,c;AACA,O;AACA,K;;AAEA,8C;AACA,sF;AACA,gJ;AACA,8F;;AAEA,yD;AACA,sH;AACA,O;;AAEA,kH;AACA,kH;;AAEA,yC;AACA,qG;AACA,6C;AACA,0E;AACA,O;AACA,0C;AACA,qG;AACA,gD;AACA,0E;AACA,O;AACA,K;;AAEA,sJ;AACA,uG;;AAEA,gF;AACA,4C;AACA,kB;AACA,0D;AACA,yD;AACA,O;AACA,K;AACA,4C;AACA,iG;AACA,yD;AACA,sF;AACA,gJ;AACA,8F;AACA,iF;;AAEA,2F;AACA,mD;AACA,O;AACA,0C;AACA,0F;;AAEA,wI;AACA,4F;AACA,uD;AACA,mG;AACA,uD;AACA,W;AACA,0D;AACA,4F;AACA,uD;AACA,mG;AACA,uD;AACA,W;AACA,S;AACA,O;;AAEA,kD;AACA,iE;AACA,kE;;AAEA,4L;AACA,4B;AACA,iC;AACA,qD;AACA,wC;AACA,qD;AACA,W;AACA,S;AACA,4B;AACA,iC;AACA,qD;AACA,wC;AACA,qD;AACA,W;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,kD;AACA,kD;AACA,E;;AAEA,yC;AACA,iD;AACA,C;;AAEA,8B;AACA,sB;AACA,4D;;AAEA,0B;AACA,+B;AACA,8D;AACA,K;AACA,G;AACA,E;;AAEA,6B;AACA,sB;AACA,4B;AACA,O;AACA,4H;AACA,uJ;AACA,O;AACA,0D;AACA,8C;AACA,uG;AACA,0B;AACA,+B;AACA,S;AACA,O;AACA,mE;AACA,M;AACA,G;AACA,E;;AAEA,wC;AACA,yB;AACA,W;AACA,G;;AAEA,mE;;AAEA,iB;AACA,0C;AACA,uE;AACA,oB;AACA,uC;AACA,K;AACA,G;AACA,E;;AAEA,8D;AACA,uC;AACA,W;AACA,G;;AAEA,gE;;AAEA,6B;AACA,sB;AACA,uB;AACA,mC;AACA,kF;AACA,iB;AACA,+B;AACA,O;AACA,Y;AACA,6B;AACA,O;AACA,M;AACA,2B;AACA,uE;AACA,oB;AACA,M;AACA,2B;AACA,mB;AACA,K;AACA,K;AACA,E;;AAEA,0E;AACA,wB;AACA,sD;AACA,G;AACA,E;;AAEA,8C;AACA,2B;AACA,0D;AACA,4B;AACA,yD;AACA,yE;;AAEA,0C;AACA,oD;AACA,yC;AACA,yC;AACA,gD;AACA,4C;AACA,S;AACA,mG;AACA,wE;AACA,S;;AAEA,gD;AACA,4C;AACA,S;AACA,mG;AACA,wD;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,6H;AACA,gB;AACA,G;AACA,2C;;AAEA,+F;AACA,wD;AACA,0B;AACA,2C;AACA,gJ;AACA,yB;;AAEA,8B;AACA,Q;AACA,4B;;AAEA,8F;AACA,mE;AACA,sF;AACA,wI;;AAEA,oH;AACA,sD;AACA,uC;AACA,uC;;AAEA,+B;AACA,S;AACA,O;AACA,4B;;AAEA,G;AACA,E;;AAEA,G;AACA,yF;AACA,iB;AACA,mB;AACA,G;AACA,2D;AACA,yC;AACA,0D;AACA,4B;AACA,6C;AACA,6F;AACA,sF;;AAEA,8F;AACA,mE;AACA,sF;AACA,wI;AACA,oH;;AAEA,wD;AACA,2C;AACA,2C;AACA,S;;AAEA,uD;AACA,0C;AACA,0C;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,4D;AACA,wD;AACA,0B;AACA,iF;AACA,4E;AACA,sC;AACA,K;AACA,G;AACA,E;;AAEA,0D;AACA,wD;AACA,0B;AACA,oC;AACA,oB;AACA,wC;AACA,uF;AACA,wB;AACA,8C;AACA,0C;AACA,kG;AACA,S;AACA,O;AACA,qF;AACA,wB;AACA,iE;AACA,qC;AACA,iC;AACA,kG;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,6D;AACA,wD;AACA,0B;AACA,oC;AACA,oB;AACA,wC;AACA,0F;;AAEA,wB;AACA,iD;AACA,6C;AACA,qG;AACA,S;AACA,O;AACA,wF;AACA,wB;AACA,iE;AACA,wC;AACA,oC;AACA,qG;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,iD;AACA,sC;AACA,8D;AACA,iD;;AAEA,oC;AACA,0H;AACA,2F;AACA,8F;AACA,qB;AACA,O;AACA,K;AACA,G;AACA,oB;AACA,E;;AAEA,iD;AACA,+C;AACA,yD;AACA,+F;AACA,2F;AACA,+D;AACA,mE;AACA,wE;AACA,uD;AACA,uF;AACA,6D;AACA,iG;AACA,uG;;AAEA,qC;;;AAGA,c;;AAEA,6B;;AAEA,G;;AAEA,Q;AACA,uD;AACA,iB;AACA,O;AACA,0B;AACA,Y;AACA,8D;AACA,O;AACA,e;;;AAGA,M;AACA,sC;AACA,K;AACA,8C;AACA,2C;AACA,iC;AACA,oB;AACA,O;AACA,K;;AAEA,0C;AACA,oC;AACA,oB;AACA,O;AACA,K;AACA,iB;AACA,I;;;AAGA,M;AACA,sB;AACA,M;AACA,0B;;AAEA,sD;AACA,8B;AACA,wB;AACA,iD;AACA,O;AACA,K;AACA,I;;AAEA,M;AACA,gC;AACA,qB;AACA,sB;AACA,K;AACA,8C;AACA,iE;AACA,0E;AACA,iB;AACA,O;AACA,K;AACA,c;AACA,I;;AAEA,M;AACA,mE;AACA,kB;AACA,K;AACA,oD;AACA,uB;AACA,sB;AACA,qB;AACA,M;AACA,sH;AACA,kD;;AAEA,mB;AACA,qD;AACA,Y;AACA,kD;AACA,K;AACA,I;;AAEA,M;AACA,+C;AACA,I;AACA,e;AACA,e;AACA,qB;AACA,K;AACA,oE;AACA,8C;AACA,oD;AACA,kD;;AAEA,qC;AACA,I;;AAEA,M;AACA,0C;AACA,kB;AACA,K;AACA,6D;AACA,6B;;AAEA,iE;AACA,gE;;AAEA,kD;AACA,oB;;AAEA,mC;AACA,gB;AACA,2C;AACA,oC;AACA,W;AACA,S;;AAEA,gC;AACA,gB;AACA,8C;AACA,0C;AACA,W;AACA,S;;AAEA,mC;AACA,gB;AACA,4C;AACA,sC;AACA,W;AACA,S;;;AAGA,kC;AACA,gB;AACA,6C;AACA,wC;AACA,W;AACA,S;;;AAGA,kB;AACA,wD;AACA,2C;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,M;AACA,0D;AACA,e;AACA,e;AACA,sB;AACA,K;AACA,6C;AACA,4C;AACA,I;;;AAGA,M;AACA,2E;AACA,8C;AACA,K;AACA,+C;AACA,Y;AACA,e;AACA,mB;AACA,M;AACA,I;;;AAGA,M;AACA,2C;AACA,+B;AACA,K;AACA,6C;AACA,Y;AACA,gB;AACA,K;AACA,I;;;AAGA,M;AACA,8C;AACA,sE;AACA,K;AACA,2C;AACA,Y;AACA,e;AACA,oB;AACA,0B;AACA,K;AACA,I;;AAEA,M;AACA,sE;AACA,I;AACA,e;AACA,e;AACA,uJ;AACA,K;AACA,+C;AACA,Y;AACA,2C;AACA,sC;AACA,e;AACA,e;AACA,qC;AACA,uC;AACA,wC;AACA,qC;AACA,K;AACA,I;;;AAGA,mE;;AAEA,8C;AACA,iD;AACA,K;;AAEA,2C;AACA,2C;AACA,K;;AAEA,6C;AACA,+C;AACA,K;;AAEA,8C;AACA,iD;AACA,K;;AAEA,4C;AACA,6C;AACA,K;AACA,yB;AACA,I;;AAEA,M;AACA,iC;AACA,I;AACA,2B;AACA,K;AACA,yD;AACA,mE;;AAEA,4C;AACA,uB;AACA,yC;AACA,6C;AACA,iC;AACA,kD;AACA,W;AACA,S;AACA,O;AACA,K;AACA,I;;;AAGA,M;AACA,gD;AACA,I;AACA,e;AACA,e;AACA,K;AACA,4C;AACA,mD;AACA,0C;AACA,6C;AACA,I;;AAEA,M;AACA,qD;AACA,I;AACA,e;AACA,e;AACA,iB;AACA,kB;AACA,K;AACA,oD;;AAEA,yD;AACA,yD;AACA,iD;AACA,K;;AAEA,iB;AACA,qD;AACA,Y;AACA,uD;AACA,K;;AAEA,uD;;AAEA,mD;AACA,0C;AACA,0C;;AAEA,kB;AACA,I;;;AAGA,M;AACA,sD;AACA,I;AACA,iB;AACA,iB;AACA,kB;AACA,K;AACA,uD;;AAEA,0E;AACA,+B;AACA,oE;AACA,c;AACA,4E;AACA,O;AACA,Y;AACA,sB;AACA,yB;AACA,6E;AACA,uE;AACA,uD;AACA,a;AACA,W;AACA,gB;AACA,mB;AACA,6E;AACA,wE;AACA,W;AACA,gB;AACA,qB;AACA,kF;AACA,+D;AACA,W;AACA,gB;AACA,sB;AACA,sF;AACA,iE;AACA,W;AACA,gB;AACA,oB;AACA,+E;AACA,gE;AACA,W;AACA,gB;AACA,O;AACA,K;AACA,I;;AAEA,M;AACA,+C;AACA,I;AACA,e;AACA,qB;AACA,K;AACA,yD;AACA,oC;;AAEA,kD;AACA,qD;;AAEA,wB;AACA,uB;AACA,8D;AACA,uC;AACA,yC;AACA,W;AACA,gB;AACA,qC;AACA,uC;AACA,S;AACA,O;AACA,O;AACA,+B;AACA,I;;;AAGA,M;AACA,0C;AACA,I;AACA,iB;AACA,sB;AACA,K;AACA,uC;AACA,iK;AACA,I;;AAEA,M;AACA,uC;AACA,I;AACA,0B;AACA,K;AACA,kE;AACA,0C;AACA,a;AACA,K;;AAEA,kE;;AAEA,+B;AACA,qB;AACA,sB;AACA,gB;AACA,gB;AACA,gB;AACA,+B;AACA,gC;AACA,iE;AACA,6B;AACA,4C;AACA,e;;AAEA,2B;AACA,c;AACA,mC;AACA,iE;AACA,kF;AACA,c;AACA,2B;AACA,Y;AACA,kB;AACA,+B;AACA,kC;AACA,mE;AACA,6B;AACA,4C;AACA,e;AACA,2B;AACA,c;AACA,mC;AACA,mE;AACA,oF;AACA,c;AACA,2B;AACA,Y;AACA,mB;AACA,+B;AACA,mC;AACA,oE;AACA,6B;AACA,4C;AACA,e;AACA,2B;AACA,c;AACA,mC;AACA,oE;AACA,qF;AACA,c;AACA,2B;AACA,Y;AACA,iB;AACA,+B;AACA,iC;AACA,kE;AACA,6B;AACA,4C;AACA,e;;AAEA,0B;AACA,c;AACA,mC;AACA,kE;AACA,mF;AACA,c;AACA,2B;AACA,Y;AACA,mB;AACA,qC;AACA,mC;AACA,6E;AACA,c;AACA,mC;AACA,kD;AACA,a;AACA,W;AACA,S;AACA,O;AACA,O;AACA,I;;AAEA,6C;AACA,2F;;;AAGA,mD;AACA,yD;;AAEA,uB;;AAEA,oD;AACA,mC;AACA,wE;AACA,gB;AACA,+G;AACA,S;AACA,O;;AAEA,oB;AACA,8B;AACA,K;;AAEA,K;;AAEA,6C;;AAEA,K;;AAEA,G;AACA,4B;AACA,E;AACA,uB;AACA,6E;AACA,mF;AACA,E;AACA,iG;AACA,e;AACA,G;AACA,0B;AACA,wC;;AAEA,iB;AACA,e;AACA,e;AACA,oB;AACA,mB;AACA,kB;AACA,+C;AACA,8C;AACA,uD;;AAEA,wC;AACA,4C;;AAEA,8C;AACA,0B;AACA,iH;AACA,M;;AAEA,8C;AACA,0B;AACA,2B;AACA,iG;AACA,+B;AACA,M;;AAEA,sC;AACA,sB;AACA,qB;;AAEA,iG;AACA,yC;AACA,yB;AACA,oD;AACA,8B;AACA,8C;AACA,4C;AACA,iD;AACA,O;AACA,K;;AAEA,+C;AACA,2C;AACA,2B;AACA,sB;AACA,wE;AACA,O;AACA,Y;AACA,0C;AACA,O;AACA,K;;AAEA,mC;AACA,0B;AACA,kD;AACA,iD;AACA,kD;AACA,6E;AACA,6C;AACA,2C;AACA,2C;AACA,8C;AACA,K;;AAEA,yC;AACA,kD;AACA,K;;AAEA,mC;AACA,qD;AACA,oD;AACA,K;;AAEA,6C;AACA,sC;AACA,oD;AACA,sB;AACA,gB;AACA,uC;AACA,yC;AACA,S;AACA,O;AACA,mB;AACA,M;;AAEA,qD;AACA,uC;AACA,sC;AACA,yB;AACA,gB;AACA,4D;AACA,S;AACA,O;AACA,kB;AACA,M;;AAEA,kC;AACA,0B;AACA,kB;;;AAGA,mF;AACA,qC;AACA,mD;AACA,mB;AACA,0B;AACA,kE;AACA,2D;AACA,a;AACA,kB;AACA,qD;AACA,a;AACA,W;AACA,S;AACA,S;;AAEA,oF;AACA,oE;AACA,gD;AACA,4C;AACA,6B;;AAEA,gC;AACA,8B;AACA,S;AACA,S;;AAEA,qE;AACA,sB;AACA,sE;AACA,S;AACA,S;;AAEA,mE;AACA,sB;AACA,+B;AACA,0B;;AAEA,gF;AACA,4G;;AAEA,0C;AACA,+C;;AAEA,gD;;AAEA,6E;;AAEA,wD;AACA,S;AACA,S;;AAEA,qD;AACA,M;;AAEA,oC;AACA,2B;AACA,M;;AAEA,0D;AACA,qC;AACA,wD;AACA,6B;AACA,S;AACA,O;AACA,M;;AAEA,mC;AACA,mC;AACA,M;;AAEA,mC;AACA,0B;;AAEA,0E;;AAEA,iC;AACA,6E;;AAEA,4E;;AAEA,4D;AACA,4D;AACA,6D;AACA,8D;AACA,gB;AACA,uC;AACA,S;;AAEA,qC;AACA,gC;AACA,mD;AACA,4C;AACA,8B;AACA,W;AACA,S;AACA,c;AACA,gC;AACA,yC;AACA,O;;AAEA,M;;AAEA,qC;AACA,0B;AACA,iD;AACA,sE;AACA,+D;AACA,S;AACA,gD;AACA,O;;AAEA,iB;AACA,M;AACA,G;;AAEA,wD;;AAEA,mE;AACA,oD;AACA,iD;AACA,K;;AAEA,6D;AACA,2D;AACA,K;;AAEA,iE;AACA,8C;;AAEA,iB;;AAEA,G;AACA,kF;AACA,oE;AACA,E;AACA,0E;AACA,sD;AACA,E;AACA,mE;AACA,gD;AACA,G;AACA,0B;AACA,e;;AAEA,+B;AACA,6B;AACA,+B;;AAEA,iC;AACA,wB;AACA,oC;AACA,oB;AACA,yD;;;AAGA,4C;AACA,+B;AACA,oB;AACA,O;;AAEA,2E;AACA,qD;AACA,oC;AACA,S;AACA,+C;AACA,sC;AACA,O;AACA,M;;AAEA,yE;AACA,6B;AACA,O;;AAEA,yE;AACA,sC;AACA,iB;AACA,O;;AAEA,6L;AACA,8L;;;AAGA,oL;AACA,qC;AACA,oC;AACA,c;AACA,sC;AACA,O;;AAEA,kC;AACA,gC;AACA,uC;AACA,8C;AACA,gB;AACA,O;AACA,O;;AAEA,M;AACA,uE;AACA,O;AACA,8F;AACA,wF;AACA,6C;AACA,mC;;AAEA,qC;AACA,M;;AAEA,kF;AACA,kG;;AAEA,2J;AACA,6C;AACA,6C;AACA,gD;AACA,O;;AAEA,+C;AACA,M;;AAEA,kF;AACA,yC;AACA,M;;AAEA,G;;AAEA,K;AACA,+C;AACA,K;AACA,yC;AACA,qB;AACA,I;;AAEA,K;AACA,iD;AACA,K;AACA,8C;AACA,kC;AACA,M;;AAEA,K;AACA,wF;AACA,K;AACA,qD;AACA,mC;;AAEA,iD;AACA,oE;AACA,O;AACA,Y;AACA,uE;AACA,O;;AAEA,qC;AACA,0E;AACA,kD;AACA,2B;AACA,uB;AACA,W;AACA,S;AACA,mE;AACA,mB;AACA,S;AACA,O;AACA,iB;AACA,sD;AACA,mG;AACA,8F;AACA,qB;AACA,O;AACA,M;;AAEA,K;AACA,gF;AACA,K;AACA,4C;AACA,0C;;AAEA,gC;;AAEA,gE;AACA,kB;AACA,e;AACA,O;;AAEA,8D;AACA,0C;AACA,wD;;AAEA,wB;;AAEA,0C;AACA,0C;;AAEA,wC;;AAEA,qB;;AAEA,uD;AACA,oD;;AAEA,oD;AACA,0D;AACA,qH;;AAEA,4B;AACA,W;;AAEA,2B;AACA,S;;AAEA,0D;AACA,oD;;AAEA,oD;AACA,0D;AACA,qH;;AAEA,qB;AACA,4B;;AAEA,6B;AACA,W;AACA,S;;AAEA,sB;AACA,Q;;AAEA,oD;;AAEA,iD;AACA,oE;AACA,O;AACA,Y;AACA,uE;AACA,O;;AAEA,oB;;AAEA,yD;AACA,2B;;AAEA,0C;AACA,kB;AACA,iB;AACA,U;AACA,wC;AACA,kB;AACA,yB;AACA,U;AACA,O;AACA,8D;AACA,4B;;AAEA,0C;AACA,kB;AACA,uB;AACA,U;AACA,wC;AACA,kB;AACA,iB;AACA,U;AACA,O;AACA,8D;AACA,yB;;AAEA,0C;AACA,kB;AACA,iB;AACA,U;AACA,wC;AACA,wB;AACA,iB;AACA,U;AACA,O;AACA,8D;AACA,2B;;AAEA,0C;AACA,wB;AACA,iB;AACA,U;AACA,wC;AACA,kB;AACA,iB;AACA,U;AACA,O;;AAEA,sD;AACA,8G;;AAEA,8G;;AAEA,6D;;AAEA,mF;;AAEA,4H;;AAEA,2F;AACA,yF;AACA,c;AACA,sC;AACA,gD;AACA,M;AACA,M;;AAEA,K;AACA,qB;AACA,0C;AACA,K;AACA,uD;AACA,wE;AACA,gF;AACA,kI;AACA,wE;AACA,O;AACA,uE;AACA,wE;AACA,O;AACA,Y;AACA,iC;AACA,O;;AAEA,oD;AACA,uF;AACA,qF;AACA,wD;AACA,kC;AACA,M;;AAEA,wD;AACA,oB;AACA,gB;AACA,4C;AACA,kB;;AAEA,0F;AACA,8C;AACA,uE;;AAEA,6E;AACA,kC;;AAEA,+D;AACA,4C;AACA,qC;AACA,iB;AACA,O;AACA,K;;AAEA,I;;;AAGA,mD;AACA,sC;;AAEA,+D;AACA,uE;AACA,2B;AACA,O;AACA,6E;AACA,iC;AACA,6B;AACA,O;AACA,K;;AAEA,K;;AAEA,mC;;AAEA,iB;;AAEA,oC;AACA,K;AACA,mB;AACA,kB;AACA,K;AACA,kB;;AAEA,K;AACA,qB;AACA,kF;AACA,K;AACA,c;AACA,W;AACA,a;AACA,c;AACA,a;AACA,Y;AACA,I;;AAEA,K;AACA,yC;AACA,yC;AACA,K;AACA,kB;AACA,Y;AACA,W;AACA,I;;AAEA,K;AACA,6C;AACA,yC;AACA,K;AACA,gB;AACA,Y;AACA,W;AACA,I;;AAEA,K;AACA,wB;AACA,kB;AACA,K;AACA,sB;;AAEA,K;AACA,2B;AACA,kB;AACA,K;AACA,sB;;AAEA,K;AACA,iB;AACA,K;AACA,iB;AACA,2D;AACA,4C;AACA,wC;AACA,M;AACA,iC;AACA,yC;AACA,qC;AACA,sC;AACA,gC;AACA,M;AACA,sD;AACA,6D;AACA,M;AACA,6B;AACA,yC;AACA,I;;AAEA,K;AACA,8B;AACA,6B;AACA,mC;AACA,wB;AACA,K;AACA,qD;AACA,oC;AACA,yJ;AACA,K;AACA,I;;AAEA,K;AACA,2C;AACA,yB;AACA,uB;AACA,qB;AACA,K;AACA,mC;AACA,iB;AACA,wB;AACA,uB;AACA,K;;AAEA,e;AACA,I;;AAEA,K;AACA,2B;AACA,gB;AACA,c;AACA,oE;AACA,K;AACA,sD;AACA,mB;AACA,c;AACA,kB;AACA,iB;AACA,Q;;AAEA,6B;AACA,0C;AACA,0B;AACA,gB;AACA,kB;AACA,qB;AACA,U;AACA,yB;AACA,O;;AAEA,Y;AACA,0C;AACA,0B;AACA,gB;AACA,sB;AACA,iB;AACA,U;AACA,yB;AACA,O;AACA,K;;AAEA,4C;AACA,oB;AACA,oB;;AAEA,+E;AACA,kD;AACA,0D;AACA,2B;AACA,gB;;AAEA,0D;AACA,2B;AACA,gB;AACA,K;;AAEA,Y;AACA,c;AACA,wB;AACA,uB;AACA,Q;AACA,yB;AACA,M;AACA,I;;AAEA,K;AACA,6B;AACA,0E;AACA,qB;AACA,K;AACA,yC;AACA,qB;;AAEA,4C;AACA,4C;AACA,K;;AAEA,mB;AACA,I;;AAEA,K;AACA,4B;AACA,0C;AACA,wC;AACA,uC;AACA,qB;AACA,K;AACA,gE;AACA,yB;AACA,uB;;AAEA,0D;AACA,wC;AACA,sC;;AAEA,qB;;AAEA,6C;AACA,4B;AACA,yB;AACA,+B;AACA,mC;AACA,mC;;AAEA,uC;AACA,yE;AACA,8B;AACA,S;AACA,O;AACA,K;;AAEA,qB;AACA,qB;AACA,+C;AACA,4B;AACA,uB;AACA,+C;AACA,K;;AAEA,qB;AACA,gD;AACA,4C;AACA,S;AACA,K;;AAEA,oB;AACA,iC;AACA,kD;AACA,8B;AACA,W;AACA,wC;AACA,kD;AACA,8B;AACA,W;AACA,O;AACA,K;;AAEA,wB;AACA,iB;AACA,2C;AACA,wC;AACA,0B;AACA,oB;AACA,O;AACA,O;AACA,I;;AAEA,K;AACA,oB;AACA,c;AACA,4B;AACA,K;AACA,oC;AACA,0E;AACA,+C;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,+B;AACA,e;AACA,iB;AACA,4B;AACA,K;AACA,qD;AACA,0E;AACA,2G;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,+B;AACA,e;AACA,iB;AACA,4B;AACA,K;AACA,qD;AACA,0E;AACA,2G;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,4B;AACA,uB;AACA,K;AACA,kC;AACA,oB;AACA,0E;AACA,mE;AACA,K;AACA,kB;AACA,I;;AAEA,K;AACA,kC;AACA,0B;AACA,uB;AACA,K;AACA,8C;AACA,oB;AACA,0E;AACA,oF;AACA,K;AACA,kB;AACA,I;;AAEA,K;AACA,yB;AACA,uB;AACA,K;AACA,kC;AACA,oB;AACA,0E;AACA,mE;AACA,K;AACA,kB;AACA,I;;AAEA,K;AACA,kC;AACA,0B;AACA,uB;AACA,K;AACA,8C;AACA,oB;AACA,0E;AACA,oF;AACA,K;AACA,kB;AACA,I;;AAEA,K;AACA,6C;AACA,+B;AACA,sB;AACA,K;AACA,wD;AACA,kB;;AAEA,6B;AACA,4C;AACA,8C;AACA,8B;AACA,W;;AAEA,2B;AACA,iE;AACA,6C;;AAEA,kC;AACA,8B;AACA,W;AACA,S;AACA,S;AACA,K;;AAEA,iB;AACA,I;;AAEA,K;AACA,0C;AACA,+B;AACA,sB;AACA,K;AACA,wD;AACA,kB;;AAEA,6B;AACA,4C;AACA,8C;AACA,8B;AACA,W;;AAEA,2B;AACA,iE;AACA,6C;;AAEA,kC;AACA,8B;AACA,W;AACA,S;AACA,S;AACA,K;;AAEA,iB;AACA,I;;AAEA,K;AACA,0B;AACA,yB;AACA,uB;AACA,K;AACA,uC;AACA,uD;AACA,8D;;AAEA,oC;AACA,oB;AACA,yC;AACA,kC;AACA,K;;AAEA,yB;AACA,4C;AACA,K;;AAEA,oB;AACA,iB;AACA,8B;AACA,2B;AACA,4B;AACA,e;AACA,O;AACA,I;;AAEA,K;AACA,0B;AACA,yB;AACA,uB;AACA,K;AACA,uC;AACA,uD;AACA,8D;;AAEA,uD;;;AAGA,yB;AACA,4C;AACA,K;;AAEA,oB;AACA,iB;AACA,8B;AACA,2B;AACA,4B;AACA,e;AACA,O;AACA,I;;AAEA,K;AACA,wB;AACA,oB;AACA,kB;AACA,K;AACA,kD;AACA,c;AACA,0E;AACA,gC;AACA,8B;;AAEA,qD;AACA,qD;;AAEA,2B;AACA,kF;AACA,2B;AACA,wD;AACA,kB;AACA,0D;AACA,W;AACA,S;AACA,kC;AACA,kF;AACA,2B;AACA,wD;AACA,kB;AACA,0D;AACA,W;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,8F;AACA,qB;AACA,2B;AACA,iB;AACA,0B;AACA,uB;AACA,K;AACA,2F;AACA,uB;AACA,sB;;AAEA,wB;AACA,kB;AACA,+E;AACA,qE;AACA,c;AACA,kB;AACA,+E;AACA,qE;AACA,c;AACA,K;;AAEA,iJ;;AAEA,I;;AAEA,K;AACA,kG;AACA,qB;AACA,2B;AACA,iB;AACA,0B;AACA,uB;AACA,K;AACA,+F;AACA,2B;AACA,sB;;AAEA,wB;AACA,kB;AACA,mF;AACA,qE;AACA,c;AACA,kB;AACA,mF;AACA,qE;AACA,c;AACA,K;;AAEA,qJ;;AAEA,I;;AAEA,K;AACA,0E;AACA,qB;AACA,iB;AACA,iB;AACA,0B;AACA,uB;AACA,K;AACA,iF;AACA,kC;AACA,qB;AACA,qB;AACA,+F;AACA,uF;AACA,6B;;AAEA,wB;AACA,kB;AACA,qE;AACA,6C;AACA,gD;AACA,0D;AACA,gC;AACA,kB;AACA,W;AACA,S;AACA,c;AACA,kB;AACA,qE;AACA,6C;AACA,gD;AACA,0D;AACA,gC;AACA,kB;AACA,W;AACA,S;AACA,c;AACA,K;;AAEA,8B;AACA,uC;AACA,oB;AACA,yE;AACA,oB;AACA,6C;AACA,oB;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,sC;AACA,oB;AACA,K;AACA,0C;AACA,oB;;AAEA,uB;AACA,kB;AACA,kC;AACA,gD;AACA,yE;AACA,wB;AACA,W;AACA,S;;AAEA,c;AACA,kB;AACA,kC;AACA,gD;AACA,yE;AACA,wB;AACA,W;AACA,S;AACA,c;AACA,K;;AAEA,iB;AACA,I;;AAEA,K;AACA,gF;AACA,qB;AACA,iB;AACA,iB;AACA,0B;AACA,uB;AACA,K;AACA,kF;AACA,qB;AACA,qB;AACA,mD;AACA,iC;AACA,kD;AACA,0B;AACA,sE;AACA,sD;AACA,0B;AACA,iE;AACA,+D;AACA,sB;AACA,W;AACA,4B;AACA,S;AACA,sB;AACA,O;AACA,+F;AACA,uF;AACA,gB;;AAEA,wB;AACA,kB;AACA,qE;AACA,6C;AACA,yD;AACA,c;AACA,kB;AACA,qE;AACA,6C;AACA,yD;AACA,c;AACA,K;;AAEA,iD;AACA,0B;AACA,4B;AACA,oB;AACA,O;AACA,oF;AACA,4B;AACA,oB;AACA,O;AACA,2C;AACA,4B;AACA,oB;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,8B;AACA,qB;AACA,iB;AACA,iB;AACA,c;AACA,gB;AACA,iB;AACA,K;AACA,sE;AACA,6B;;AAEA,uB;AACA,kB;AACA,0E;AACA,c;AACA,kB;AACA,0E;AACA,c;AACA,K;;AAEA,2C;;AAEA,oB;AACA,qH;;AAEA,2D;AACA,wE;AACA,+D;AACA,iE;AACA,yD;AACA,2D;AACA,wD;;AAEA,yC;;AAEA,8B;AACA,O;AACA,K;AACA,gB;AACA,I;;AAEA,K;AACA,iE;AACA,2B;AACA,uB;AACA,K;AACA,gD;AACA,kC;AACA,mC;;AAEA,iF;AACA,uF;AACA,oB;AACA,O;AACA,K;;AAEA,iF;AACA,mB;AACA,K;;AAEA,iF;AACA,uF;AACA,oB;AACA,O;AACA,K;;AAEA,iB;AACA,I;;AAEA,U;;AAEA,O;AACA,iC;AACA,O;AACA,4B;AACA,oB;AACA,M;AACA,O;AACA,gD;AACA,O;AACA,4B;AACA,oB;AACA,M;AACA,O;AACA,uB;AACA,O;AACA,uB;AACA,O;AACA,uC;AACA,O;AACA,uD;AACA,O;AACA,uC;AACA,O;AACA,uD;;AAEA,+B;AACA,+B;AACA,O;AACA,iB;AACA,+G;AACA,O;AACA,uB;AACA,wD;AACA,0B;AACA,2C;AACA,0D;AACA,S;AACA,O;AACA,M;;AAEA,O;AACA,gD;AACA,O;AACA,0C;AACA,sB;;AAEA,kB;;AAEA,6C;AACA,wB;AACA,wB;AACA,wB;;AAEA,uC;AACA,6B;AACA,uB;AACA,8C;AACA,6B;AACA,uB;AACA,S;;AAEA,6B;AACA,yC;;AAEA,oB;AACA,8B;AACA,2B;AACA,8B;AACA,S;AACA,S;AACA,sB;AACA,M;;AAEA,O;AACA,iC;AACA,O;AACA,8B;AACA,kB;AACA,kB;AACA,gB;AACA,e;AACA,Q;AACA,gB;AACA,gB;AACA,e;AACA,Q;;AAEA,yB;AACA,8B;AACA,8C;AACA,uE;AACA,kG;AACA,wE;AACA,W;AACA,S;AACA,O;;AAEA,6D;AACA,8F;AACA,0E;AACA,gG;AACA,2E;AACA,S;AACA,O;AACA,M;AACA,O;AACA,+C;AACA,O;AACA,+B;AACA,oD;;AAEA,0C;AACA,sD;AACA,M;AACA,2C;AACA,mC;AACA,oE;AACA,2D;AACA,kC;AACA,S;AACA,O;;AAEA,6B;AACA,2D;AACA,2F;AACA,8D;AACA,O;;AAEA,M;AACA,2C;AACA,8E;AACA,qI;;AAEA,sC;AACA,e;AACA,O;;AAEA,mC;AACA,oE;AACA,2D;AACA,kC;AACA,S;AACA,O;;AAEA,6B;AACA,gF;AACA,+D;AACA,S;AACA,6F;AACA,gF;AACA,kE;AACA,S;AACA,O;AACA,M;AACA,O;AACA,mF;AACA,+B;AACA,uB;AACA,O;AACA,gE;AACA,0B;AACA,yB;AACA,2B;AACA,kB;AACA,iC;AACA,qB;AACA,+B;AACA,8B;;AAEA,0B;AACA,0B;AACA,0E;AACA,6C;AACA,4G;AACA,Y;AACA,qD;AACA,wD;AACA,Y;AACA,4B;AACA,2D;AACA,yD;AACA,Y;AACA,wC;AACA,8D;AACA,+C;AACA,6C;;AAEA,kE;;AAEA,+B;AACA,oE;AACA,sB;AACA,sF;AACA,4C;AACA,iB;AACA,e;AACA,a;AACA,gC;AACA,qC;AACA,c;AACA,Y;AACA,qC;AACA,gB;AACA,wB;AACA,0E;AACA,6C;AACA,oD;AACA,Y;AACA,qD;AACA,wD;AACA,Y;AACA,4B;AACA,2D;AACA,yD;AACA,Y;AACA,qC;AACA,8D;AACA,mC;AACA,Y;AACA,gB;AACA,O;;AAEA,4C;AACA,mD;;AAEA,mC;;AAEA,gB;AACA,yB;AACA,0C;AACA,yD;AACA,W;AACA,U;AACA,Q;;AAEA,qD;AACA,uH;;AAEA,2E;;AAEA,kB;AACA,mB;AACA,6B;;AAEA,0C;AACA,oC;AACA,W;;AAEA,2E;;AAEA,+D;;AAEA,uG;;AAEA,gD;AACA,gF;;AAEA,0I;AACA,0D;AACA,a;;AAEA,4H;AACA,8E;AACA,8D;AACA,iF;AACA,sE;AACA,wE;AACA,a;;AAEA,W;;AAEA,oC;AACA,iE;AACA,wK;AACA,kD;AACA,4D;;AAEA,iC;AACA,oF;AACA,kF;AACA,+J;AACA,8D;AACA,qF;AACA,mF;AACA,e;AACA,a;AACA,W;;AAEA,uC;AACA,8F;AACA,0B;AACA,6E;;AAEA,4D;AACA,2E;AACA,a;AACA,W;;AAEA,+B;;AAEA,U;AACA,Q;;;AAGA,yD;;;AAGA,mC;AACA,8G;AACA,6C;AACA,yG;AACA,W;AACA,8D;AACA,S;AACA,O;AACA,M;AACA,O;AACA,8C;AACA,uB;AACA,O;AACA,uC;AACA,oC;AACA,sB;;AAEA,+E;AACA,gC;AACA,iG;AACA,iF;AACA,kE;AACA,W;AACA,S;AACA,O;AACA,oB;AACA,M;AACA,O;AACA,8C;AACA,uB;AACA,O;AACA,uC;AACA,oC;AACA,sB;;AAEA,+E;AACA,gC;AACA,iG;AACA,iF;AACA,kE;AACA,W;AACA,S;AACA,O;AACA,oB;AACA,M;AACA,O;AACA,yD;AACA,mB;AACA,oB;AACA,gB;AACA,O;AACA,yD;AACA,uE;AACA,0E;AACA,2E;AACA,kC;AACA,gD;;AAEA,uB;AACA,c;AACA,iB;AACA,gB;AACA,mB;;AAEA,4D;AACA,2D;;AAEA,8C;;AAEA,8B;AACA,mE;AACA,mD;AACA,iE;;AAEA,8B;AACA,uB;AACA,kB;AACA,sC;AACA,W;;AAEA,iE;;;AAGA,wC;AACA,U;;AAEA,wG;AACA,2B;AACA,iC;AACA,mC;AACA,4E;;AAEA,mF;AACA,kG;;AAEA,oD;AACA,uF;AACA,wD;AACA,e;AACA,oB;AACA,uF;AACA,sD;AACA,e;AACA,a;AACA,W;;AAEA,iD;AACA,gD;;AAEA,gB;AACA,6B;AACA,yC;AACA,S;;;AAGA,6F;AACA,iC;AACA,2C;AACA,wE;AACA,+E;;AAEA,yB;AACA,mC;AACA,+F;AACA,sE;AACA,W;AACA,gB;AACA,mC;AACA,qE;AACA,qG;AACA,yE;AACA,a;AACA,W;AACA,S;;AAEA,0B;;AAEA,yC;AACA,O;AACA,M;AACA,O;AACA,0D;AACA,sB;AACA,0B;AACA,O;AACA,iD;AACA,mC;AACA,2B;AACA,wD;AACA,iH;AACA,8B;;AAEA,8B;AACA,wB;AACA,oD;AACA,8B;AACA,yC;AACA,e;AACA,oB;AACA,sB;AACA,oD;AACA,8B;AACA,yC;AACA,e;AACA,oB;AACA,yB;AACA,oD;AACA,8B;AACA,yC;AACA,e;AACA,oB;AACA,wB;AACA,oD;AACA,8B;AACA,yC;AACA,e;AACA,oB;AACA,W;;AAEA,6B;AACA,S;AACA,wD;AACA,6C;AACA,4C;AACA,6D;AACA,a;AACA,kD;AACA,4C;AACA,2D;AACA,a;AACA,W;;AAEA,8C;AACA,4C;AACA,8D;AACA,a;AACA,oD;AACA,4C;AACA,6D;AACA,a;AACA,W;AACA,U;;AAEA,yB;AACA,qB;AACA,mC;AACA,uD;AACA,gE;AACA,gE;;AAEA,6C;AACA,Y;AACA,gB;AACA,mB;AACA,mC;AACA,uD;AACA,gE;AACA,gE;;AAEA,6C;AACA,Y;AACA,gB;AACA,O;AACA,M;AACA,6C;AACA,qF;AACA,iB;AACA,O;AACA,M;AACA,iC;;AAEA,kD;AACA,wD;AACA,4D;AACA,sB;AACA,S;AACA,Q;;AAEA,sD;AACA,mB;AACA,oB;;AAEA,kF;AACA,mC;;AAEA,uE;AACA,uI;AACA,yB;AACA,wD;AACA,4E;AACA,yB;AACA,W;;AAEA,0C;;AAEA,0E;AACA,sE;;AAEA,0L;AACA,2B;AACA,a;AACA,W;AACA,0C;;AAEA,uE;AACA,uI;AACA,yB;AACA,wD;AACA,4E;AACA,yB;AACA,W;;AAEA,0C;;AAEA,0E;AACA,sE;;AAEA,0L;AACA,2B;AACA,a;AACA,W;AACA,S;AACA,O;;AAEA,kB;AACA,M;AACA,gD;AACA,oE;AACA,M;AACA,mD;AACA,sE;AACA,M;AACA,mC;AACA,0B;AACA,4C;AACA,gI;AACA,gB;AACA,wB;AACA,S;AACA,Q;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,sB;AACA,G;AACA,wB;AACA,sB;AACA,wD;;;AAGA,wB;AACA,2B;;AAEA,mD;;AAEA,sG;AACA,sC;AACA,K;AACA,sG;AACA,sC;AACA,K;AACA,+D;AACA,6C;AACA,K;;AAEA,kE;AACA,4B;AACA,a;AACA,K;;AAEA,4E;AACA,6F;AACA,wH;AACA,kH;AACA,gG;AACA,gG;AACA,wG;AACA,iH;AACA,6G;AACA,4F;AACA,G;AACA,E;;AAEA,G;AACA,iD;AACA,G;AACA,+B;AACA,sC;AACA,wD;AACA,iF;AACA,oE;AACA,iC;AACA,a;AACA,K;AACA,0F;AACA,kC;AACA,e;AACA,O;AACA,2D;AACA,0D;AACA,wE;AACA,gB;AACA,iE;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,2C;;AAEA,2D;;AAEA,4D;AACA,+B;AACA,mE;AACA,wC;AACA,mC;AACA,G;AACA,G;;AAEA,yC;;AAEA,0B;AACA,K;AACA,sE;AACA,4D;AACA,iB;AACA,K;AACA,mC;AACA,sC;AACA,yB;AACA,G;;AAEA,K;AACA,4B;AACA,K;AACA,qE;AACA,sB;AACA,4B;AACA,6B;AACA,S;AACA,K;AACA,I;;AAEA,K;AACA,gB;AACA,iD;AACA,K;AACA,qD;AACA,8C;AACA,sE;AACA,I;;AAEA,K;AACA,0C;AACA,K;AACA,+E;AACA,mD;AACA,a;AACA,K;;AAEA,iC;AACA,O;AACA,oB;AACA,oB;AACA,Q;AACA,O;AACA,qB;AACA,sB;AACA,+B;AACA,wC;AACA,S;AACA,Q;AACA,wC;AACA,M;AACA,I;;AAEA,K;AACA,6D;AACA,oD;AACA,K;AACA,6E;AACA,sB;AACA,iC;;AAEA,mF;AACA,a;AACA,K;;AAEA,oC;AACA,yF;AACA,mC;AACA,iF;;AAEA,yC;AACA,gE;AACA,8C;AACA,yD;AACA,kG;AACA,W;;AAEA,iC;AACA,c;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,iC;AACA,K;AACA,2D;AACA,sB;;AAEA,6H;AACA,4B;;AAEA,sE;;AAEA,gD;AACA,iF;AACA,uB;AACA,4D;AACA,S;AACA,gG;AACA,oE;AACA,Q;;AAEA,uD;AACA,gG;AACA,uB;AACA,2E;AACA,S;AACA,gG;AACA,Q;;AAEA,2E;AACA,4B;AACA,S;AACA,0E;AACA,4B;AACA,S;;AAEA,2E;AACA,mC;AACA,S;AACA,0E;AACA,mC;AACA,S;;;AAGA,K;AACA,I;;AAEA,K;AACA,sB;AACA,+E;AACA,K;AACA,qD;AACA,mD;AACA,a;AACA,4E;AACA,4E;AACA,K;;AAEA,+C;AACA,4J;;AAEA,mB;AACA,K;;AAEA,S;AACA,yE;AACA,wB;AACA,yF;AACA,8I;;AAEA,qB;AACA,O;AACA,K;;AAEA,gC;AACA,uC;AACA,I;;AAEA,+C;;AAEA,qD;AACA,yC;AACA,K;;AAEA,wD;AACA,yF;AACA,2D;;AAEA,iB;;AAEA,0B;AACA,e;;AAEA,+C;AACA,6B;AACA,sB;;AAEA,4D;;AAEA,2B;AACA,G;;AAEA,2J;AACA,wD;AACA,gE;AACA,8D;AACA,2D;;AAEA,qB;AACA,kB;AACA,e;AACA,M;;AAEA,kC;AACA,mB;AACA,mC;AACA,uB;AACA,uB;AACA,6C;AACA,2B;AACA,gG;AACA,sF;AACA,gB;AACA,oB;AACA,2B;AACA,gG;AACA,mF;AACA,gB;AACA,a;AACA,kB;AACA,uB;AACA,iD;AACA,2B;AACA,0F;AACA,mF;AACA,gB;AACA,a;AACA,kB;AACA,yB;AACA,oB;AACA,S;AACA,c;AACA,mB;AACA,mC;AACA,uB;AACA,6C;AACA,2B;AACA,oC;AACA,qC;AACA,gB;AACA,oB;AACA,4C;AACA,a;AACA,kB;AACA,uB;AACA,6C;AACA,2B;AACA,oC;AACA,sC;AACA,gB;AACA,oB;AACA,4C;AACA,a;AACA,kB;AACA,uB;AACA,6C;AACA,2B;AACA,oC;AACA,kC;AACA,gB;AACA,oB;AACA,4C;AACA,a;AACA,kB;AACA,uB;AACA,6C;AACA,2B;AACA,oC;AACA,mC;AACA,gB;AACA,oB;AACA,4C;AACA,a;AACA,kB;AACA,S;AACA,c;AACA,mB;AACA,mC;AACA,uB;AACA,iD;AACA,2B;AACA,sF;AACA,sF;AACA,gB;AACA,oB;AACA,2B;AACA,sF;AACA,uF;AACA,gB;AACA,a;AACA,kB;AACA,yB;AACA,Y;AACA,oB;AACA,uB;AACA,6C;AACA,2B;AACA,gG;AACA,uF;AACA,gB;AACA,oB;AACA,2B;AACA,sF;AACA,mF;AACA,gB;AACA,a;AACA,kB;AACA,uB;AACA,iD;AACA,2B;AACA,uF;AACA,mF;AACA,gB;AACA,oD;AACA,2B;AACA,wC;AACA,iC;AACA,gB;AACA,a;AACA,kB;AACA,S;AACA,c;AACA,mB;AACA,mC;AACA,uB;AACA,uB;AACA,uB;AACA,6C;AACA,2C;AACA,a;AACA,kB;AACA,uB;AACA,6C;AACA,2C;AACA,oB;AACA,2B;AACA,oC;AACA,kC;AACA,gB;AACA,a;AACA,kB;AACA,S;AACA,c;AACA,K;;AAEA,qB;AACA,I;;AAEA,oE;AACA,oB;AACA,8C;;AAEA,qC;AACA,0B;AACA,oB;AACA,O;;AAEA,sD;;AAEA,gC;AACA,qB;AACA,sC;AACA,gD;AACA,sC;AACA,8C;AACA,O;AACA,M;;AAEA,iG;AACA,qF;AACA,qC;AACA,6D;AACA,gC;AACA,0C;AACA,4C;AACA,iD;AACA,U;AACA,+B;;AAEA,qB;AACA,iG;AACA,yC;AACA,6D;AACA,gC;AACA,0C;AACA,4C;AACA,iD;AACA,U;AACA,+B;;AAEA,qB;AACA,O;AACA,O;;AAEA,+F;AACA,qF;AACA,gD;AACA,sC;AACA,+B;;AAEA,qB;AACA,iG;AACA,oD;AACA,sC;AACA,+B;;AAEA,qB;AACA,O;AACA,O;;AAEA,gG;AACA,2D;AACA,8D;;AAEA,oC;AACA,kD;AACA,gD;AACA,8C;AACA,U;;AAEA,wB;AACA,iB;AACA,S;;AAEA,uE;AACA,gE;;AAEA,sC;AACA,iC;AACA,W;;AAEA,8D;AACA,mD;AACA,qD;AACA,4D;;AAEA,oD;AACA,8D;AACA,W;;AAEA,wJ;;AAEA,4C;AACA,wE;AACA,W;AACA,kE;;AAEA,S;;AAEA,+B;AACA,O;AACA,O;;AAEA,I;;AAEA,8D;AACA,mC;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,0B;AACA,wB;;AAEA,2F;AACA,I;;AAEA,4C;;AAEA,iB;;AAEA,uC;;AAEA,mC;;AAEA,mD;AACA,6B;AACA,sB;;AAEA,uB;AACA,kD;AACA,oD;AACA,+C;AACA,K;;AAEA,mB;AACA,kF;AACA,oF;AACA,+E;AACA,K;AACA,I;;AAEA,kD;AACA,kB;;AAEA,4D;AACA,yC;;AAEA,6E;AACA,gE;AACA,O;AACA,O;;AAEA,8D;AACA,0C;;AAEA,6E;AACA,mE;AACA,O;;AAEA,6E;AACA,gE;AACA,O;;AAEA,8B;AACA,+E;AACA,qE;AACA,S;AACA,a;;AAEA,iF;AACA,qC;AACA,gD;AACA,O;;AAEA,O;;AAEA,I;;AAEA,qB;AACA,K;;AAEA,2C;;AAEA,gD;AACA,yD;AACA,G;;AAEA,G;AACA,uH;AACA,2F;AACA,G;AACA,gC;;AAEA,E;AACA,wB;AACA,wF;AACA,0C;AACA,yC;AACA,6D;AACA,G;;AAEA,iD;AACA,2C;AACA,2C;AACA,qD;AACA,6D;AACA,E;;AAEA,+D;AACA,4C;AACA,8D;AACA,oC;AACA,sB;AACA,uB;AACA,kC;;AAEA,+C;AACA,2D;AACA,4B;;AAEA,6D;;AAEA,0B;AACA,+B;AACA,uB;AACA,iB;AACA,K;AACA,E;;AAEA,sE;AACA,4B;AACA,0B;AACA,sE;AACA,gB;AACA,K;AACA,gI;AACA,gB;AACA,K;AACA,uB;AACA,G;AACA,gB;AACA,E;;AAEA,4D;AACA,0C;AACA,E;;AAEA,oD;AACA,2D;AACA,uB;AACA,E;;AAEA,gD;AACA,Y;AACA,mD;AACA,6B;AACA,6C;AACA,oD;AACA,iD;AACA,uD;AACA,M;AACA,kB;AACA,0B;;AAEA,uE;AACA,sF;AACA,+E;AACA,8F;;AAEA,oC;AACA,mD;AACA,iE;AACA,2D;AACA,wE;AACA,M;;AAEA,wB;AACA,6B;AACA,oC;AACA,mC;AACA,2D;AACA,M;;AAEA,oC;AACA,iF;AACA,6E;AACA,K;;AAEA,uB;AACA,6B;AACA,6B;AACA,4B;AACA,qD;AACA,8B;AACA,mC;AACA,M;;AAEA,mC;AACA,yE;AACA,qE;AACA,K;;AAEA,yD;AACA,6D;AACA,gE;AACA,oE;AACA,I;;AAEA,gB;AACA,W;AACA,G;;AAEA,yD;;AAEA,yB;AACA,2B;AACA,2B;;AAEA,4C;AACA,0B;AACA,8B;AACA,gB;AACA,iB;;AAEA,4D;;AAEA,+B;AACA,iC;;AAEA,4C;AACA,sF;AACA,gE;AACA,iC;AACA,K;;AAEA,sB;AACA,+I;AACA,oJ;AACA,mJ;;AAEA,+B;AACA,G;;AAEA,qC;AACA,sC;AACA,wC;AACA,uC;;AAEA,iC;AACA,mC;AACA,uC;AACA,qC;;AAEA,wC;AACA,qC;AACA,uC;AACA,iC;AACA,kC;AACA,6C;;AAEA,kC;AACA,6C;AACA,G;;AAEA,mB;AACA,wC;AACA,mE;AACA,2D;AACA,uE;;AAEA,G;AACA,oG;;AAEA,mB;;;;AAIA,yE;AACA,gB;AACA,K;;;AAGA,uE;AACA,gB;AACA,K;;AAEA,oE;;AAEA,2F;AACA,uE;AACA,e;AACA,O;AACA,6B;AACA,uC;;AAEA,gD;;AAEA,kC;;AAEA,wC;AACA,qD;AACA,sB;AACA,S;AACA,oE;AACA,sB;AACA,S;AACA,sD;AACA,sB;AACA,S;AACA,oE;AACA,sB;AACA,S;AACA,Q;;AAEA,sC;AACA,+B;AACA,gF;AACA,uC;AACA,S;AACA,Q;AACA,0E;AACA,O;AACA,G;AACA,C;;AAEA,G;AACA,uC;AACA,yB;AACA,G;AACA,yD;AACA,iH;AACA,sB;AACA,W;AACA,G;;AAEA,+B;;AAEA,a;AACA,gB;AACA,W;AACA,c;AACA,O;AACA,U;AACA,Q;;AAEA,iC;AACA,iD;;AAEA,gE;AACA,wE;AACA,oB;AACA,O;AACA,K;;AAEA,iB;AACA,I;;AAEA,oF;AACA,8E;AACA,uF;;AAEA,qF;AACA,uF;;AAEA,mG;AACA,qG;;AAEA,oF;AACA,qF;;AAEA,4G;AACA,6G;;AAEA,wH;AACA,6D;AACA,oE;AACA,mC;AACA,mE;AACA,0E;AACA,c;AACA,kE;AACA,yE;AACA,O;AACA,Y;AACA,4D;AACA,gE;AACA,mE;AACA,uE;AACA,K;;AAEA,iJ;AACA,2D;AACA,kE;AACA,Y;AACA,uD;AACA,8D;AACA,K;;AAEA,I;;AAEA,iJ;AACA,+C;AACA,G;AACA,Q;AACA,mD;AACA,G;;AAEA,8B;AACA,uD;AACA,6C;AACA,kB;AACA,Y;AACA,K;AACA,G;;AAEA,mC;AACA,uD;AACA,6C;AACA,gB;AACA,Y;AACA,K;AACA,G;;AAEA,oD;;AAEA,8B;AACA,0D;AACA,6C;AACA,qB;AACA,Y;AACA,K;AACA,G;;AAEA,mC;AACA,0D;AACA,6C;AACA,mB;AACA,Y;AACA,K;AACA,G;;AAEA,oD;AACA,gE;AACA,sF;AACA,sG;AACA,iD;AACA,uE;AACA,sE;;AAEA,4B;AACA,wE;AACA,8B;AACA,wE;;AAEA,2C;AACA,8C;;AAEA,0D;AACA,oD;AACA,e;AACA,2C;AACA,K;AACA,qD;AACA,gB;AACA,wC;AACA,K;AACA,G;AACA,Q;AACA,qB;AACA,W;AACA,G;;AAEA,iC;AACA,mC;AACA,qC;AACA,kC;;AAEA,kC;AACA,oC;AACA,wC;AACA,mC;;AAEA,yD;;AAEA,qD;AACA,sC;AACA,wC;AACA,qC;;AAEA,mC;AACA,qD;AACA,6C;AACA,oC;;AAEA,uH;AACA,sC;AACA,G;AACA,Q;AACA,mD;AACA,oD;AACA,uC;AACA,G;;AAEA,kC;AACA,+E;AACA,G;AACA,E;;AAEA,G;AACA,c;AACA,G;AACA,qD;AACA,iC;AACA,kC;AACA,oC;AACA,mC;AACA,oC;;AAEA,kC;AACA,0D;AACA,8D;AACA,G;;;AAGA,E;;AAEA,6D;AACA,sC;AACA,qB;AACA,G;AACA,mB;AACA,E;;AAEA,G;AACA,mI;AACA,6H;AACA,G;;AAEA,0C;AACA,iE;AACA,mB;AACA,mB;AACA,G;AACA,Q;AACA,oB;AACA,oB;AACA,G;AACA,C;;AAEA,G;AACA,8G;AACA,kB;AACA,qB;AACA,G;AACA,+D;AACA,0C;AACA,qC;AACA,iB;AACA,G;;AAEA,8C;AACA,wG;AACA,iB;AACA,G;;AAEA,c;AACA,E;;AAEA,G;AACA,mG;AACA,4C;AACA,qB;AACA,G;AACA,iE;AACA,4B;AACA,gB;AACA,G;AACA,sE;AACA,E;;AAEA,yE;AACA,sE;AACA,E;;AAEA,yE;AACA,sE;AACA,E;;AAEA,yE;AACA,sE;AACA,E;;AAEA,yE;AACA,sE;AACA,E;;AAEA,8D;;AAEA,G;AACA,iG;AACA,G;;AAEA,oD;AACA,6J;AACA,qJ;AACA,e;AACA,C;;AAEA,8D;AACA,oE;AACA,E;;AAEA,uD;AACA,0E;AACA,E;;AAEA,G;AACA,oD;AACA,oB;AACA,G;AACA,wD;AACA,yF;AACA,E;;AAEA,G;AACA,sD;AACA,oB;AACA,G;AACA,uD;AACA,yF;AACA,E;;AAEA,G;AACA,uG;AACA,4C;AACA,qB;AACA,G;AACA,iE;AACA,wC;AACA,gD;;AAEA,2B;AACA,uB;AACA,G;;AAEA,2B;AACA,uB;AACA,G;;AAEA,oJ;AACA,E;;AAEA,uE;AACA,4G;AACA,E;;AAEA,iE;AACA,qG;AACA,mG;AACA,mG;AACA,oG;AACA,E;;AAEA,G;AACA,wD;AACA,8G;AACA,qB;AACA,qB;AACA,G;AACA,kE;AACA,sH;AACA,E;;AAEA,wE;AACA,wH;AACA,E;;AAEA,wE;AACA,wH;AACA,E;;AAEA,G;AACA,2G;AACA,4C;AACA,qB;AACA,G;AACA,+D;AACA,wC;AACA,gD;AACA,6I;AACA,wH;AACA,8H;AACA,gB;AACA,G;AACA,e;AACA,E;;AAEA,0E;AACA,6E;AACA,iB;AACA,G;;AAEA,uC;AACA,+C;AACA,yC;AACA,8C;;AAEA,2D;AACA,mE;;AAEA,iE;AACA,iE;AACA,4E;AACA,4E;;AAEA,uE;AACA,4E;AACA,4G;AACA,kG;;AAEA,+B;AACA,wC;AACA,sC;AACA,iC;AACA,K;AACA,wC;AACA,sC;AACA,iC;AACA,K;AACA,G;;AAEA,wB;AACA,oB;;AAEA,c;AACA,E;;AAEA,2D;AACA,yE;AACA,mB;AACA,yE;AACA,mB;AACA,yE;AACA,mB;AACA,yE;AACA,mB;AACA,G;AACA,E;;AAEA,oE;AACA,sB;AACA,kB;AACA,0C;AACA,4C;AACA,Y;AACA,kB;AACA,2C;AACA,2C;AACA,Y;AACA,kB;AACA,8C;AACA,wC;AACA,Y;AACA,kB;AACA,6C;AACA,yC;AACA,Y;AACA,G;AACA,E;;AAEA,+D;AACA,+G;AACA,E;;AAEA,mE;AACA,+G;AACA,E;;AAEA,gE;AACA,+G;AACA,E;;AAEA,kE;AACA,+G;AACA,E;;AAEA,4E;AACA,sB;AACA,yC;AACA,oH;AACA,oH;AACA,sH;AACA,wH;AACA,oB;AACA,O;AACA,K;AACA,G;AACA,0L;AACA,E;;AAEA,qF;AACA,+D;;AAEA,sB;AACA,yC;AACA,yJ;AACA,uJ;AACA,uJ;AACA,qJ;AACA,K;AACA,G;;AAEA,oD;AACA,mC;AACA,uD;AACA,uC;AACA,wD;AACA,sC;AACA,0D;AACA,qC;AACA,G;AACA,E;;AAEA,wE;AACA,mC;AACA,c;AACA,G;;AAEA,qB;AACA,gD;AACA,mD;AACA,iD;AACA,iD;AACA,K;AACA,sB;AACA,kD;AACA,qD;AACA,mD;AACA,mD;AACA,K;AACA,kB;;AAEA,4C;AACA,uB;AACA,G;AACA,gD;AACA,yB;AACA,G;AACA,kD;AACA,0B;AACA,G;AACA,8C;AACA,wB;AACA,G;;AAEA,gB;AACA,E;;AAEA,uD;AACA,wC;AACA,gD;AACA,e;AACA,wD;AACA,0D;AACA,uG;AACA,kD;AACA,O;AACA,K;AACA,G;AACA,a;AACA,E;;AAEA,qD;AACA,wC;AACA,gD;AACA,e;AACA,wD;AACA,0D;AACA,mD;AACA,0B;AACA,O;AACA,gE;AACA,8B;AACA,O;AACA,Y;AACA,kD;AACA,O;AACA,K;AACA,G;AACA,a;AACA,E;;AAEA,G;AACA,mI;AACA,6B;AACA,G;AACA,6D;AACA,wC;AACA,gD;AACA,wD;AACA,0D;AACA,0C;AACA,qC;AACA,e;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,4D;;AAEA,G;AACA,0B;AACA,e;AACA,G;AACA,yD;AACA,uB;AACA,qB;AACA,yB;AACA,C;;AAEA,4D;AACA,yB;AACA,E;;AAEA,8D;AACA,yB;AACA,E;;AAEA,mE;AACA,2B;AACA,E;;AAEA,mE;AACA,6B;AACA,E;;AAEA,8D;AACA,0B;AACA,E;;AAEA,gE;AACA,0B;AACA,E;;AAEA,uF;AACA,oD;AACA,E;;AAEA,uF;AACA,sD;AACA,E;;AAEA,G;AACA,4B;AACA,yB;AACA,qB;AACA,oC;AACA,e;AACA,G;AACA,sF;AACA,U;AACA,Y;;AAEA,2B;AACA,yC;AACA,wB;AACA,sB;AACA,wB;AACA,qB;AACA,4B;AACA,yB;AACA,2B;;AAEA,0E;AACA,gB;AACA,0B;AACA,0B;AACA,qC;AACA,K;AACA,sD;AACA,8B;AACA,K;AACA,8B;AACA,8B;AACA,qB;;AAEA,Q;AACA,G;;AAEA,8C;AACA,yD;AACA,mG;AACA,2D;AACA,C;;AAEA,oE;AACA,oG;AACA,E;;AAEA,gE;AACA,gE;AACA,E;;AAEA,2D;AACA,sC;AACA,6C;AACA,Y;;AAEA,yD;;AAEA,uD;;AAEA,gC;AACA,iC;AACA,oD;AACA,kB;;AAEA,4H;AACA,wD;AACA,0D;AACA,0D;AACA,Y;AACA,O;AACA,iE;AACA,6B;AACA,K;AACA,G;AACA,sC;AACA,uJ;AACA,iE;AACA,6B;AACA,K;AACA,G;AACA,E;;AAEA,gE;AACA,+B;AACA,E;;AAEA,oE;;AAEA,4D;AACA,6D;AACA,yF;AACA,iD;AACA,oD;AACA,4C;;AAEA,mF;AACA,kE;AACA,uD;;;AAGA,gC;AACA,E;;AAEA,gC;AACA,2B;;AAEA,0F;;AAEA,2B;AACA,6B;AACA,4C;AACA,8C;AACA,sD;AACA,8D;AACA,gD;AACA,sD;AACA,8C;AACA,kD;AACA,G;AACA,Q;AACA,8D;AACA,8D;AACA,gD;AACA,oD;AACA,8C;AACA,oD;;AAEA,wD;AACA,G;;AAEA,yB;AACA,mG;AACA,+F;AACA,qF;AACA,K;AACA,mD;AACA,2D;AACA,oE;AACA,U;AACA,K;AACA,G;;;;AAIA,qB;AACA,+B;AACA,C;;AAEA,G;AACA,gC;AACA,+L;AACA,yB;AACA,G;AACA,kD;AACA,+B;AACA,qE;AACA,gF;AACA,W;AACA,G;;AAEA,8B;;AAEA,c;AACA,E;;AAEA,G;AACA,kG;AACA,gE;AACA,wC;AACA,2B;AACA,oB;AACA,G;AACA,4D;AACA,gB;AACA,wC;AACA,U;AACA,8D;AACA,sE;;AAEA,6D;AACA,oE;AACA,uC;AACA,sE;AACA,2C;AACA,wE;AACA,Y;AACA,0C;AACA,K;AACA,G;AACA,E;;AAEA,2D;AACA,iD;AACA,E;;AAEA,G;AACA,qE;AACA,a;AACA,yB;AACA,G;AACA,uD;AACA,2C;AACA,wC;AACA,c;AACA,E;;AAEA,G;AACA,wE;AACA,a;AACA,yB;AACA,G;AACA,4D;AACA,gD;AACA,0C;AACA,c;AACA,E;;AAEA,G;AACA,uD;AACA,wC;AACA,yB;AACA,G;;AAEA,0D;AACA,uC;AACA,c;AACA,E;;AAEA,iD;AACA,U;AACA,sC;AACA,yC;AACA,qC;AACA,uC;AACA,I;AACA,E;;AAEA,mF;AACA,4L;AACA,E;;AAEA,mD;AACA,kC;AACA,E;;AAEA,6C;AACA,8B;AACA,yC;AACA,E;;AAEA,G;AACA,qI;AACA,kI;AACA,kB;AACA,e;AACA,G;AACA,4C;AACA,2B;AACA,c;AACA,uC;AACA,gD;AACA,iE;AACA,0B;;AAEA,oF;;AAEA,oB;AACA,gB;AACA,gB;AACA,8D;;AAEA,yD;;AAEA,8E;AACA,mD;AACA,gC;AACA,K;AACA,iI;AACA,2C;AACA,K;AACA,0B;AACA,0B;AACA,iE;AACA,qE;AACA,mC;AACA,+C;AACA,sE;AACA,oE;AACA,a;AACA,O;AACA,C;;AAEA,6D;;AAEA,yD;AACA,kD;AACA,iC;AACA,E;;AAEA,qC;AACA,kB;;AAEA,yD;;AAEA,yB;AACA,2B;;AAEA,oC;AACA,sC;;AAEA,sC;AACA,6C;AACA,4D;AACA,6E;AACA,K;AACA,uB;AACA,wD;AACA,gG;AACA,O;AACA,K;;AAEA,yD;AACA,oB;AACA,oC;AACA,8C;AACA,0D;AACA,mC;AACA,iB;AACA,O;AACA,K;AACA,I;;AAEA,sC;AACA,qC;AACA,I;;AAEA,uB;;AAEA,O;AACA,iH;AACA,mB;AACA,O;AACA,I;AACA,0C;AACA,wB;AACA,qB;;AAEA,mE;AACA,iD;AACA,2E;;AAEA,qE;AACA,O;AACA,K;;AAEA,sB;AACA,4C;AACA,2B;AACA,S;AACA,K;;AAEA,iB;AACA,M;;AAEA,uC;AACA,yB;;AAEA,kE;;AAEA,6D;;AAEA,2B;AACA,iD;AACA,wC;AACA,yC;AACA,M;AACA,mE;AACA,gE;AACA,kE;AACA,kE;AACA,qB;AACA,a;AACA,M;AACA,6F;AACA,S;AACA,a;;AAEA,wG;AACA,sD;AACA,gD;AACA,6C;;AAEA,4E;;AAEA,iB;AACA,gB;AACA,2C;;AAEA,6B;AACA,S;AACA,a;;AAEA,+F;AACA,I;;AAEA,oB;AACA,sC;AACA,sD;AACA,8C;AACA,2E;AACA,gF;AACA,2B;AACA,mH;AACA,O;AACA,K;AACA,I;;AAEA,uB;AACA,sC;AACA,oD;AACA,2C;AACA,wE;AACA,4E;AACA,qB;AACA,8B;AACA,8F;AACA,I;AACA,I;AACA,I;AACA,O;;AAEA,oC;AACA,yD;AACA,+C;;AAEA,2E;AACA,gE;AACA,uG;AACA,S;AACA,c;AACA,iG;AACA,S;;AAEA,iC;AACA,iC;AACA,O;AACA,+C;AACA,oC;AACA,8C;AACA,0D;AACA,mC;AACA,gB;AACA,O;AACA,K;AACA,I;;;AAGA,qC;AACA,mC;AACA,wC;;AAEA,2B;;AAEA,qB;;AAEA,2F;AACA,I;;AAEA,wF;;AAEA,uF;;AAEA,oF;;;AAGA,gK;AACA,qG;;AAEA,sH;AACA,wC;AACA,oE;AACA,+C;AACA,O;AACA,O;AACA,oH;AACA,yC;AACA,oE;AACA,6C;AACA,O;AACA,O;;AAEA,0C;AACA,2C;AACA,K;AACA,kH;AACA,6D;;AAEA,oD;AACA,wD;AACA,O;AACA,qD;;AAEA,yE;AACA,yC;AACA,0D;;AAEA,4D;AACA,S;AACA,a;AACA,O;AACA,G;;AAEA,+D;AACA,yB;AACA,K;;AAEA,8B;AACA,0C;AACA,0C;;AAEA,yB;AACA,I;AACA,C;;AAEA,yD;AACA,gB;AACA,0C;AACA,+D;;AAEA,oD;AACA,sD;AACA,iB;AACA,yG;AACA,qH;AACA,yD;AACA,sG;AACA,kD;AACA,wG;AACA,2D;AACA,K;AACA,G;;AAEA,c;AACA,E;;;;AAIA,uC;AACA,0B;AACA,wB;AACA,+D;AACA,iE;AACA,kB;AACA,K;AACA,G;AACA,e;AACA,C;;AAEA,G;AACA,oF;AACA,gE;AACA,G;AACA,oC;AACA,iB;AACA,oD;AACA,mB;AACA,oB;AACA,G;;AAEA,mC;AACA,C;AACA,G;AACA,mG;AACA,G;AACA,wC;AACA,yC;AACA,yC;AACA,sC;AACA,oC;AACA,qC;AACA,kE;AACA,oD;AACA,M;AACA,K;;AAEA,8C;AACA,uC;AACA,+C;AACA,4C;AACA,0C;AACA,2C;AACA,gB;AACA,K;;AAEA,gC;AACA,oB;AACA,sD;AACA,+B;AACA,gB;AACA,a;;AAEA,oB;AACA,yD;AACA,iD;AACA,6D;AACA,O;AACA,M;;AAEA,6C;AACA,gB;AACA,sB;AACA,K;AACA,O;AACA,C;;AAEA,G;AACA,+F;AACA,G;AACA,6B;AACA,+B;AACA,uC;AACA,uC;AACA,I;AACA,C;AACA,G;AACA,uB;AACA,e;AACA,G;AACA,uD;AACA,uB;AACA,qB;AACA,yB;AACA,C;;AAEA,yD;AACA,yB;AACA,E;;AAEA,2D;AACA,yB;AACA,E;;AAEA,gE;AACA,2B;AACA,E;;AAEA,gE;AACA,6B;AACA,E;;AAEA,2D;AACA,0B;AACA,E;;AAEA,8E;AACA,oD;AACA,E;;AAEA,8E;AACA,sD;AACA,E;;AAEA,sC;AACA,2B;AACA,C;;AAEA,G;AACA,wD;AACA,wC;AACA,G;AACA,gE;AACA,6B;AACA,W;AACA,G;;AAEA,uD;AACA,8D;;AAEA,qD;AACA,6D;AACA,G;;AAEA,wD;AACA,gE;AACA,G;;AAEA,iE;AACA,qE;AACA,kI;AACA,+D;AACA,K;;AAEA,qE;AACA,uE;AACA,yI;AACA,iE;AACA,K;;AAEA,K;AACA,E;;AAEA,qD;AACA,2B;AACA,uB;AACA,c;AACA,wC;AACA,C;;AAEA,sE;;AAEA,6E;AACA,iD;AACA,8B;AACA,G;AACA,kD;;AAEA,sC;AACA,mE;AACA,iC;AACA,mC;AACA,iB;AACA,iB;AACA,uC;AACA,qC;;AAEA,qD;AACA,+B;AACA,Y;AACA,sB;AACA,K;;AAEA,sD;AACA,6B;AACA,Y;AACA,qB;AACA,K;AACA,G;AACA,yC;AACA,iF;AACA,8E;AACA,G;;AAEA,iE;;AAEA,sF;AACA,wF;AACA,E;;AAEA,yD;AACA,2B;AACA,2B;AACA,kB;AACA,c;AACA,sC;AACA,C;;AAEA,0E;;AAEA,4D;AACA,iF;AACA,iD;AACA,8B;AACA,G;AACA,kD;;AAEA,sC;;AAEA,mE;AACA,mC;AACA,iB;AACA,iB;AACA,qC;;AAEA,qD;AACA,+B;AACA,Y;AACA,sB;AACA,K;;AAEA,qD;AACA,G;AACA,yC;AACA,gD;AACA,qD;AACA,G;;AAEA,iE;;AAEA,oF;AACA,oG;AACA,E;;AAEA,8E;AACA,oB;AACA,4D;AACA,E;;AAEA,gF;AACA,4D;AACA,E;;AAEA,mF;AACA,sC;AACA,gE;AACA,U;AACA,wC;AACA,G;AACA,E;;AAEA,uE;AACA,mD;AACA,E;;AAEA,uF;AACA,c;AACA,wB;AACA,8G;AACA,W;AACA,G;AACA,a;AACA,E;;AAEA,oD;AACA,yE;AACA,uD;AACA,gE;;AAEA,kG;;AAEA,0F;AACA,kG;AACA,G;AACA,yB;AACA,gC;AACA,U;AACA,uE;AACA,G;AACA,8B;AACA,E;;AAEA,G;AACA,oE;AACA,4B;AACA,yG;AACA,G;AACA,gG;AACA,yC;;AAEA,uB;AACA,gD;AACA,uD;AACA,G;AACA,Q;AACA,wE;AACA,2D;AACA,G;;AAEA,+B;AACA,E;;AAEA,mF;AACA,sC;AACA,mD;AACA,G;AACA,Q;AACA,a;AACA,G;AACA,E;;AAEA,uD;AACA,2B;AACA,yB;AACA,c;AACA,qC;AACA,C;;AAEA,wE;;AAEA,4D;AACA,+E;AACA,iD;AACA,8B;AACA,G;AACA,kD;;AAEA,sC;AACA,mE;AACA,iC;AACA,iB;AACA,iB;AACA,uC;;AAEA,uD;;AAEA,sD;AACA,6B;AACA,Y;AACA,qB;AACA,K;AACA,G;AACA,yC;AACA,+C;AACA,uD;AACA,G;;AAEA,iE;;AAEA,uE;AACA,iF;AACA,G;AACA,Q;AACA,oF;AACA,G;;AAEA,sG;AACA,E;;AAEA,8E;AACA,2D;AACA,E;;AAEA,iF;AACA,qC;AACA,iE;AACA,U;AACA,uC;AACA,G;AACA,E;;AAEA,qE;AACA,iD;AACA,E;;AAEA,qF;AACA,c;AACA,yB;AACA,kL;AACA,W;AACA,G;AACA,a;AACA,E;;AAEA,4E;AACA,oB;AACA,4D;AACA,E;;AAEA,oD;AACA,uE;AACA,oD;AACA,oE;AACA,yP;AACA,wF;AACA,8F;AACA,G;AACA,yB;AACA,gE;AACA,G;AACA,Q;AACA,mE;AACA,G;AACA,+B;AACA,E;;AAEA,G;AACA,8B;AACA,4B;AACA,qG;AACA,G;AACA,0F;AACA,yC;AACA,mB;AACA,gD;AACA,yD;AACA,G;AACA,Q;AACA,gE;AACA,uD;AACA,G;;AAEA,+B;AACA,E;;AAEA,iF;AACA,sC;AACA,kD;AACA,G;AACA,Q;AACA,a;AACA,G;AACA,E;;AAEA,0C;AACA,2B;AACA,0E;AACA,2E;AACA,mE;AACA,uE;AACA,+D;AACA,qC;AACA,uD;AACA,G;AACA,2B;AACA,C;;AAEA,iE;AACA,kB;;AAEA,2C;AACA,8B;AACA,a;AACA,K;;AAEA,mD;AACA,2E;AACA,qB;AACA,a;AACA,K;;AAEA,6B;AACA,6B;AACA,+B;AACA,I;;AAEA,8D;;AAEA,wF;AACA,sE;AACA,4F;AACA,G;;AAEA,2F;AACA,oE;AACA,G;AACA,E;;AAEA,uD;AACA,8D;;AAEA,sB;AACA,4B;AACA,4F;AACA,G;AACA,wB;AACA,8B;AACA,8F;AACA,G;AACA,qE;AACA,uC;AACA,qC;AACA,E;;AAEA,+D;AACA,uD;AACA,mD;AACA,+C;AACA,6C;AACA,E;;AAEA,0D;AACA,kD;AACA,8C;AACA,E;;AAEA,oD;AACA,2B;AACA,qC;AACA,4B;AACA,C;;AAEA,G;AACA,sI;AACA,gC;AACA,+B;AACA,G;AACA,gE;AACA,4C;AACA,+C;AACA,G;AACA,2B;AACA,uF;AACA,E;;AAEA,G;AACA,oD;AACA,qB;AACA,G;AACA,sD;AACA,iC;AACA,E;;AAEA,G;AACA,sC;AACA,wC;AACA,G;AACA,wD;AACA,uB;AACA,sE;AACA,G;AACA,Q;AACA,kC;AACA,G;AACA,E;;AAEA,G;AACA,+H;AACA,2C;AACA,2C;AACA,oB;AACA,G;AACA,0E;AACA,wB;AACA,iD;AACA,sC;;AAEA,kB;AACA,K;AACA,+C;AACA,oC;;AAEA,kB;AACA,K;AACA,G;;AAEA,e;AACA,E;;AAEA,oD;AACA,wB;AACA,E;;AAEA,G;AACA,wE;AACA,oB;AACA,G;AACA,yD;AACA,K;AACA,gD;AACA,wD;;AAEA,sE;AACA,E;;AAEA,qG;AACA,wF;;AAEA,+B;AACA,uC;AACA,G;AACA,E;;AAEA,2D;AACA,K;AACA,iB;AACA,2D;AACA,iE;AACA,8C;;AAEA,uB;AACA,+B;AACA,wC;;AAEA,mB;AACA,2B;AACA,O;AACA,K;;AAEA,W;AACA,G;;AAEA,8B;;AAEA,4D;AACA,uE;;AAEA,6D;AACA,uD;;AAEA,0D;AACA,+E;AACA,O;AACA,K;AACA,G;;AAEA,gD;AACA,iE;;AAEA,6D;AACA,oD;;AAEA,uD;AACA,4E;AACA,O;AACA,K;;AAEA,8D;AACA,yE;;AAEA,qH;AACA,wB;AACA,uC;AACA,2F;AACA,S;AACA,O;AACA,oE;AACA,mC;AACA,mD;AACA,uG;AACA,S;AACA,O;AACA,oE;AACA,sC;AACA,sD;AACA,0G;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,+E;;AAEA,6B;AACA,sC;;AAEA,iB;AACA,iD;AACA,6B;AACA,K;AACA,G;AACA,E;;AAEA,kD;AACA,kB;AACA,2B;;AAEA,6E;AACA,mB;AACA,kB;AACA,iD;;AAEA,uB;AACA,+C;AACA,8B;AACA,iC;;AAEA,iB;AACA,iB;AACA,wB;AACA,oB;AACA,6B;AACA,e;AACA,iE;AACA,gC;AACA,e;AACA,oE;AACA,sB;AACA,yB;AACA,8C;AACA,0D;AACA,mG;AACA,M;AACA,sB;AACA,iC;AACA,qF;AACA,M;AACA,+B;AACA,qF;AACA,M;AACA,yB;AACA,2B;AACA,qB;AACA,qC;AACA,wC;AACA,2C;;AAEA,e;AACA,0B;AACA,0B;AACA,2B;AACA,yB;AACA,gC;AACA,+B;AACA,qB;AACA,iB;AACA,8B;AACA,6B;AACA,+B;AACA,8B;AACA,gC;;AAEA,e;AACA,uB;AACA,wB;;AAEA,yB;AACA,iB;AACA,I;;AAEA,yB;AACA,qB;AACA,gC;AACA,0C;AACA,mC;AACA,uC;AACA,O;AACA,6C;AACA,2E;AACA,O;AACA,Y;AACA,4C;AACA,O;AACA,K;AACA,G;AACA,C;;AAEA,G;AACA,kB;AACA,G;;AAEA,mE;AACA,8C;AACA,6B;AACA,uC;AACA,uC;AACA,O;AACA,K;AACA,G;AACA,uD;AACA,oC;AACA,G;AACA,uB;AACA,E;;AAEA,2F;AACA,iD;AACA,iL;AACA,G;AACA,4H;AACA,sC;AACA,G;AACA,Q;AACA,8B;AACA,G;AACA,E;;AAEA,oD;AACA,6B;AACA,E;;AAEA,4C;AACA,yB;AACA,2B;AACA,qB;AACA,+C;;AAEA,c;AACA,qC;AACA,2F;AACA,iD;AACA,sC;AACA,iB;AACA,qJ;AACA,K;AACA,qC;AACA,G;AACA,wC;;AAEA,W;AACA,oC;AACA,2F;AACA,8C;AACA,gC;AACA,iB;AACA,qJ;AACA,K;AACA,qC;AACA,G;AACA,wC;AACA,qC;AACA,wC;;AAEA,Y;AACA,iC;AACA,2F;AACA,+C;AACA,uC;AACA,kC;;AAEA,+B;AACA,uC;AACA,K;;AAEA,iB;AACA,mJ;AACA,K;AACA,mC;AACA,G;AACA,sC;;AAEA,iC;AACA,uD;AACA,G;;AAEA,2B;AACA,2D;AACA,oB;AACA,iD;AACA,uC;AACA,G;AACA,2D;AACA,oB;AACA,iD;AACA,oD;AACA,G;AACA,iE;AACA,uB;AACA,uD;AACA,uD;AACA,G;;AAEA,yD;AACA,wC;AACA,4C;AACA,iC;AACA,K;AACA,G;;AAEA,gE;AACA,iG;AACA,0D;;AAEA,wB;AACA,2B;AACA,C;;AAEA,2D;AACA,qC;AACA,E;;AAEA,G;AACA,oB;AACA,2J;AACA,8B;AACA,G;AACA,uD;AACA,iC;AACA,6D;AACA,0E;AACA,G;;AAEA,kB;AACA,kC;AACA,uE;AACA,K;AACA,U;AACA,6D;AACA,K;AACA,iB;AACA,qE;AACA,iF;AACA,kF;AACA,mB;AACA,K;AACA,U;AACA,wE;AACA,K;;;AAGA,oB;AACA,qE;AACA,kF;AACA,gF;AACA,sB;AACA,Y;AACA,iF;AACA,K;;AAEA,8C;AACA,e;AACA,4C;AACA,sD;AACA,M;AACA,oD;AACA,kB;AACA,+C;AACA,mD;AACA,M;AACA,mD;AACA,G;AACA,Q;AACA,mC;AACA,0J;AACA,K;AACA,2E;AACA,G;;AAEA,mC;;AAEA,iC;AACA,6D;AACA,+D;AACA,2D;AACA,G;;AAEA,6B;AACA,c;AACA,E;;AAEA,kD;AACA,sD;AACA,sB;AACA,E;;AAEA,wE;AACA,2D;AACA,uD;AACA,sD;AACA,G;AACA,E;;AAEA,oE;AACA,a;;AAEA,kC;AACA,W;AACA,G;AACA,wC;;AAEA,iB;AACA,+B;AACA,4E;AACA,2D;AACA,kF;AACA,O;AACA,uE;AACA,8F;AACA,O;AACA,0E;AACA,iG;AACA,O;AACA,K;AACA,G;AACA,6B;AACA,8D;AACA,G;AACA,E;;AAEA,G;AACA,U;AACA,wC;AACA,sF;AACA,0B;AACA,yB;AACA,E;AACA,G;AACA,wD;AACA,iD;AACA,yC;AACA,G;AACA,qD;AACA,wC;AACA,G;;AAEA,gF;;AAEA,a;AACA,+F;AACA,K;AACA,E;;AAEA,G;AACA,kB;AACA,a;AACA,gE;AACA,E;AACA,G;AACA,4D;AACA,uC;AACA,c;AACA,yF;AACA,G;AACA,E;;AAEA,G;AACA,e;AACA,a;AACA,sF;AACA,uC;AACA,E;AACA,G;AACA,yD;AACA,sE;AACA,gB;AACA,G;;AAEA,uE;;AAEA,W;AACA,4B;AACA,G;AACA,E;;AAEA,G;AACA,4C;AACA,Y;AACA,mC;AACA,G;AACA,sD;AACA,yB;AACA,uC;AACA,qC;AACA,6D;AACA,G;AACA,Q;AACA,+C;AACA,G;;AAEA,mC;AACA,Q;AACA,wE;AACA,I;AACA,E;;AAEA,yD;AACA,qE;AACA,E;;AAEA,8D;AACA,gE;AACA,E;;AAEA,6D;AACA,iE;AACA,E;;AAEA,iE;AACA,sE;AACA,E;;AAEA,oC;AACA,gE;AACA,uE;AACA,E;;AAEA,iC;AACA,6D;AACA,8D;AACA,E;;AAEA,4D;AACA,+D;AACA,E;;AAEA,gE;AACA,oE;AACA,E;;AAEA,oC;AACA,+D;AACA,qE;AACA,E;;AAEA,mE;AACA,4D;AACA,E;;AAEA,8D;AACA,wC;AACA,E;;AAEA,kE;AACA,yC;AACA,E;;AAEA,kE;AACA,+D;AACA,E;;AAEA,iE;AACA,2C;AACA,E;;AAEA,gE;AACA,kE;AACA,E;;AAEA,mE;AACA,sE;AACA,E;;AAEA,kE;AACA,sE;AACA,oD;AACA,G;AACA,kK;AACA,wD;AACA,G;AACA,Q;AACA,kE;AACA,G;AACA,E;;AAEA,+D;AACA,sE;AACA,iD;AACA,G;AACA,gK;AACA,oD;AACA,G;AACA,6D;AACA,E;;AAEA,8D;AACA,8D;AACA,E;;AAEA,4D;AACA,6E;AACA,E;;AAEA,G;AACA,+G;AACA,4B;AACA,mB;AACA,G;AACA,gE;AACA,sE;AACA,0E;AACA,mC;AACA,0E;AACA,G;AACA,gB;AACA,E;;;AAGA,iE;AACA,iE;AACA,E;;;AAGA,+D;AACA,mF;AACA,E;;;;AAIA,qE;AACA,4D;AACA,mC;AACA,gC;AACA,wC;AACA,gC;AACA,G;;AAEA,4E;AACA,kC;AACA,qE;AACA,G;AACA,e;AACA,E;;AAEA,8E;AACA,4D;AACA,wG;;AAEA,wD;AACA,gF;AACA,uF;AACA,wF;AACA,2C;AACA,kF;AACA,O;AACA,K;AACA,G;AACA,e;AACA,E;;;AAGA,4C;AACA,yB;AACA,mC;AACA,qC;AACA,2C;;AAEA,6B;AACA,6B;AACA,6B;AACA,mC;;AAEA,8C;;AAEA,C;;AAEA,yD;AACA,yC;AACA,iD;AACA,G;;AAEA,2D;AACA,+C;AACA,+D;AACA,iE;AACA,qD;;AAEA,qB;AACA,uD;AACA,6D;AACA,gB;AACA,sB;AACA,oB;AACA,uD;;AAEA,yB;AACA,gC;AACA,oB;;AAEA,2B;;AAEA,+B;;AAEA,wD;;AAEA,uB;AACA,uD;;AAEA,2C;AACA,oE;AACA,qD;AACA,K;;AAEA,wC;AACA,G;;AAEA,kB;AACA,gC;AACA,G;;AAEA,uC;;AAEA,yC;AACA,6B;;AAEA,wD;;AAEA,4C;;AAEA,0E;AACA,mG;AACA,qD;;AAEA,gE;AACA,8D;;AAEA,2D;AACA,4D;AACA,kE;AACA,iG;AACA,O;AACA,K;;AAEA,8C;;AAEA,6C;AACA,G;;AAEA,E;;AAEA,uF;AACA,gE;AACA,iD;AACA,uC;AACA,G;AACA,E;;AAEA,8F;AACA,iB;AACA,0B;AACA,wE;AACA,yD;;AAEA,6D;AACA,iC;AACA,2H;AACA,K;;AAEA,kE;AACA,4D;AACA,K;;AAEA,uD;;AAEA,wB;AACA,8C;;AAEA,6D;;AAEA,8D;;AAEA,0E;AACA,4B;AACA,6C;AACA,K;;;AAGA,wB;AACA,2O;AACA,mB;AACA,mD;AACA,O;AACA,Y;AACA,wC;AACA,O;AACA,K;;AAEA,sB;;AAEA,sE;AACA,G;AACA,E;;AAEA,6E;AACA,oG;AACA,qJ;AACA,G;AACA,E;;AAEA,oE;AACA,uB;AACA,mB;AACA,oB;AACA,gB;;AAEA,+D;AACA,oB;AACA,e;AACA,gF;AACA,2E;AACA,kE;;AAEA,gE;;AAEA,0I;AACA,6E;AACA,K;AACA,G;;AAEA,E;;AAEA,4F;AACA,yB;;AAEA,kF;AACA,yE;AACA,gC;AACA,iG;AACA,K;AACA,U;AACA,gF;AACA,K;;AAEA,qF;AACA,8B;AACA,8C;AACA,K;;AAEA,iD;AACA,wB;AACA,K;;AAEA,gC;;AAEA,uF;;AAEA,G;;AAEA,Y;AACA,E;;AAEA,+E;AACA,Y;AACA,kH;;AAEA,qF;AACA,uG;AACA,kG;AACA,G;AACA,E;;AAEA,kE;AACA,6B;AACA,qC;AACA,E;;AAEA,yF;AACA,S;;AAEA,qD;AACA,0B;AACA,2B;AACA,8B;AACA,+B;AACA,U;AACA,qF;AACA,G;;AAEA,Y;AACA,E;;AAEA,4D;AACA,wC;AACA,2F;AACA,iD;AACA,G;;AAEA,Y;AACA,E;;AAEA,4E;AACA,oB;AACA,8B;AACA,qC;AACA,E;;AAEA,0E;AACA,+G;;AAEA,wG;AACA,c;AACA,wC;AACA,yB;AACA,qC;AACA,8C;AACA,K;;AAEA,mD;AACA,8E;AACA,G;AACA,E;;AAEA,uE;AACA,mB;AACA,yB;;AAEA,gB;AACA,qB;AACA,E;;AAEA,sE;AACA,gC;AACA,W;AACA,G;;AAEA,2D;AACA,O;AACA,wB;;AAEA,oD;AACA,uC;;AAEA,sH;AACA,gF;AACA,wG;AACA,O;AACA,G;AACA,E;;AAEA,kE;AACA,2D;;AAEA,mB;AACA,mF;AACA,6D;AACA,0C;AACA,G;AACA,mF;AACA,uD;AACA,0C;AACA,G;AACA,E;;AAEA,8D;AACA,2D;AACA,iC;AACA,kC;;AAEA,oG;AACA,oC;AACA,gB;AACA,0C;AACA,mC;AACA,O;AACA,sD;AACA,4E;AACA,qD;AACA,mC;AACA,O;AACA,4E;AACA,qC;AACA,mC;AACA,O;AACA,K;;AAEA,2D;AACA,yD;AACA,6E;AACA,qD;AACA,O;AACA,K;AACA,G;;AAEA,gB;AACA,+B;AACA,G;AACA,E;;AAEA,6E;AACA,wC;AACA,8B;AACA,oD;AACA,2D;AACA,O;AACA,K;;AAEA,Y;AACA,E;;AAEA,iF;AACA,oB;AACA,8B;AACA,+C;AACA,E;;AAEA,kE;AACA,sF;AACA,yC;AACA,iF;AACA,K;AACA,U;AACA,oF;AACA,K;AACA,G;AACA,E;;AAEA,gF;AACA,mC;AACA,gC;AACA,0C;AACA,uB;AACA,Y;AACA,G;AACA,gC;AACA,iC;AACA,Y;AACA,G;AACA,E;;AAEA,6F;AACA,mE;AACA,iD;AACA,uC;AACA,G;AACA,E;;AAEA,E;AACA,uD;AACA,G;AACA,oC;;AAEA,oE;AACA,S;AACA,oC;AACA,0B;AACA,qB;;AAEA,Y;AACA,E;;AAEA,oE;AACA,wC;AACA,0B;AACA,qB;;AAEA,Y;AACA,E;;;;AAIA,wC;AACA,2B;AACA,0B;AACA,0B;;AAEA,kB;;AAEA,yD;AACA,6D;AACA,kD;AACA,K;AACA,C;;AAEA,gE;AACA,wE;AACA,iC;AACA,iD;AACA,G;AACA,Q;AACA,iE;AACA,mJ;AACA,kB;AACA,G;AACA,E;;;AAGA,+D;AACA,Y;;AAEA,8D;AACA,0E;;AAEA,mC;AACA,kI;AACA,U;AACA,gK;AACA,G;;AAEA,0G;AACA,iH;AACA,2D;AACA,0C;AACA,kB;AACA,gD;AACA,G;;AAEA,gC;AACA,sF;;AAEA,6E;AACA,qC;AACA,oB;AACA,wD;AACA,K;AACA,G;;AAEA,yD;AACA,gB;AACA,mF;AACA,E;;AAEA,yE;AACA,c;AACA,wB;AACA,qG;AACA,W;AACA,G;AACA,a;AACA,E;AACA,kE;;AAEA,2B;AACA,+B;AACA,G;;AAEA,mD;AACA,gB;AACA,mB;;AAEA,kJ;AACA,6C;AACA,G;;AAEA,+C;AACA,oC;AACA,oC;AACA,0C;AACA,uC;;AAEA,kC;;AAEA,0C;;AAEA,mB;AACA,E;;AAEA,gE;AACA,8D;AACA,E;;AAEA,sE;AACA,mE;AACA,E;;AAEA,qE;AACA,kO;AACA,E;;AAEA,mE;AACA,uC;AACA,wF;AACA,G;AACA,iC;AACA,E;;AAEA,+D;;AAEA,kD;;AAEA,qC;AACA,2B;AACA,G;;AAEA,wD;AACA,+B;AACA,0C;AACA,G;;AAEA,yB;;AAEA,E;;AAEA,+D;AACA,kC;AACA,oE;AACA,G;AACA,mC;AACA,4D;AACA,4B;AACA,+D;AACA,8B;AACA,gE;AACA,iB;AACA,iE;AACA,8B;AACA,S;AACA,c;AACA,iK;AACA,S;AACA,O;AACA,K;AACA,U;AACA,8B;AACA,K;AACA,G;AACA,6B;AACA,E;;AAEA,uD;AACA,8D;AACA,gD;;AAEA,oC;AACA,0B;AACA,G;;AAEA,gD;AACA,2B;AACA,2C;AACA,G;AACA,Q;AACA,0B;AACA,G;AACA,E;;AAEA,G;AACA,W;AACA,uE;AACA,oF;AACA,+C;AACA,G;AACA,yE;AACA,4B;;AAEA,a;AACA,wD;AACA,sB;AACA,G;AACA,Q;AACA,sC;AACA,G;;AAEA,iI;AACA,gB;AACA,Y;AACA,G;;AAEA,8D;AACA,oB;AACA,4F;AACA,2B;AACA,8B;AACA,G;;AAEA,kB;AACA,+C;AACA,W;AACA,Q;AACA,0C;AACA,yB;AACA,0D;AACA,M;AACA,qF;AACA,0B;AACA,I;AACA,E;;AAEA,G;AACA,W;AACA,6E;AACA,0F;AACA,+C;AACA,G;AACA,4E;AACA,gC;;AAEA,sC;;AAEA,mI;AACA,gB;AACA,Y;AACA,G;;AAEA,sE;AACA,wB;AACA,oG;AACA,6B;AACA,+B;AACA,G;;AAEA,kB;AACA,kD;AACA,U;AACA,Q;AACA,6C;AACA,0B;AACA,6D;AACA,M;AACA,wF;AACA,2B;AACA,wC;AACA,G;AACA,E;;;AAGA,G;AACA,6H;AACA,2J;AACA,G;AACA,6E;AACA,iB;AACA,wE;AACA,8E;AACA,kL;AACA,uB;AACA,K;AACA,G;;AAEA,iB;AACA,4D;AACA,kE;AACA,G;;AAEA,gJ;AACA,uC;;AAEA,kB;AACA,E;;AAEA,G;AACA,uI;AACA,G;AACA,sE;AACA,+D;AACA,qE;AACA,E;;AAEA,G;AACA,qE;AACA,sF;AACA,E;AACA,iG;AACA,yG;AACA,E;AACA,qB;AACA,G;AACA,mH;AACA,mC;AACA,uN;AACA,mB;AACA,K;AACA,0P;AACA,mB;AACA,K;AACA,U;AACA,kB;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,G;AACA,wE;AACA,2F;AACA,E;AACA,oG;AACA,4G;AACA,E;AACA,qB;AACA,G;AACA,yH;AACA,sC;AACA,qP;AACA,mB;AACA,K;AACA,2R;AACA,mB;AACA,K;AACA,U;AACA,kB;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,0I;AACA,mC;AACA,0B;AACA,wB;AACA,4B;AACA,iB;AACA,2B;AACA,4B;AACA,0B;;;AAGA,Q;AACA,c;AACA,kB;AACA,yB;AACA,8B;AACA,0B;;AAEA,gB;;AAEA,qC;AACA,uB;AACA,iC;AACA,8B;AACA,kC;AACA,K;AACA,iB;AACA,I;;AAEA,6C;AACA,oB;AACA,mB;;AAEA,2C;AACA,sC;AACA,2B;AACA,K;;AAEA,uC;AACA,qD;AACA,4C;AACA,+D;AACA,8E;AACA,K;AACA,I;;;AAGA,qC;AACA,oC;;AAEA,kD;AACA,2B;AACA,K;;AAEA,2E;AACA,qC;AACA,6B;AACA,O;AACA,yB;AACA,K;AACA,6B;AACA,uB;AACA,2B;AACA,yB;AACA,K;;AAEA,qC;AACA,0B;AACA,Y;AACA,K;AACA,G;;AAEA,0D;AACA,sC;AACA,iC;AACA,4G;AACA,sD;AACA,2B;AACA,O;AACA,gC;AACA,c;AACA,O;AACA,K;AACA,G;;AAEA,+C;AACA,qB;AACA,G;;AAEA,wD;AACA,qC;AACA,8B;AACA,G;;AAEA,iC;AACA,uD;AACA,G;AACA,C;;;AAGA,G;AACA,kG;AACA,gE;AACA,E;AACA,qB;AACA,4D;AACA,kG;AACA,4E;AACA,+F;AACA,iD;AACA,E;AACA,yC;AACA,yE;AACA,0C;AACA,4F;AACA,iH;AACA,wH;AACA,e;AACA,G;AACA,wH;AACA,mC;AACA,uB;AACA,4B;AACA,qB;AACA,iB;AACA,c;AACA,gB;AACA,yB;AACA,4B;AACA,0B;AACA,uC;AACA,+B;AACA,kC;AACA,mC;AACA,K;AACA,mD;AACA,wB;AACA,K;AACA,0E;AACA,kC;AACA,0B;AACA,O;AACA,sB;AACA,K;AACA,6B;AACA,qB;AACA,2B;AACA,sB;AACA,K;AACA,uC;AACA,0B;AACA,Y;AACA,K;AACA,G;;AAEA,iL;AACA,oD;AACA,gC;AACA,8B;AACA,8I;AACA,qD;AACA,O;AACA,wB;AACA,O;AACA,gC;AACA,O;AACA,a;AACA,O;AACA,K;AACA,G;;AAEA,6C;AACA,qB;AACA,G;;AAEA,qD;AACA,qC;AACA,8B;AACA,G;;AAEA,8B;AACA,iD;AACA,G;AACA,C;;AAEA,oB;AACA,uC;AACA,2C;AACA,W;AACA,c;AACA,c;AACA,gB;AACA,sB;AACA,kE;AACA,gD;;AAEA,kB;AACA,uC;AACA,oC;AACA,uB;AACA,gD;AACA,S;AACA,c;AACA,mE;AACA,+C;AACA,0B;AACA,S;;AAEA,qB;AACA,O;AACA,oB;AACA,Y;AACA,kB;AACA,mC;AACA,+D;AACA,oC;AACA,W;AACA,S;;AAEA,uB;AACA,wD;AACA,4D;;AAEA,sC;AACA,iC;AACA,a;AACA,W;AACA,gB;AACA,6E;AACA,W;AACA,S;;AAEA,sB;AACA,O;AACA,M;AACA,mC;AACA,C;;;;AAIA,yB;;AAEA,G;AACA,a;AACA,kB;AACA,uB;AACA,gB;AACA,4C;AACA,G;;AAEA,c;;AAEA,yC;AACA,iB;AACA,yC;;AAEA,gB;AACA,0B;AACA,qD;AACA,uB;AACA,+B;AACA,0B;AACA,8B;AACA,2B;AACA,sE;;;AAGA,yC;AACA,oB;AACA,yC;;;AAGA,+B;AACA,+B;AACA,6B;AACA,K;;AAEA,O;AACA,wE;AACA,M;AACA,oF;AACA,6D;AACA,O;AACA,sE;AACA,4C;AACA,4B;AACA,mB;AACA,Y;AACA,8F;AACA,4F;AACA,8E;;AAEA,wB;AACA,oE;AACA,yD;AACA,S;;AAEA,sB;AACA,K;;AAEA,yC;AACA,kB;AACA,yC;;AAEA,sD;AACA,0D;AACA,mB;;AAEA,6D;AACA,wD;AACA,iE;AACA,4D;AACA,mE;AACA,sD;AACA,2C;AACA,8C;AACA,sE;AACA,S;;AAEA,wB;AACA,sB;AACA,K;;AAEA,uB;AACA,0C;AACA,oC;AACA,2B;AACA,0B;AACA,0B;AACA,2B;AACA,wE;AACA,oC;AACA,kB;;AAEA,uC;AACA,4C;AACA,gB;AACA,wC;AACA,6B;AACA,oB;AACA,4E;AACA,kH;AACA,iB;;AAEA,+F;AACA,2L;AACA,yL;AACA,yL;AACA,2L;;AAEA,uF;AACA,oE;AACA,iH;;AAEA,0C;AACA,8B;AACA,qB;AACA,iB;;AAEA,oD;AACA,4gB;;AAEA,sD;AACA,8E;AACA,a;AACA,S;AACA,wB;AACA,K;;AAEA,2D;AACA,8C;AACA,iD;AACA,iD;AACA,uB;AACA,wB;AACA,mB;;AAEA,mD;AACA,wC;AACA,wB;AACA,8C;AACA,+C;AACA,wB;AACA,8C;AACA,gB;AACA,6C;AACA,S;;AAEA,4B;AACA,kE;;AAEA,8B;AACA,+B;AACA,uE;AACA,0C;AACA,gC;AACA,kF;AACA,+D;AACA,oC;AACA,iB;AACA,kG;AACA,yC;AACA,oB;AACA,qF;AACA,a;AACA,gB;AACA,2C;AACA,0C;AACA,yF;AACA,yC;AACA,oB;AACA,qF;AACA,a;AACA,S;;AAEA,sB;AACA,K;;AAEA,6D;AACA,uB;AACA,mB;AACA,mC;;AAEA,mC;AACA,wC;AACA,wB;AACA,8C;AACA,gB;AACA,6C;AACA,S;;AAEA,+D;AACA,Q;AACA,wC;AACA,sC;AACA,8C;AACA,qC;AACA,gB;AACA,0C;AACA,S;;AAEA,sB;AACA,K;;AAEA,6B;AACA,+C;AACA,oE;AACA,gF;AACA,2H;AACA,K;;AAEA,oC;AACA,0C;AACA,wB;AACA,kE;AACA,qC;AACA,oB;AACA,iE;AACA,sB;AACA,4D;AACA,sB;AACA,qD;AACA,4C;AACA,sB;AACA,4D;AACA,sB;AACA,qD;AACA,S;AACA,+B;AACA,K;;AAEA,6D;AACA,yB;AACA,2B;AACA,2B;AACA,sB;AACA,6D;AACA,4D;AACA,4D;AACA,6D;AACA,oD;AACA,uB;AACA,qB;AACA,kC;AACA,6E;AACA,gB;AACA,gB;AACA,kB;AACA,c;AACA,sB;AACA,sB;AACA,mB;AACA,wB;;AAEA,wE;AACA,iD;AACA,8B;AACA,gB;AACA,sG;AACA,4D;AACA,2C;AACA,4B;AACA,6C;AACA,kD;AACA,8B;AACA,mD;AACA,a;;AAEA,4C;AACA,2C;AACA,qD;AACA,kD;AACA,kD;AACA,kD;AACA,kD;AACA,6D;;AAEA,sD;AACA,gD;AACA,+B;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,qE;AACA,+B;AACA,oF;AACA,qD;AACA,qG;AACA,8B;AACA,mF;AACA,oD;AACA,oG;AACA,8B;AACA,mF;AACA,oD;AACA,oG;AACA,+B;AACA,oF;AACA,oD;AACA,iB;AACA,a;;AAEA,6C;AACA,2C;AACA,yC;AACA,gD;AACA,gC;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,oE;AACA,gD;AACA,kD;;AAEA,sD;AACA,wD;AACA,sC;AACA,gD;AACA,yB;AACA,8B;AACA,qB;AACA,iB;AACA,a;;AAEA,uC;AACA,2C;AACA,yC;AACA,gD;AACA,8B;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,sE;AACA,a;;AAEA,6C;AACA,8B;AACA,oD;AACA,a;;AAEA,+C;AACA,6C;AACA,4C;;AAEA,4B;AACA,kD;AACA,2D;AACA,qD;AACA,2H;AACA,wB;AACA,2E;AACA,iB;;AAEA,oC;;AAEA,6C;AACA,wF;AACA,wB;AACA,2B;AACA,iB;;AAEA,yD;AACA,2B;AACA,iB;AACA,oB;AACA,2D;AACA,a;;AAEA,4B;AACA,sC;AACA,+B;AACA,2B;AACA,a;;AAEA,iC;AACA,4H;AACA,a;;AAEA,4C;AACA,uB;AACA,a;;AAEA,sN;AACA,S;AACA,K;;AAEA,yC;AACA,2B;AACA,yC;;AAEA,gC;AACA,uC;AACA,kC;AACA,iE;AACA,sB;AACA,oC;AACA,+C;AACA,S;;AAEA,0C;AACA,M;;AAEA,qB;AACA,8B;;AAEA,6B;AACA,wC;AACA,sC;AACA,M;;AAEA,8E;AACA,2E;AACA,oB;AACA,+C;AACA,mB;AACA,mC;AACA,S;;AAEA,6B;AACA,iC;AACA,6D;AACA,a;AACA,kC;AACA,S;;AAEA,wC;AACA,sC;AACA,S;;AAEA,uB;AACA,M;AACA,I;AACA,qE;AACA,oE;AACA,8B;AACA,2C;AACA,mB;AACA,8C;AACA,S;AACA,Q;AACA,8B;AACA,yD;AACA,S;AACA,Q;AACA,8B;AACA,M;;AAEA,4B;AACA,qB;AACA,2B;AACA,wB;AACA,U;AACA,wB;AACA,0B;AACA,yB;AACA,yB;AACA,yB;AACA,U;AACA,oC;AACA,gC;AACA,0D;AACA,kC;AACA,kC;AACA,wC;AACA,U;AACA,mB;AACA,uB;AACA,S;AACA,O;;AAEA,4C;AACA,iE;AACA,M;;AAEA,+C;AACA,qE;AACA,M;;AAEA,yC;AACA,e;AACA,yC;;AAEA,wC;AACA,gC;AACA,K;;AAEA,yC;AACA,8B;AACA,yC;;AAEA,6D;AACA,wE;;AAEA,O;AACA,gE;AACA,kH;AACA,O;AACA,uD;AACA,wE;AACA,yB;AACA,Y;AACA,+D;AACA,oF;AACA,qF;AACA,mF;AACA,0F;AACA,a;AACA,Y;AACA,iD;AACA,qE;AACA,a;;AAEA,sB;AACA,sB;AACA,2C;AACA,mC;;AAEA,uC;AACA,yC;AACA,kC;AACA,a;;AAEA,sD;AACA,iD;AACA,qC;AACA,0E;AACA,4B;AACA,4C;AACA,0C;AACA,qB;AACA,iB;AACA,a;;AAEA,8B;AACA,mF;AACA,a;;AAEA,yB;AACA,U;AACA,K;;AAEA,I;AACA,O;AACA,wD;AACA,wD;AACA,wB;AACA,O;AACA,4B;AACA,4C;AACA,+B;AACA,qB;AACA,S;AACA,6C;AACA,K;;AAEA,O;AACA,gE;AACA,uE;AACA,mB;AACA,O;AACA,iC;AACA,yD;AACA,kD;AACA,sC;AACA,sC;AACA,iC;AACA,sB;AACA,a;;;AAGA,yC;AACA,yB;AACA,yC;;;AAGA,sC;;AAEA,6B;AACA,iC;AACA,U;;AAEA,2D;AACA,uC;AACA,6D;AACA,kF;AACA,gB;AACA,U;;AAEA,2C;AACA,qF;AACA,oC;AACA,a;AACA,oF;AACA,U;;AAEA,6B;AACA,+B;AACA,U;;AAEA,+B;AACA,+B;AACA,U;;AAEA,gC;AACA,wC;AACA,wB;AACA,U;;AAEA,gC;AACA,6E;AACA,mD;AACA,iD;AACA,a;AACA,6E;AACA,wB;AACA,U;;AAEA,qC;AACA,6E;AACA,mD;AACA,iD;AACA,a;AACA,mG;AACA,wB;AACA,U;;AAEA,qC;AACA,mD;AACA,+D;AACA,mE;AACA,8C;AACA,a;AACA,gE;AACA,wB;AACA,U;;AAEA,mC;AACA,mD;AACA,+D;AACA,kE;AACA,a;AACA,yE;AACA,wB;AACA,U;;AAEA,uC;AACA,0E;AACA,S;;AAEA,M;;AAEA,yC;AACA,wB;AACA,yC;;AAEA,iC;AACA,oB;AACA,iC;AACA,K;;AAEA,2B;AACA,uC;AACA,gF;AACA,oE;AACA,+C;AACA,kC;AACA,K;;AAEA,4B;AACA,qD;AACA,gC;AACA,2B;AACA,W;AACA,K;AACA,c","file":"/packages/olragon_handsontable.js","sourcesContent":["/*!\n * Handsontable 0.12.3\n * Handsontable is a JavaScript library for editable tables with basic copy-paste compatibility with Excel and Google Docs\n *\n * Copyright 2012-2014 Marcin Warpechowski\n * Licensed under the MIT license.\n * http://handsontable.com/\n *\n * Date: Mon Jan 12 2015 10:24:46 GMT+0100 (CET)\n */\n/*jslint white: true, browser: true, plusplus: true, indent: 4, maxerr: 50 */\n\n//var Handsontable = { //class namespace\n//  plugins: {}, //plugin namespace\n//  helper: {} //helper namespace\n//};\n\nvar Handsontable = function (rootElement, userSettings) {\n  userSettings = userSettings || {};\n  var instance = new Handsontable.Core(rootElement, userSettings);\n  instance.init();\n  return instance;\n};\nHandsontable.plugins = {};\n\n// Meteor support\nif (typeof Package !== 'undefined') {\n  window.Handsontable = Handsontable;\n}\n\n(function (window, Handsontable) {\n  \"use strict\";\n\n//http://stackoverflow.com/questions/3629183/why-doesnt-indexof-work-on-an-array-ie8\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function (elt /*, from*/) {\n    var len = this.length >>> 0;\n\n    var from = Number(arguments[1]) || 0;\n    from = (from < 0)\n      ? Math.ceil(from)\n      : Math.floor(from);\n    if (from < 0)\n      from += len;\n\n    for (; from < len; from++) {\n      if (from in this &&\n        this[from] === elt)\n        return from;\n    }\n    return -1;\n  };\n}\n/**\n * Array.filter() shim by Trevor Menagh (https://github.com/trevmex) with some modifications\n */\n\nif (!Array.prototype.filter) {\n  Array.prototype.filter = function (fun, thisp) {\n    \"use strict\";\n\n    if (typeof this === \"undefined\" || this === null) {\n      throw new TypeError();\n    }\n    if (typeof fun !== \"function\") {\n      throw new TypeError();\n    }\n\n    thisp = thisp || this;\n\n    if (isNodeList(thisp)) {\n      thisp = convertNodeListToArray(thisp);\n    }\n\n    var len = thisp.length,\n      res = [],\n      i,\n      val;\n\n    for (i = 0; i < len; i += 1) {\n      if (thisp.hasOwnProperty(i)) {\n        val = thisp[i]; // in case fun mutates this\n        if (fun.call(thisp, val, i, thisp)) {\n          res.push(val);\n        }\n      }\n    }\n\n    return res;\n\n    function isNodeList(object) {\n      return /NodeList/i.test(object.item);\n    }\n\n    function convertNodeListToArray(nodeList) {\n      var array = [];\n\n      for (var i = 0, len = nodeList.length; i < len; i++){\n        array[i] = nodeList[i]\n      }\n\n      return array;\n    }\n  };\n}\n\nif (!Array.isArray) {\n  Array.isArray = function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n// License CC-BY-SA v2.5\nif (!Object.keys) {\n  Object.keys = (function() {\n    'use strict';\n    var hasOwnProperty = Object.prototype.hasOwnProperty,\n      hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n      dontEnums = [\n        'toString',\n        'toLocaleString',\n        'valueOf',\n        'hasOwnProperty',\n        'isPrototypeOf',\n        'propertyIsEnumerable',\n        'constructor'\n      ],\n      dontEnumsLength = dontEnums.length;\n\n    return function(obj) {\n      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n        throw new TypeError('Object.keys called on non-object');\n      }\n\n      var result = [], prop, i;\n\n      for (prop in obj) {\n        if (hasOwnProperty.call(obj, prop)) {\n          result.push(prop);\n        }\n      }\n\n      if (hasDontEnumBug) {\n        for (i = 0; i < dontEnumsLength; i++) {\n          if (hasOwnProperty.call(obj, dontEnums[i])) {\n            result.push(dontEnums[i]);\n          }\n        }\n      }\n      return result;\n    };\n  }());\n}\n\n/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nif (typeof WeakMap === 'undefined') {\n  (function() {\n    var defineProperty = Object.defineProperty;\n\n    try {\n      var properDefineProperty = true;\n      defineProperty(function(){}, 'foo', {});\n    } catch (e) {\n      properDefineProperty = false;\n    }\n\n    /*\n      IE8 does not support Date.now() but IE8 compatibility mode in IE9 and IE10 does.\n      M$ deserves a high five for this one :)\n     */\n    var counter = +(new Date) % 1e9;\n\n    var WeakMap = function() {\n      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n      if(!properDefineProperty){\n        this._wmCache = [];\n      }\n    };\n\n    if(properDefineProperty){\n      WeakMap.prototype = {\n        set: function(key, value) {\n          var entry = key[this.name];\n          if (entry && entry[0] === key)\n            entry[1] = value;\n          else\n            defineProperty(key, this.name, {value: [key, value], writable: true});\n\n        },\n        get: function(key) {\n          var entry;\n          return (entry = key[this.name]) && entry[0] === key ?\n            entry[1] : undefined;\n        },\n        'delete': function(key) {\n          this.set(key, undefined);\n        }\n      };\n    } else {\n      WeakMap.prototype = {\n        set: function(key, value) {\n\n          if(typeof key == 'undefined' || typeof value == 'undefined') return;\n\n          for(var i = 0, len = this._wmCache.length; i < len; i++){\n            if(this._wmCache[i].key == key){\n              this._wmCache[i].value = value;\n              return;\n            }\n          }\n\n          this._wmCache.push({key: key, value: value});\n\n        },\n        get: function(key) {\n\n          if(typeof key == 'undefined') return;\n\n          for(var i = 0, len = this._wmCache.length; i < len; i++){\n            if(this._wmCache[i].key == key){\n              return  this._wmCache[i].value;\n            }\n          }\n\n          return;\n\n        },\n        'delete': function(key) {\n\n          if(typeof key == 'undefined') return;\n\n          for(var i = 0, len = this._wmCache.length; i < len; i++){\n            if(this._wmCache[i].key == key){\n              Array.prototype.slice.call(this._wmCache, i, 1);\n            }\n          }\n        }\n      };\n    }\n\n    window.WeakMap = WeakMap;\n  })();\n}\n\nHandsontable.activeGuid = null;\n\n/**\n * Handsontable constructor\n * @param rootElement The DOM element in which Handsontable DOM will be inserted\n * @param userSettings\n * @constructor\n */\nHandsontable.Core = function (rootElement, userSettings) {\n  var priv\n    , datamap\n    , grid\n    , selection\n    , editorManager\n    , instance = this\n    , GridSettings = function () {}\n    , eventManager = Handsontable.eventManager(instance);\n\n  Handsontable.helper.extend(GridSettings.prototype, DefaultSettings.prototype); //create grid settings as a copy of default settings\n  Handsontable.helper.extend(GridSettings.prototype, userSettings); //overwrite defaults with user settings\n  Handsontable.helper.extend(GridSettings.prototype, expandType(userSettings));\n\n  this.rootElement = rootElement;\n\n  this.container = document.createElement('DIV');\n  this.container.className = 'htContainer';\n\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n\n  this.guid = 'ht_' + Handsontable.helper.randomString(); //this is the namespace for global events\n\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === \"ht_\") {\n    this.rootElement.id = this.guid; //if root element does not have an id, assign a random id\n  }\n  priv = {\n    cellSettings: [],\n    columnSettings: [],\n    columnsSettingConflicts: ['data', 'width'],\n    settings: new GridSettings(), // current settings instance\n    selRange: null, //exposed by public method `getSelectedRange`\n    isPopulated: null,\n    scrollable: null,\n    firstRun: true\n  };\n\n  grid = {\n    /**\n     * Inserts or removes rows and columns\n     * @param {String} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\"\n     * @param {Number} index\n     * @param {Number} amount\n     * @param {String} [source] Optional. Source of hook runner.\n     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function (action, index, amount, source, keepEmptyRows) {\n      var delta;\n\n      amount = amount || 1;\n\n      switch (action) {\n        case \"insert_row\":\n          delta = datamap.createRow(index, amount);\n\n          if (delta) {\n            if (selection.isSelected() && priv.selRange.from.row >= index) {\n              priv.selRange.from.row = priv.selRange.from.row + delta;\n              selection.transformEnd(delta, 0); //will call render() internally\n            }\n            else {\n              selection.refreshBorders(); //it will call render and prepare methods\n            }\n          }\n          break;\n\n        case \"insert_col\":\n          // //column order may have changes, so we need to translate the selection column index -> source array index\n          // index = instance.runHooksAndReturn('modifyCol', index);\n            delta = datamap.createCol(index, amount);\n\n          if (delta) {\n\n            if(Array.isArray(instance.getSettings().colHeaders)){\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; //inserts empty (undefined) elements at the end of an array\n              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray); //inserts empty (undefined) elements into the colHeader array\n            }\n\n            if (selection.isSelected() && priv.selRange.from.col >= index) {\n              priv.selRange.from.col = priv.selRange.from.col + delta;\n              selection.transformEnd(0, delta); //will call render() internally\n            }\n            else {\n              selection.refreshBorders(); //it will call render and prepare methods\n            }\n          }\n          break;\n\n        case \"remove_row\":\n          //column order may have changes, so we need to translate the selection column index -> source array index\n          index = instance.runHooksAndReturn('modifyCol', index);\n\n          datamap.removeRow(index, amount);\n          priv.cellSettings.splice(index, amount);\n          grid.adjustRowsAndCols();\n          selection.refreshBorders(); //it will call render and prepare methods\n          break;\n\n        case \"remove_col\":\n          datamap.removeCol(index, amount);\n\n          for(var row = 0, len = datamap.getAll().length; row < len; row++){\n            if(row in priv.cellSettings){  //if row hasn't been rendered it wouldn't have cellSettings\n              priv.cellSettings[row].splice(index, amount);\n            }\n          }\n\n          if(Array.isArray(instance.getSettings().colHeaders)){\n            if(typeof index == 'undefined'){\n              index = -1;\n            }\n            instance.getSettings().colHeaders.splice(index, amount);\n          }\n\n          //priv.columnSettings.splice(index, amount);\n\n          grid.adjustRowsAndCols();\n          selection.refreshBorders(); //it will call render and prepare methods\n          break;\n\n        default:\n          throw new Error('There is no such action \"' + action + '\"');\n          break;\n      }\n\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); //makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table\n     */\n    adjustRowsAndCols: function () {\n      var r, rlen, emptyRows, emptyCols;\n\n      //should I add empty rows to data source to meet minRows?\n      rlen = instance.countRows();\n      if (rlen < priv.settings.minRows) {\n        for (r = 0; r < priv.settings.minRows - rlen; r++) {\n          datamap.createRow(instance.countRows(), 1, true);\n        }\n      }\n\n      emptyRows = instance.countEmptyRows(true);\n\n      //should I add empty rows to meet minSpareRows?\n      if (emptyRows < priv.settings.minSpareRows) {\n        for (; emptyRows < priv.settings.minSpareRows && instance.countRows() < priv.settings.maxRows; emptyRows++) {\n          datamap.createRow(instance.countRows(), 1, true);\n        }\n      }\n\n      //count currently empty cols\n      emptyCols = instance.countEmptyCols(true);\n\n      //should I add empty cols to meet minCols?\n      if (!priv.settings.columns && instance.countCols() < priv.settings.minCols) {\n        for (; instance.countCols() < priv.settings.minCols; emptyCols++) {\n          datamap.createCol(instance.countCols(), 1, true);\n        }\n      }\n\n      //should I add empty cols to meet minSpareCols?\n      if (!priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {\n        for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {\n          datamap.createCol(instance.countCols(), 1, true);\n        }\n      }\n\n      // if (priv.settings.enterBeginsEditing) {\n      //   for (; (((priv.settings.minRows || priv.settings.minSpareRows) && instance.countRows() > priv.settings.minRows) && (priv.settings.minSpareRows && emptyRows > priv.settings.minSpareRows)); emptyRows--) {\n      //     datamap.removeRow();\n      //   }\n      // }\n\n      // if (priv.settings.enterBeginsEditing && !priv.settings.columns) {\n      //   for (; (((priv.settings.minCols || priv.settings.minSpareCols) && instance.countCols() > priv.settings.minCols) && (priv.settings.minSpareCols && emptyCols > priv.settings.minSpareCols)); emptyCols--) {\n      //     datamap.removeCol();\n      //   }\n      // }\n\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n\n      if (selection.isSelected()) {\n        var selectionChanged;\n        var fromRow = priv.selRange.from.row;\n        var fromCol = priv.selRange.from.col;\n        var toRow = priv.selRange.to.row;\n        var toCol = priv.selRange.to.col;\n\n        //if selection is outside, move selection to last row\n        if (fromRow > rowCount - 1) {\n          fromRow = rowCount - 1;\n          selectionChanged = true;\n          if (toRow > fromRow) {\n            toRow = fromRow;\n          }\n        } else if (toRow > rowCount - 1) {\n          toRow = rowCount - 1;\n          selectionChanged = true;\n          if (fromRow > toRow) {\n            fromRow = toRow;\n          }\n        }\n\n        //if selection is outside, move selection to last row\n        if (fromCol > colCount - 1) {\n          fromCol = colCount - 1;\n          selectionChanged = true;\n          if (toCol > fromCol) {\n            toCol = fromCol;\n          }\n        } else if (toCol > colCount - 1) {\n          toCol = colCount - 1;\n          selectionChanged = true;\n          if (fromCol > toCol) {\n            fromCol = toCol;\n          }\n        }\n\n        if (selectionChanged) {\n          instance.selectCell(fromRow, fromCol, toRow, toCol);\n        }\n      }\n    },\n\n    /**\n     * Populate cells at position with 2d array\n     * @param {Object} start Start selection position\n     * @param {Array} input 2d array\n     * @param {Object} [end] End selection position (only for drag-down mode)\n     * @param {String} [source=\"populateFromArray\"]\n     * @param {String} [method=\"overwrite\"]\n     * @param {String} direction (left|right|up|down)\n     * @param {Array} deltas array\n     * @return {Object|undefined} ending td in pasted area (only if any cell was changed)\n     */\n    populateFromArray: function (start, input, end, source, method, direction, deltas) {\n      var r, rlen, c, clen, setData = [], current = {};\n      rlen = input.length;\n      if (rlen === 0) {\n        return false;\n      }\n\n      var repeatCol\n        , repeatRow\n        , cmax\n        , rmax;\n\n      // insert data with specified pasteMode method\n      switch (method) {\n        case 'shift_down' :\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0;\n          input = Handsontable.helper.translateRowsToColumns(input);\n          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {\n            if (c < clen) {\n              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {\n                input[c].push(input[c][r % rlen]);\n              }\n              input[c].unshift(start.col + c, start.row, 0);\n              instance.spliceCol.apply(instance, input[c]);\n            }\n            else {\n              input[c % clen][0] = start.col + c;\n              instance.spliceCol.apply(instance, input[c % clen]);\n            }\n          }\n          break;\n\n        case 'shift_right' :\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0;\n          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {\n            if (r < rlen) {\n              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {\n                input[r].push(input[r][c % clen]);\n              }\n              input[r].unshift(start.row + r, start.col, 0);\n              instance.spliceRow.apply(instance, input[r]);\n            }\n            else {\n              input[r % rlen][0] = start.row + r;\n              instance.spliceRow.apply(instance, input[r % rlen]);\n            }\n          }\n          break;\n\n        case 'overwrite' :\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n\n          var iterators = {row: 0, col: 0}, // number of packages\n              selected = { // selected range\n                row: (end && start) ? (end.row - start.row + 1) : 1,\n                col: (end && start) ? (end.col - start.col + 1) : 1\n              };\n\n          if (['up', 'left'].indexOf(direction) !== -1) {\n            iterators = {\n              row: Math.ceil(selected.row / rlen) || 1,\n              col: Math.ceil(selected.col / input[0].length) || 1\n            }\n          } else if (['down', 'right'].indexOf(direction) !== -1) {\n            iterators = {\n              row: 1,\n              col: 1\n            };\n          }\n\n\n          for (r = 0; r < rlen; r++) {\n            if ((end && current.row > end.row) || (!priv.settings.allowInsertRow && current.row > instance.countRows() - 1) || (current.row >= priv.settings.maxRows)) {\n              break;\n            }\n            current.col = start.col;\n            clen = input[r] ? input[r].length : 0;\n            for (c = 0; c < clen; c++) {\n              if ((end && current.col > end.col) || (!priv.settings.allowInsertColumn && current.col > instance.countCols() - 1) || (current.col >= priv.settings.maxCols)) {\n                break;\n              }\n\n              if (!instance.getCellMeta(current.row, current.col).readOnly) {\n                var result,\n                    value = input[r][c],\n                    index = {\n                      row: r,\n                      col: c\n                    };\n\n                if (source === 'autofill') {\n                  result = instance.runHooksAndReturn('beforeAutofillInsidePopulate', index, direction, input, deltas, iterators, selected);\n\n                  if (result) {\n                    iterators = typeof(result.iterators) !== 'undefined' ? result.iterators : iterators;\n                    value = typeof(result.value) !== 'undefined' ? result.value : value;\n                  }\n                }\n\n                setData.push([current.row, current.col, value]);\n              }\n\n              current.col++;\n\n              if (end && c === clen - 1) {\n                c = -1;\n\n                if (['down', 'right'].indexOf(direction) !== -1) {\n                  iterators.col++;\n                } else if (['up', 'left'].indexOf(direction) !== -1) {\n                  if (iterators.col > 1) {\n                    iterators.col--;\n                  }\n                }\n\n              }\n            }\n\n            current.row++;\n            iterators.col = 1;\n\n            if (end && r === rlen - 1) {\n              r = -1;\n\n              if (['down', 'right'].indexOf(direction) !== -1) {\n                iterators.row++;\n              } else if (['up', 'left'].indexOf(direction) !== -1) {\n                if (iterators.row > 1) {\n                  iterators.row--;\n                }\n              }\n\n            }\n          }\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n\n  this.selection = selection = { //this public assignment is only temporary\n    inProgress: false,\n\n    selectedHeader: {\n      cols: false,\n      rows: false\n    },\n\n    setSelectedHeaders: function (rows, cols) {\n      instance.selection.selectedHeader.rows = rows;\n      instance.selection.selectedHeader.cols = cols;\n    },\n\n    /**\n     * Sets inProgress to true. This enables onSelectionEnd and onSelectionEndByProp to function as desired\n     */\n    begin: function () {\n      instance.selection.inProgress = true;\n    },\n\n    /**\n     * Sets inProgress to false. Triggers onSelectionEnd and onSelectionEndByProp\n     */\n    finish: function () {\n      var sel = instance.getSelected();\n      Handsontable.hooks.run(instance, \"afterSelectionEnd\", sel[0], sel[1], sel[2], sel[3]);\n      Handsontable.hooks.run(instance, \"afterSelectionEndByProp\", sel[0], instance.colToProp(sel[1]), sel[2], instance.colToProp(sel[3]));\n      instance.selection.inProgress = false;\n    },\n\n    isInProgress: function () {\n      return instance.selection.inProgress;\n    },\n\n    /**\n     * Starts selection range on given td object\n     * @param {WalkontableCellCoords} coords\n     */\n    setRangeStart: function (coords, keepEditorOpened) {\n      Handsontable.hooks.run(instance, \"beforeSetRangeStart\", coords);\n      priv.selRange = new WalkontableCellRange(coords, coords, coords);\n      selection.setRangeEnd(coords, null, keepEditorOpened);\n    },\n\n    /**\n     * Ends selection range on given td object\n     * @param {WalkontableCellCoords} coords\n     * @param {Boolean} [scrollToCell=true] If true, viewport will be scrolled to range end\n     */\n    setRangeEnd: function (coords, scrollToCell, keepEditorOpened) {\n      //trigger handlers\n      Handsontable.hooks.run(instance, \"beforeSetRangeEnd\", coords);\n\n      instance.selection.begin();\n\n      priv.selRange.to = new WalkontableCellCoords(coords.row, coords.col);\n      if (!priv.settings.multiSelect) {\n        priv.selRange.from = coords;\n      }\n\n      //set up current selection\n      instance.view.wt.selections.current.clear();\n      instance.view.wt.selections.current.add(priv.selRange.highlight);\n\n      //set up area selection\n      instance.view.wt.selections.area.clear();\n      if (selection.isMultiple()) {\n        instance.view.wt.selections.area.add(priv.selRange.from);\n        instance.view.wt.selections.area.add(priv.selRange.to);\n      }\n\n      //set up highlight\n      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {\n        instance.view.wt.selections.highlight.clear();\n        instance.view.wt.selections.highlight.add(priv.selRange.from);\n        instance.view.wt.selections.highlight.add(priv.selRange.to);\n      }\n\n      //trigger handlers\n      Handsontable.hooks.run(instance, \"afterSelection\", priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col);\n      Handsontable.hooks.run(instance, \"afterSelectionByProp\", priv.selRange.from.row, datamap.colToProp(priv.selRange.from.col), priv.selRange.to.row, datamap.colToProp(priv.selRange.to.col));\n\n      if (scrollToCell !== false && instance.view.mainViewIsActive()) {\n        instance.view.scrollViewport(coords);\n      }\n      selection.refreshBorders(null, keepEditorOpened);\n    },\n\n    /**\n     * Destroys editor, redraws borders around cells, prepares editor\n     * @param {Boolean} revertOriginal\n     * @param {Boolean} keepEditor\n     */\n    refreshBorders: function (revertOriginal, keepEditor) {\n      if (!keepEditor) {\n        editorManager.destroyEditor(revertOriginal);\n      }\n      instance.view.render();\n      if (selection.isSelected() && !keepEditor) {\n        editorManager.prepareEditor();\n      }\n    },\n\n    /**\n     * Returns information if we have a multiselection\n     * @return {Boolean}\n     */\n    isMultiple: function () {\n      var isMultiple = !(priv.selRange.to.col === priv.selRange.from.col && priv.selRange.to.row === priv.selRange.from.row)\n        , modifier = Handsontable.hooks.execute(instance, 'afterIsMultipleSelection', isMultiple);\n\n      if(isMultiple) {\n        return modifier;\n      }\n    },\n\n    /**\n     * Selects cell relative to current cell (if possible)\n     */\n    transformStart: function (rowDelta, colDelta, force, keepEditorOpened) {\n      var delta = new WalkontableCellCoords(rowDelta, colDelta);\n      instance.runHooks('modifyTransformStart', delta);\n\n      if (priv.selRange.highlight.row + rowDelta > instance.countRows() - 1) {\n        if (force && priv.settings.minSpareRows > 0) {\n          instance.alter(\"insert_row\", instance.countRows());\n        }\n        else if (priv.settings.autoWrapCol) {\n          delta.row = 1 - instance.countRows();\n          delta.col = priv.selRange.highlight.col + delta.col == instance.countCols() - 1 ? 1 - instance.countCols() : 1;\n        }\n      }\n      else if (priv.settings.autoWrapCol && priv.selRange.highlight.row + delta.row < 0 && priv.selRange.highlight.col + delta.col >= 0) {\n        delta.row = instance.countRows() - 1;\n        delta.col = priv.selRange.highlight.col + delta.col == 0 ? instance.countCols() - 1 : -1;\n      }\n\n      if (priv.selRange.highlight.col + delta.col > instance.countCols() - 1) {\n        if (force && priv.settings.minSpareCols > 0) {\n          instance.alter(\"insert_col\", instance.countCols());\n        }\n        else if (priv.settings.autoWrapRow) {\n          delta.row = priv.selRange.highlight.row + delta.row == instance.countRows() - 1 ? 1 - instance.countRows() : 1;\n          delta.col = 1 - instance.countCols();\n        }\n      }\n      else if (priv.settings.autoWrapRow && priv.selRange.highlight.col + delta.col < 0 && priv.selRange.highlight.row + delta.row >= 0) {\n        delta.row = priv.selRange.highlight.row + delta.row == 0 ? instance.countRows() - 1 : -1;\n        delta.col = instance.countCols() - 1;\n      }\n\n      var totalRows = instance.countRows();\n      var totalCols = instance.countCols();\n      var coords = new WalkontableCellCoords(priv.selRange.highlight.row + delta.row, priv.selRange.highlight.col + delta.col);\n\n      if (coords.row < 0) {\n        coords.row = 0;\n      }\n      else if (coords.row > 0 && coords.row >= totalRows) {\n        coords.row = totalRows - 1;\n      }\n\n      if (coords.col < 0) {\n        coords.col = 0;\n      }\n      else if (coords.col > 0 && coords.col >= totalCols) {\n        coords.col = totalCols - 1;\n      }\n\n      selection.setRangeStart(coords, keepEditorOpened);\n    },\n\n    /**\n     * Sets selection end cell relative to current selection end cell (if possible)\n     */\n    transformEnd: function (rowDelta, colDelta) {\n      var delta = new WalkontableCellCoords(rowDelta, colDelta);\n      instance.runHooks('modifyTransformEnd', delta);\n\n        var totalRows = instance.countRows();\n        var totalCols = instance.countCols();\n        var coords = new WalkontableCellCoords(priv.selRange.to.row + delta.row, priv.selRange.to.col + delta.col);\n\n        if (coords.row < 0) {\n          coords.row = 0;\n        }\n        else if (coords.row > 0 && coords.row >= totalRows) {\n          coords.row = totalRows - 1;\n        }\n\n        if (coords.col < 0) {\n          coords.col = 0;\n        }\n        else if (coords.col > 0 && coords.col >= totalCols) {\n          coords.col = totalCols - 1;\n        }\n\n        selection.setRangeEnd(coords);\n    },\n\n    /**\n     * Returns true if currently there is a selection on screen, false otherwise\n     * @return {Boolean}\n     */\n    isSelected: function () {\n      return (priv.selRange !== null);\n    },\n\n    /**\n     * Returns true if coords is within current selection coords\n     * @param {WalkontableCellCoords} coords\n     * @return {Boolean}\n     */\n    inInSelection: function (coords) {\n      if (!selection.isSelected()) {\n        return false;\n      }\n      return priv.selRange.includes(coords);\n    },\n\n    /**\n     * Deselects all selected cells\n     */\n    deselect: function () {\n      if (!selection.isSelected()) {\n        return;\n      }\n      instance.selection.inProgress = false; //needed by HT inception\n      priv.selRange = null;\n      instance.view.wt.selections.current.clear();\n      instance.view.wt.selections.area.clear();\n      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {\n        instance.view.wt.selections.highlight.clear();\n      }\n      editorManager.destroyEditor();\n      selection.refreshBorders();\n      Handsontable.hooks.run(instance, 'afterDeselect');\n    },\n\n    /**\n     * Select all cells\n     */\n    selectAll: function () {\n      if (!priv.settings.multiSelect) {\n        return;\n      }\n      selection.setRangeStart(new WalkontableCellCoords(0, 0));\n      selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, instance.countCols() - 1), false);\n    },\n\n    /**\n     * Deletes data from selected cells\n     */\n    empty: function () {\n      if (!selection.isSelected()) {\n        return;\n      }\n      var topLeft = priv.selRange.getTopLeftCorner();\n      var bottomRight = priv.selRange.getBottomRightCorner();\n      var r, c, changes = [];\n      for (r = topLeft.row; r <= bottomRight.row; r++) {\n        for (c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!instance.getCellMeta(r, c).readOnly) {\n            changes.push([r, c, '']);\n          }\n        }\n      }\n      instance.setDataAtCell(changes);\n    }\n  };\n\n  this.init = function () {\n    Handsontable.hooks.run(instance, 'beforeInit');\n\n    if(Handsontable.mobileBrowser) {\n      Handsontable.Dom.addClass(instance.rootElement, 'mobile');\n    }\n\n    this.updateSettings(priv.settings, true);\n\n    this.view = new Handsontable.TableView(this);\n    editorManager = new Handsontable.EditorManager(instance, priv, selection, datamap);\n\n    this.forceFullRender = true; //used when data was changed\n    this.view.render();\n\n    if (typeof priv.firstRun === 'object') {\n      Handsontable.hooks.run(instance, 'afterChange', priv.firstRun[0], priv.firstRun[1]);\n      priv.firstRun = false;\n    }\n    Handsontable.hooks.run(instance, 'afterInit');\n  };\n\n  function ValidatorsQueue() { //moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n\n    return {\n      validatorsInQueue: 0,\n      addValidatorToQueue: function () {\n        this.validatorsInQueue++;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function () {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function () {\n      },\n      checkIfQueueIsEmpty: function () {\n        if (this.validatorsInQueue == 0 && resolved == false) {\n          resolved = true;\n          this.onQueueEmpty();\n        }\n      }\n    };\n  }\n\n  function validateChanges(changes, source, callback) {\n    var waitingForValidator = new ValidatorsQueue();\n    waitingForValidator.onQueueEmpty = resolve;\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      }\n      else {\n        var row = changes[i][0];\n        var col = datamap.propToCol(changes[i][1]);\n        var logicalCol = instance.runHooksAndReturn('modifyCol', col); //column order may have changes, so we need to translate physical col index (stored in datasource) to logical (displayed to user)\n        var cellProperties = instance.getCellMeta(row, logicalCol);\n\n        if (cellProperties.type === 'numeric' && typeof changes[i][3] === 'string') {\n          if (changes[i][3].length > 0 && (/^-?[\\d\\s]*(\\.|\\,)?\\d*$/.test(changes[i][3]) || cellProperties.format )) {\n            var len = changes[i][3].length;\n            if (typeof cellProperties.language == 'undefined') {\n              numeral.language('en');\n            }\n            else if (changes[i][3].indexOf(\".\") === len - 3 && changes[i][3].indexOf(\",\") === -1) { //this input in format XXXX.XX is likely to come from paste. Let's parse it using international rules\n              numeral.language('en');\n            }\n            else {\n              numeral.language(cellProperties.language);\n            }\n\n            changes[i][3] = numeral().unformat(changes[i][3] || '0'); //numeral cannot unformat empty string\n          }\n        }\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, (function (i, cellProperties) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error(\"Validation error: result is not boolean\");\n              }\n              if (result === false && cellProperties.allowInvalid === false) {\n                changes.splice(i, 1);         // cancel the change\n                cellProperties.valid = true;  // we cancelled the change, so cell value is still valid\n                --i;\n              }\n              waitingForValidator.removeValidatorFormQueue();\n            }\n          })(i, cellProperties)\n            , source);\n        }\n      }\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n\n    function resolve() {\n      var beforeChangeResult;\n\n      if (changes.length) {\n        beforeChangeResult = Handsontable.hooks.execute(instance, \"beforeChange\", changes, source);\n        if (typeof beforeChangeResult === 'function') {\n          console.warn(\"Your beforeChange callback returns a function. It's not supported since Handsontable 0.12.1 (and the returned function will not be executed).\");\n        } else if (beforeChangeResult === false) {\n          changes.splice(0, changes.length); //invalidate all changes (remove everything from array)\n        }\n      }\n        callback(); //called when async validators are resolved and beforeChange was not async\n    }\n  }\n\n  /**\n   * Internal function to apply changes. Called after validateChanges\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue]\n   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)\n   */\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n\n    if (i < 0) {\n      return;\n    }\n\n    for (; 0 <= i; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        continue;\n      }\n\n      if(changes[i][2] == null && changes[i][3] == null) {\n        continue;\n      }\n\n      if (priv.settings.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          datamap.createRow();\n        }\n      }\n\n      if (instance.dataType === 'array' && priv.settings.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          datamap.createCol();\n        }\n      }\n\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n\n    instance.forceFullRender = true; //used when data was changed\n    grid.adjustRowsAndCols();\n    Handsontable.hooks.run(instance, 'beforeChangeRender', changes, source);\n    selection.refreshBorders(null, true);\n    Handsontable.hooks.run(instance, 'afterChange', changes, source || 'edit');\n  }\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties);\n\n    if (Object.prototype.toString.call(validator) === '[object RegExp]') {\n      validator = (function (validator) {\n        return function (value, callback) {\n          callback(validator.test(value));\n        }\n      })(validator);\n    }\n\n    if (typeof validator == 'function') {\n\n      value = Handsontable.hooks.execute(instance, \"beforeValidate\", value, cellProperties.row, cellProperties.prop, source);\n\n      // To provide consistent behaviour, validation should be always asynchronous\n      instance._registerTimeout(setTimeout(function () {\n        validator.call(cellProperties, value, function (valid) {\n          cellProperties.valid = valid;\n\n          valid = Handsontable.hooks.execute(instance, \"afterValidate\", valid, value, cellProperties.row, cellProperties.prop, source);\n\n          callback(valid);\n        });\n\n        return value;\n      }, 0));\n    } else { //resolve callback even if validator function was not found\n      cellProperties.valid = true;\n      callback(true);\n    }\n\n\n\n  };\n\n  function setDataInputToArray(row, prop_or_col, value) {\n    if (typeof row === \"object\") { //is it an array of changes\n      return row;\n    }\n    else {\n      return [\n        [row, prop_or_col, value]\n      ];\n    }\n  }\n\n  /**\n   * Set data at given cell\n   * @public\n   * @param {Number|Array} row or array of changes in format [[row, col, value], ...]\n   * @param {Number|String} col or source String\n   * @param {String} value\n   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)\n   */\n  this.setDataAtCell = function (row, col, value, source) {\n    var input = setDataInputToArray(row, col, value)\n      , i\n      , ilen\n      , changes = []\n      , prop;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (typeof input[i] !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');\n      }\n      prop = datamap.colToProp(input[i][1]);\n      changes.push([\n        input[i][0],\n        prop,\n        datamap.get(input[i][0], prop),\n        input[i][2]\n      ]);\n    }\n\n    if (!source && typeof row === \"object\") {\n      source = col;\n    }\n\n    validateChanges(changes, source, function () {\n      applyChanges(changes, source);\n    });\n  };\n\n\n  /**\n   * Set data at given row property\n   * @public\n   * @param {Number|Array} row or array of changes in format [[row, prop, value], ...]\n   * @param {String} prop or source String\n   * @param {String} value\n   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)\n   */\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value)\n      , i\n      , ilen\n      , changes = [];\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([\n        input[i][0],\n        input[i][1],\n        datamap.get(input[i][0], input[i][1]),\n        input[i][2]\n      ]);\n    }\n\n    if (!source && typeof row === \"object\") {\n      source = prop;\n    }\n\n    validateChanges(changes, source, function () {\n      applyChanges(changes, source);\n    });\n  };\n\n  /**\n   * Listen to document body keyboard input\n   */\n  this.listen = function () {\n    Handsontable.activeGuid = instance.guid;\n\n    if (document.activeElement && document.activeElement !== document.body) {\n      document.activeElement.blur();\n    }\n    else if (!document.activeElement) { //IE\n      document.body.focus();\n    }\n  };\n\n  /**\n   * Stop listening to document body keyboard input\n   */\n  this.unlisten = function () {\n    Handsontable.activeGuid = null;\n  };\n\n  /**\n   * Returns true if current Handsontable instance is listening on document body keyboard input\n   */\n  this.isListening = function () {\n    return Handsontable.activeGuid === instance.guid;\n  };\n\n  /**\n   * Destroys current editor, renders and selects current cell. If revertOriginal != true, edited data is saved\n   * @param {Boolean} revertOriginal\n   */\n  this.destroyEditor = function (revertOriginal) {\n    selection.refreshBorders(revertOriginal);\n  };\n\n  /**\n   * Populate cells at position with 2d array\n   * @param {Number} row Start row\n   * @param {Number} col Start column\n   * @param {Array} input 2d array\n   * @param {Number=} endRow End row (use when you want to cut input when certain row is reached)\n   * @param {Number=} endCol End column (use when you want to cut input when certain column is reached)\n   * @param {String=} [source=\"populateFromArray\"]\n   * @param {String=} [method=\"overwrite\"]\n   * @param {String} direction edit (left|right|up|down)\n   * @param {Array} deltas array\n   * @return {Object|undefined} ending td in pasted area (only if any cell was changed)\n   */\n  this.populateFromArray = function (row, col, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(typeof input === 'object' && typeof input[0] === 'object')) {\n      throw new Error(\"populateFromArray parameter `input` must be an array of arrays\"); //API changed in 0.9-beta2, let's check if you use it correctly\n    }\n    return grid.populateFromArray(new WalkontableCellCoords(row, col), input, typeof endRow === 'number' ? new WalkontableCellCoords(endRow, endCol) : null, source, method, direction, deltas);\n  };\n\n  /**\n   * Adds/removes data from the column\n   * @param {Number} col Index of column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array\n   */\n  this.spliceCol = function (col, index, amount/*, elements... */) {\n    return datamap.spliceCol.apply(datamap, arguments);\n  };\n\n  /**\n   * Adds/removes data from the row\n   * @param {Number} row Index of column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array\n   */\n  this.spliceRow = function (row, index, amount/*, elements... */) {\n    return datamap.spliceRow.apply(datamap, arguments);\n  };\n\n  /**\n   * Returns current selection. Returns undefined if there is no selection.\n   * @public\n   * @return {Array} [`startRow`, `startCol`, `endRow`, `endCol`]\n   */\n  this.getSelected = function () { //https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return [priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col];\n    }\n  };\n\n  /**\n   * Returns current selection as a WalkontableCellRange object. Returns undefined if there is no selection.\n   * @public\n   * @return {WalkontableCellRange}\n   */\n  this.getSelectedRange = function () { //https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return priv.selRange;\n    }\n  };\n\n\n  /**\n   * Render visible data\n   * @public\n   */\n  this.render = function () {\n    if (instance.view) {\n      instance.forceFullRender = true; //used when data was changed\n      selection.refreshBorders(null, true);\n    }\n  };\n\n  /**\n   * Load data from array\n   * @public\n   * @param {Array} data\n   */\n  this.loadData = function (data) {\n    if (typeof data === 'object' && data !== null) {\n      if (!(data.push && data.splice)) { //check if data is array. Must use duck-type check so Backbone Collections also pass it\n        //when data is not an array, attempt to make a single-row array of it\n        data = [data];\n      }\n    }\n    else if(data === null) {\n      data = [];\n      var row;\n      for (var r = 0, rlen = priv.settings.startRows; r < rlen; r++) {\n        row = [];\n        for (var c = 0, clen = priv.settings.startCols; c < clen; c++) {\n          row.push(null);\n        }\n        data.push(row);\n      }\n    }\n    else {\n      throw new Error(\"loadData only accepts array of objects or array of arrays (\" + typeof data + \" given)\");\n    }\n\n    priv.isPopulated = false;\n    GridSettings.prototype.data = data;\n\n    if (Array.isArray(priv.settings.dataSchema) || Array.isArray(data[0])) {\n      instance.dataType = 'array';\n    }\n    else if (typeof priv.settings.dataSchema === 'function') {\n      instance.dataType = 'function';\n    }\n    else {\n      instance.dataType = 'object';\n    }\n\n    datamap = new Handsontable.DataMap(instance, priv, GridSettings);\n\n    clearCellSettingCache();\n\n    grid.adjustRowsAndCols();\n    Handsontable.hooks.run(instance, 'afterLoadData');\n\n    if (priv.firstRun) {\n      priv.firstRun = [null, 'loadData'];\n    }\n    else {\n      Handsontable.hooks.run(instance, 'afterChange', null, 'loadData');\n      instance.render();\n    }\n\n    priv.isPopulated = true;\n\n\n\n    function clearCellSettingCache() {\n      priv.cellSettings.length = 0;\n    }\n  };\n\n  /**\n   * Return the current data object (the same that was passed by `data` configuration option or `loadData` method). Optionally you can provide cell range `r`, `c`, `r2`, `c2` to get only a fragment of grid data\n   * @public\n   * @param {Number} r (Optional) From row\n   * @param {Number} c (Optional) From col\n   * @param {Number} r2 (Optional) To row\n   * @param {Number} c2 (Optional) To col\n   * @return {Array|Object}\n   */\n  this.getData = function (r, c, r2, c2) {\n    if (typeof r === 'undefined') {\n      return datamap.getAll();\n    } else {\n      return datamap.getRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2), datamap.DESTINATION_RENDERER);\n    }\n  };\n\n  this.getCopyableData = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new WalkontableCellCoords(startRow, startCol), new WalkontableCellCoords(endRow, endCol));\n  };\n\n  /**\n   * Update settings\n   * @public\n   */\n  this.updateSettings = function (settings, init) {\n    var i, clen;\n\n    if (typeof settings.rows !== \"undefined\") {\n      throw new Error(\"'rows' setting is no longer supported. do you mean startRows, minRows or maxRows?\");\n    }\n    if (typeof settings.cols !== \"undefined\") {\n      throw new Error(\"'cols' setting is no longer supported. do you mean startCols, minCols or maxCols?\");\n    }\n\n    for (i in settings) {\n      if (i === 'data') {\n        continue; //loadData will be triggered later\n      }\n      else {\n        if (Handsontable.hooks.hooks[i] !== void 0 || Handsontable.hooks.legacy[i] !== void 0) {\n          if (typeof settings[i] === 'function' || Array.isArray(settings[i])) {\n            instance.addHook(i, settings[i]);\n          }\n        }\n        else {\n          // Update settings\n          if (!init && settings.hasOwnProperty(i)) {\n            GridSettings.prototype[i] = settings[i];\n          }\n        }\n      }\n    }\n\n    // Load data or create data map\n    if (settings.data === void 0 && priv.settings.data === void 0) {\n      instance.loadData(null); //data source created just now\n    }\n    else if (settings.data !== void 0) {\n      instance.loadData(settings.data); //data source given as option\n    }\n    else if (settings.columns !== void 0) {\n      datamap.createMap();\n    }\n\n    // Init columns constructors configuration\n    clen = instance.countCols();\n\n    //Clear cellSettings cache\n    priv.cellSettings.length = 0;\n\n    if (clen > 0) {\n      var proto, column;\n\n      for (i = 0; i < clen; i++) {\n        priv.columnSettings[i] = Handsontable.helper.columnFactory(GridSettings, priv.columnsSettingConflicts);\n\n        // shortcut for prototype\n        proto = priv.columnSettings[i].prototype;\n\n        // Use settings provided by user\n        if (GridSettings.prototype.columns) {\n          column = GridSettings.prototype.columns[i];\n          Handsontable.helper.extend(proto, column);\n          Handsontable.helper.extend(proto, expandType(column));\n        }\n      }\n    }\n\n    if (typeof settings.cell !== 'undefined') {\n      for(i in settings.cell) {\n        var cell = settings.cell[i];\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      }\n    }\n\n    Handsontable.hooks.run(instance, 'afterCellMetaReset');\n\n    if (typeof settings.className !== \"undefined\") {\n      if (GridSettings.prototype.className) {\n        Handsontable.Dom.removeClass(instance.rootElement,GridSettings.prototype.className);\n//        instance.rootElement.removeClass(GridSettings.prototype.className);\n      }\n      if (settings.className) {\n        Handsontable.Dom.addClass(instance.rootElement,settings.className);\n//        instance.rootElement.addClass(settings.className);\n      }\n    }\n\n    if (typeof settings.height != 'undefined'){\n      var height = settings.height;\n\n      if (typeof height == 'function'){\n        height = height();\n      }\n\n      instance.rootElement.style.height = height + 'px';\n    }\n\n    if (typeof settings.width != 'undefined'){\n      var width = settings.width;\n\n      if (typeof width == 'function'){\n        width = width();\n      }\n\n      instance.rootElement.style.width = width + 'px';\n    }\n\n    if (height){\n      instance.rootElement.style.overflow = 'auto';\n    }\n\n    if (!init) {\n      Handsontable.hooks.run(instance, 'afterUpdateSettings');\n    }\n\n    grid.adjustRowsAndCols();\n    if (instance.view && !priv.firstRun) {\n      instance.forceFullRender = true; //used when data was changed\n      selection.refreshBorders(null, true);\n    }\n  };\n\n  this.getValue = function () {\n    var sel = instance.getSelected();\n    if (GridSettings.prototype.getValue) {\n      if (typeof GridSettings.prototype.getValue === 'function') {\n        return GridSettings.prototype.getValue.call(instance);\n      }\n      else if (sel) {\n        return instance.getData()[sel[0]][GridSettings.prototype.getValue];\n      }\n    }\n    else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n\n  function expandType(obj) {\n    if (!obj.hasOwnProperty('type')) return; //ignore obj.prototype.type\n\n    var type, expandedType = {};\n\n    if (typeof obj.type === 'object') {\n      type = obj.type;\n    }\n    else if (typeof obj.type === 'string') {\n      type = Handsontable.cellTypes[obj.type];\n      if (type === void 0) {\n        throw new Error('You declared cell type \"' + obj.type + '\" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');\n      }\n    }\n\n\n    for (var i in type) {\n      if (type.hasOwnProperty(i) && !obj.hasOwnProperty(i)) {\n        expandedType[i] = type[i];\n      }\n    }\n\n    return expandedType;\n\n  }\n\n  /**\n   * Returns current settings object\n   * @return {Object}\n   */\n  this.getSettings = function () {\n    return priv.settings;\n  };\n\n  /**\n   * Clears grid\n   * @public\n   */\n  this.clear = function () {\n    selection.selectAll();\n    selection.empty();\n  };\n\n  /**\n   * Inserts or removes rows and columns\n   * @param {String} action See grid.alter for possible values\n   * @param {Number} index\n   * @param {Number} amount\n   * @param {String} [source] Optional. Source of hook runner.\n   * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n   * @public\n   */\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n\n  /**\n   * Returns <td> element corresponding to params row, col\n   * @param {Number} row\n   * @param {Number} col\n   * @param {Boolean} topmost\n   * @public\n   * @return {Element}\n   */\n  this.getCell = function (row, col, topmost) {\n    return instance.view.getCellAtCoords(new WalkontableCellCoords(row, col), topmost);\n  };\n\n  /**\n   * Returns coordinates for the provided element\n   * @param elem\n   * @returns {WalkontableCellCoords|*}\n   */\n  this.getCoords = function(elem) {\n    return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable, elem);\n  };\n\n  /**\n   * Returns property name associated with column number\n   * @param {Number} col\n   * @public\n   * @return {String}\n   */\n  this.colToProp = function (col) {\n    return datamap.colToProp(col);\n  };\n\n  /**\n   * Returns column number associated with property name\n   * @param {String} prop\n   * @public\n   * @return {Number}\n   */\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n\n  /**\n   * Return value at `row`, `col`\n   * @param {Number} row\n   * @param {Number} col\n   * @public\n   * @return value (mixed data type)\n   */\n  this.getDataAtCell = function (row, col) {\n    return datamap.get(row, datamap.colToProp(col));\n  };\n\n  /**\n   * Return value at `row`, `prop`\n   * @param {Number} row\n   * @param {String} prop\n   * @public\n   * @return value (mixed data type)\n   */\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n\n  /**\n   * Return value at `col`, where `col` is the visible index of the column\n   * @param {Number} col\n   * @public\n   * @return {Array} value (mixed data type)\n   */\n  this.getDataAtCol = function (col) {\n    var out = [];\n    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, col), new WalkontableCellCoords(priv.settings.data.length - 1, col), datamap.DESTINATION_RENDERER));\n  };\n\n  /**\n   * Return value at `prop`\n   * @param {String} prop\n   * @public\n   * @return {Array} value (mixed data type)\n   */\n  this.getDataAtProp = function (prop) {\n    var out = [];\n    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, datamap.propToCol(prop)), new WalkontableCellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER));\n  };\n\n  /**\n   * Return original source values at 'col'\n   * @param {Number} col\n   * @public\n   * @returns value (mixed data type)\n   */\n  this.getSourceDataAtCol = function (col) {\n    var out = [],\n        data = priv.settings.data;\n\n    for (var i = 0; i < data.length; i++) {\n      out.push(data[i][col]);\n    }\n\n    return out;\n  };\n\n  /**\n   * Return original source values at 'row'\n   * @param {Number} row\n   * @public\n   * @returns value {mixed data type}\n   */\n  this.getSourceDataAtRow = function (row) {\n    return priv.settings.data[row];\n  };\n\n  /**\n   * Return value at `row`\n   * @param {Number} row\n   * @public\n   * @return value (mixed data type)\n   */\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new WalkontableCellCoords(row, 0), new WalkontableCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0];\n  };\n\n  /***\n   *  Remove \"key\" property object from cell meta data corresponding to params row,col\n   * @param {Number} row\n   * @param {Number} col\n   * @param {String} key\n   */\n  this.removeCellMeta = function(row, col, key) {\n    var cellMeta = instance.getCellMeta(row, col);\n    if(cellMeta[key] != undefined){\n      delete priv.cellSettings[row][col][key];\n    }\n  };\n\n  /**\n   * Set cell meta data object to corresponding params row, col\n   * @param {Number} row\n   * @param {Number} col\n   * @param {Object} prop\n   */\n  this.setCellMetaObject = function (row, col, prop) {\n    if (typeof prop === 'object') {\n      for (var key in prop) {\n        var value = prop[key];\n        this.setCellMeta(row, col, key, value);\n      }\n    }\n  };\n\n  /**\n   * Sets cell meta data object \"key\" corresponding to params row, col\n   * @param {Number} row\n   * @param {Number} col\n   * @param {String} key\n   * @param {String} val\n   *\n   */\n  this.setCellMeta = function (row, col, key, val) {\n    if (!priv.cellSettings[row]) {\n      priv.cellSettings[row] = [];\n    }\n    if (!priv.cellSettings[row][col]) {\n      priv.cellSettings[row][col] = new priv.columnSettings[col]();\n    }\n    priv.cellSettings[row][col][key] = val;\n    Handsontable.hooks.run(instance, 'afterSetCellMeta', row, col, key, val);\n  };\n\n  /**\n   * Returns cell meta data object corresponding to params row, col\n   * @param {Number} row\n   * @param {Number} col\n   * @public\n   * @return {Object}\n   */\n  this.getCellMeta = function (row, col) {\n    var prop = datamap.colToProp(col)\n      , cellProperties;\n\n    row = translateRowIndex(row);\n    col = translateColIndex(col);\n\n    if (!priv.columnSettings[col]) {\n      priv.columnSettings[col] = Handsontable.helper.columnFactory(GridSettings, priv.columnsSettingConflicts);\n    }\n\n    if (!priv.cellSettings[row]) {\n      priv.cellSettings[row] = [];\n    }\n    if (!priv.cellSettings[row][col]) {\n      priv.cellSettings[row][col] = new priv.columnSettings[col]();\n    }\n\n    cellProperties = priv.cellSettings[row][col]; //retrieve cellProperties from cache\n\n    cellProperties.row = row;\n    cellProperties.col = col;\n    cellProperties.prop = prop;\n    cellProperties.instance = instance;\n\n    Handsontable.hooks.run(instance, 'beforeGetCellMeta', row, col, cellProperties);\n    Handsontable.helper.extend(cellProperties, expandType(cellProperties)); //for `type` added in beforeGetCellMeta\n\n    if (cellProperties.cells) {\n      var settings = cellProperties.cells.call(cellProperties, row, col, prop);\n\n      if (settings) {\n        Handsontable.helper.extend(cellProperties, settings);\n        Handsontable.helper.extend(cellProperties, expandType(settings)); //for `type` added in cells\n      }\n    }\n\n    Handsontable.hooks.run(instance, 'afterGetCellMeta', row, col, cellProperties);\n\n    return cellProperties;\n  };\n\n  /**\n   * If displayed rows order is different than the order of rows stored in memory (i.e. sorting is applied)\n   * we need to translate logical (stored) row index to physical (displayed) index.\n   * @param row - original row index\n   * @returns {int} translated row index\n   */\n  function translateRowIndex(row){\n    return Handsontable.hooks.execute(instance, 'modifyRow', row);\n  }\n\n  /**\n   * If displayed columns order is different than the order of columns stored in memory (i.e. column were moved using manualColumnMove plugin)\n   * we need to translate logical (stored) column index to physical (displayed) index.\n   * @param col - original column index\n   * @returns {int} - translated column index\n   */\n  function translateColIndex(col){\n    return Handsontable.hooks.execute(instance, 'modifyCol', col); // warning: this must be done after datamap.colToProp\n  }\n\n  var rendererLookup = Handsontable.helper.cellMethodLookupFactory('renderer');\n  this.getCellRenderer = function (row, col) {\n    var renderer = rendererLookup.call(this, row, col);\n    return Handsontable.renderers.getRenderer(renderer);\n\n  };\n\n  this.getCellEditor = Handsontable.helper.cellMethodLookupFactory('editor');\n\n  this.getCellValidator = Handsontable.helper.cellMethodLookupFactory('validator');\n\n\n  /**\n   * Validates all cells using their validator functions and calls callback when finished. Does not render the view\n   * @param callback\n   */\n  this.validateCells = function (callback) {\n    var waitingForValidator = new ValidatorsQueue();\n    waitingForValidator.onQueueEmpty = callback;\n\n    var i = instance.countRows() - 1;\n    while (i >= 0) {\n      var j = instance.countCols() - 1;\n      while (j >= 0) {\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function () {\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j--;\n      }\n      i--;\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n\n  /**\n   * Return array of row headers (if they are enabled). If param `row` given, return header at given row as string\n   * @param {Number} row (Optional)\n   * @return {Array|String}\n   */\n  this.getRowHeader = function (row) {\n    if (row === void 0) {\n      var out = [];\n      for (var i = 0, ilen = instance.countRows(); i < ilen; i++) {\n        out.push(instance.getRowHeader(i));\n      }\n      return out;\n    }\n    else if (Array.isArray(priv.settings.rowHeaders) && priv.settings.rowHeaders[row] !== void 0) {\n      return priv.settings.rowHeaders[row];\n    }\n    else if (typeof priv.settings.rowHeaders === 'function') {\n      return priv.settings.rowHeaders(row);\n    }\n    else if (priv.settings.rowHeaders && typeof priv.settings.rowHeaders !== 'string' && typeof priv.settings.rowHeaders !== 'number') {\n      return row + 1;\n    }\n    else {\n      return priv.settings.rowHeaders;\n    }\n  };\n\n  /**\n   * Returns information of this table is configured to display row headers\n   * @returns {boolean}\n   */\n  this.hasRowHeaders = function () {\n    return !!priv.settings.rowHeaders;\n  };\n\n  /**\n   * Returns information of this table is configured to display column headers\n   * @returns {boolean}\n   */\n  this.hasColHeaders = function () {\n    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) { //Polymer has empty value = null\n      return !!priv.settings.colHeaders;\n    }\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Return array of column headers (if they are enabled). If param `col` given, return header at given column as string\n   * @param {Number} col (Optional)\n   * @return {Array|String}\n   */\n  this.getColHeader = function (col) {\n    if (col === void 0) {\n      var out = [];\n      for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n      return out;\n    }\n    else {\n      var baseCol = col;\n      col = Handsontable.hooks.execute(instance, 'modifyCol', col);\n\n      if (priv.settings.columns && priv.settings.columns[col] && priv.settings.columns[col].title) {\n        return priv.settings.columns[col].title;\n      }\n      else if (Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[col] !== void 0) {\n        return priv.settings.colHeaders[col];\n      }\n      else if (typeof priv.settings.colHeaders === 'function') {\n        return priv.settings.colHeaders(col);\n      }\n      else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {\n        return Handsontable.helper.spreadsheetColumnLabel(baseCol); //see #1458\n      }\n      else {\n        return priv.settings.colHeaders;\n      }\n    }\n  };\n\n  /**\n   * Return column width from settings (no guessing). Private use intended\n   * @param {Number} col\n   * @return {Number}\n   */\n  this._getColWidthFromSettings = function (col) {\n    var cellProperties = instance.getCellMeta(0, col);\n    var width = cellProperties.width;\n    if (width === void 0 || width === priv.settings.width) {\n      width = cellProperties.colWidths;\n    }\n    if (width !== void 0 && width !== null) {\n      switch (typeof width) {\n        case 'object': //array\n          width = width[col];\n          break;\n\n        case 'function':\n          width = width(col);\n          break;\n      }\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n    return width;\n  };\n\n  /**\n   * Return column width\n   * @param {Number} col\n   * @return {Number}\n   */\n  this.getColWidth = function (col) {\n    var width = instance._getColWidthFromSettings(col);\n    if (!width) {\n      width = 50;\n    }\n    width = Handsontable.hooks.execute(instance, 'modifyColWidth', width, col);\n    return width;\n  };\n\n  /**\n   * Return row height from settings (no guessing). Private use intended\n   * @param {Number} row\n   * @return {Number}\n   */\n  this._getRowHeightFromSettings= function (row) {\n    /* inefficient\n    var cellProperties = instance.getCellMeta(0, row);\n    var height = cellProperties.height;\n    if (height === void 0 || height === priv.settings.height) {\n      height = cellProperties.rowHeights;\n    }\n    */\n    var height = priv.settings.rowHeights; //only uses grid settings\n    if (height !== void 0 && height !== null) {\n      switch (typeof height) {\n        case 'object': //array\n          height = height[row];\n          break;\n\n        case 'function':\n          height = height(row);\n          break;\n      }\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n    return height;\n  };\n\n  /**\n   * Return row height\n   * @param {Number} row\n   * @return {Number}\n   */\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n    height = Handsontable.hooks.execute(instance, 'modifyRowHeight', height, row);\n    return height;\n  };\n\n  /**\n   * Return total number of rows in grid\n   * @return {Number}\n   */\n  this.countRows = function () {\n    return priv.settings.data.length;\n  };\n\n  /**\n   * Return total number of columns in grid\n   * @return {Number}\n   */\n  this.countCols = function () {\n    if (instance.dataType === 'object' || instance.dataType === 'function') {\n      if (priv.settings.columns && priv.settings.columns.length) {\n        return priv.settings.columns.length;\n      }\n      else {\n        return datamap.colToPropCache.length;\n      }\n    }\n    else if (instance.dataType === 'array') {\n      if (priv.settings.columns && priv.settings.columns.length) {\n        return priv.settings.columns.length;\n      }\n      else if (priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length) {\n        return priv.settings.data[0].length;\n      }\n      else {\n        return 0;\n      }\n    }\n  };\n\n  /**\n   * Return index of first rendered row\n   * @return {Number}\n   */\n  this.rowOffset = function () {\n    return instance.view.wt.wtTable.getFirstRenderedRow();\n  };\n\n  /**\n   * Return index of first visible column\n   * @return {Number}\n   */\n  this.colOffset = function () {\n    return instance.view.wt.wtTable.getFirstRenderedColumn();\n  };\n\n  /**\n   * Return number of rendered rows (including rows partially or fully rendered outside viewport). Returns -1 if table is not visible\n   * @return {Number}\n   */\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n\n  /**\n   * Return number of visible rows (rendered rows that fully fit inside viewport)). Returns -1 if table is not visible\n   * @return {Number}\n   */\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n\n  /**\n   * Return number of rendered columns (including columns partially or fully rendered outside viewport). Returns -1 if table is not visible\n   * @return {Number}\n   */\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n\n  /**\n   * Return number of visible columns. Returns -1 if table is not visible\n   * @return {Number}\n   */\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : - 1;\n  };\n\n  /**\n   * Return number of empty rows\n   * @return {Boolean} ending If true, will only count empty rows at the end of the data source\n   */\n  this.countEmptyRows = function (ending) {\n    var i = instance.countRows() - 1\n      , empty = 0\n      , row;\n    while (i >= 0) {\n      row = Handsontable.hooks.execute(this, 'modifyRow', i);\n      if (instance.isEmptyRow(row)) {\n        empty++;\n      }\n      else if (ending) {\n        break;\n      }\n      i--;\n    }\n    return empty;\n  };\n\n  /**\n   * Return number of empty columns\n   * @return {Boolean} ending If true, will only count empty columns at the end of the data source row\n   */\n  this.countEmptyCols = function (ending) {\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n\n    var i = instance.countCols() - 1\n      , empty = 0;\n    while (i >= 0) {\n      if (instance.isEmptyCol(i)) {\n        empty++;\n      }\n      else if (ending) {\n        break;\n      }\n      i--;\n    }\n    return empty;\n  };\n\n  /**\n   * Return true if the row at the given index is empty, false otherwise\n   * @param {Number} r Row index\n   * @return {Boolean}\n   */\n  this.isEmptyRow = function (r) {\n    return priv.settings.isEmptyRow.call(instance, r);\n  };\n\n  /**\n   * Return true if the column at the given index is empty, false otherwise\n   * @param {Number} c Column index\n   * @return {Boolean}\n   */\n  this.isEmptyCol = function (c) {\n    return priv.settings.isEmptyCol.call(instance, c);\n  };\n\n  /**\n   * Selects cell on grid. Optionally selects range to another cell\n   * @param {Number} row\n   * @param {Number} col\n   * @param {Number} [endRow]\n   * @param {Number} [endCol]\n   * @param {Boolean} [scrollToCell=true] If true, viewport will be scrolled to the selection\n   * @public\n   * @return {Boolean}\n   */\n  this.selectCell = function (row, col, endRow, endCol, scrollToCell) {\n    if (typeof row !== 'number' || row < 0 || row >= instance.countRows()) {\n      return false;\n    }\n    if (typeof col !== 'number' || col < 0 || col >= instance.countCols()) {\n      return false;\n    }\n    if (typeof endRow !== \"undefined\") {\n      if (typeof endRow !== 'number' || endRow < 0 || endRow >= instance.countRows()) {\n        return false;\n      }\n      if (typeof endCol !== 'number' || endCol < 0 || endCol >= instance.countCols()) {\n        return false;\n      }\n    }\n    var coords = new WalkontableCellCoords(row, col);\n    priv.selRange = new WalkontableCellRange(coords, coords, coords);\n    if (document.activeElement && document.activeElement !== document.documentElement && document.activeElement !== document.body) {\n      document.activeElement.blur(); //needed or otherwise prepare won't focus the cell. selectionSpec tests this (should move focus to selected cell)\n    }\n    instance.listen();\n    if (typeof endRow === \"undefined\") {\n      selection.setRangeEnd(priv.selRange.from, scrollToCell);\n    }\n    else {\n      selection.setRangeEnd(new WalkontableCellCoords(endRow, endCol), scrollToCell);\n    }\n\n    instance.selection.finish();\n    return true;\n  };\n\n  this.selectCellByProp = function (row, prop, endRow, endProp, scrollToCell) {\n    arguments[1] = datamap.propToCol(arguments[1]);\n    if (typeof arguments[3] !== \"undefined\") {\n      arguments[3] = datamap.propToCol(arguments[3]);\n    }\n    return instance.selectCell.apply(instance, arguments);\n  };\n\n  /**\n   * Deselects current sell selection on grid\n   * @public\n   */\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n\n  /**\n   * Remove grid from DOM\n   * @public\n   */\n  this.destroy = function () {\n\n    instance._clearTimeouts();\n    if (instance.view) { //in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n\n\n    Handsontable.Dom.empty(instance.rootElement);\n    eventManager.clear();\n\n    Handsontable.hooks.run(instance, 'afterDestroy');\n    Handsontable.hooks.destroy(instance);\n\n    for (var i in instance) {\n      if (instance.hasOwnProperty(i)) {\n        //replace instance methods with post mortem\n        if (typeof instance[i] === \"function\") {\n          if (i !== \"runHooks\" && i !== \"runHooksAndReturn\") {\n            instance[i] = postMortem;\n          }\n        }\n        //replace instance properties with null (restores memory)\n        //it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        else if (i !== \"guid\") {\n          instance[i] = null;\n        }\n      }\n    }\n\n\n    //replace private properties with null (restores memory)\n    //it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n    priv = null;\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n    GridSettings = null;\n  };\n\n  /**\n   * Replacement for all methods after Handsotnable was destroyed\n   */\n  function postMortem() {\n    throw new Error(\"This method cannot be called because this Handsontable instance has been destroyed\");\n  }\n\n  /**\n   * Returns active editor object\n   * @returns {Object}\n   */\n  this.getActiveEditor = function(){\n    return editorManager.getActiveEditor();\n  };\n\n  /**\n   * Return Handsontable instance\n   * @public\n   * @return {Object}\n   */\n  this.getInstance = function () {\n    return instance;\n  };\n\n  this.addHook = function (key, fn) {\n    Handsontable.hooks.add(key, fn, instance);\n  };\n\n  this.addHookOnce = function (key, fn) {\n    Handsontable.hooks.once(key, fn, instance);\n  };\n\n  this.removeHook = function (key, fn) {\n    Handsontable.hooks.remove(key, fn, instance);\n  };\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    Handsontable.hooks.run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n\n  this.runHooksAndReturn = function (key, p1, p2, p3, p4, p5, p6) {\n    return Handsontable.hooks.execute(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n\n  this.timeouts = [];\n\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called\n   * @public\n   */\n  this._registerTimeout = function (handle) {\n    this.timeouts.push(handle);\n  };\n\n  /**\n   * Clears all known timeouts\n   * @public\n   */\n  this._clearTimeouts = function () {\n    for(var i = 0, ilen = this.timeouts.length; i<ilen; i++) {\n      clearTimeout(this.timeouts[i]);\n    }\n  };\n\n  /**\n   * Handsontable version\n   */\n  this.version = '0.12.3'; //inserted by grunt from package.json\n};\n\nvar DefaultSettings = function () {};\n\nDefaultSettings.prototype = {\n  data: void 0,\n  dataSchema: void 0,\n  width: void 0,\n  height: void 0,\n  startRows: 5,\n  startCols: 5,\n  rowHeaders: null,\n  colHeaders: null,\n  colWidths: void 0,\n  columns: void 0,\n  cells: void 0,\n  cell: [],\n  minRows: 0,\n  minCols: 0,\n  maxRows: Infinity,\n  maxCols: Infinity,\n  minSpareRows: 0,\n  minSpareCols: 0,\n  allowInsertRow:true,\n  allowInsertColumn: true,\n  allowRemoveRow: true,\n  allowRemoveColumn: true,\n  multiSelect: true,\n  fillHandle: true,\n  fixedRowsTop: 0,\n  fixedColumnsLeft: 0,\n  outsideClickDeselects: true,\n  enterBeginsEditing: true,\n  enterMoves: {row: 1, col: 0},\n  tabMoves: {row: 0, col: 1},\n  autoWrapRow: false,\n  autoWrapCol: false,\n  copyRowsLimit: 1000,\n  copyColsLimit: 1000,\n  pasteMode: 'overwrite',\n  currentRowClassName: void 0,\n  currentColClassName: void 0,\n  stretchH: 'none',\n  isEmptyRow: function (r) {\n    var val;\n    for (var c = 0, clen = this.countCols(); c < clen; c++) {\n      val = this.getDataAtCell(r, c);\n      if (val !== '' && val !== null && typeof val !== 'undefined') {\n        return false;\n      }\n    }\n    return true;\n  },\n  isEmptyCol: function (c) {\n    var val;\n    for (var r = 0, rlen = this.countRows(); r < rlen; r++) {\n      val = this.getDataAtCell(r, c);\n      if (val !== '' && val !== null && typeof val !== 'undefined') {\n        return false;\n      }\n    }\n    return true;\n  },\n  observeDOMVisibility: true,\n  allowInvalid: true,\n  invalidCellClassName: 'htInvalid',\n  placeholder: false,\n  placeholderCellClassName: 'htPlaceholder',\n  readOnlyCellClassName: 'htDimmed',\n  commentedCellClassName: 'htCommentCell',\n  fragmentSelection: false,\n  readOnly: false,\n  type: 'text',\n  copyable: true,\n  debug: false, //shows debug overlays in Walkontable\n  wordWrap: true,\n  noWordWrapClassName: 'htNoWrap',\n  contextMenu: void 0,\n  undo: void 0,\n  columnSorting: void 0,\n  manualColumnMove: void 0,\n  manualColumnResize: void 0,\n  manualRowMove: void 0,\n  manualRowResize: void 0,\n  viewportRowRenderingOffset: 10, //number of rows to be prerendered before and after the viewport\n  viewportColumnRenderingOffset: 10, // number of columns to be prerendered before and after the viewport\n  groups: void 0\n};\nHandsontable.DefaultSettings = DefaultSettings;\n\n(function (window) {\n  'use strict';\n\n  function MultiMap() {\n    var map = {\n      arrayMap: [],\n      weakMap: new WeakMap()\n    };\n\n    return {\n      'get': function (key) {\n        if (canBeAnArrayMapKey(key)) {\n          return map.arrayMap[key];\n        } else if (canBeAWeakMapKey(key)) {\n          return map.weakMap.get(key);\n        }\n      },\n\n      'set': function (key, value) {\n        if (canBeAnArrayMapKey(key)) {\n          map.arrayMap[key] = value;\n        } else if (canBeAWeakMapKey(key)) {\n          map.weakMap.set(key, value);\n        } else {\n          throw new Error('Invalid key type');\n        }\n\n\n      },\n\n      'delete': function (key) {\n        if (canBeAnArrayMapKey(key)) {\n          delete map.arrayMap[key];\n        } else if (canBeAWeakMapKey(key)) {\n          map.weakMap['delete'](key);  //Delete must be called using square bracket notation, because IE8 does not handle using `delete` with dot notation\n        }\n      }\n    };\n\n\n\n    function canBeAnArrayMapKey(obj){\n      return obj !== null && !isNaNSymbol(obj) && (typeof obj == 'string' || typeof obj == 'number');\n    }\n\n    function canBeAWeakMapKey(obj){\n      return obj !== null && (typeof obj == 'object' || typeof obj == 'function');\n    }\n\n    function isNaNSymbol(obj){\n      return obj !== obj; // NaN === NaN is always false\n    }\n\n  }\n\n  if (!window.MultiMap){\n    window.MultiMap = MultiMap;\n  }\n\n})(window);\n/**\n * DOM helper optimized for maximum performance\n * It is recommended for Handsontable plugins and renderers, because it is much faster than jQuery\n * @type {Object}\n */\nif(!window.Handsontable) {\n  var Handsontable = {}; //required because Walkontable test suite uses this class directly\n}\nHandsontable.Dom = {};\n\n\nHandsontable.Dom.enableImmediatePropagation = function (event) {\n  if (event != null && event.isImmediatePropagationEnabled == null) {\n    event.stopImmediatePropagation = function () {\n      this.isImmediatePropagationEnabled = false;\n      this.cancelBubble = true;\n    };\n    event.isImmediatePropagationEnabled = true;\n    event.isImmediatePropagationStopped = function () {\n      return !this.isImmediatePropagationEnabled;\n    };\n  }\n};\n\n//goes up the DOM tree (including given element) until it finds an element that matches the nodeName\nHandsontable.Dom.closest = function (elem, nodeNames, until) {\n  while (elem != null && elem !== until) {\n    if (elem.nodeType === 1 && nodeNames.indexOf(elem.nodeName) > -1) {\n      return elem;\n    }\n    elem = elem.parentNode;\n  }\n  return null;\n};\n\n/**\n * Goes up the DOM tree and checks if element is child of another element\n * @param child Child element\n * @param {Object|string} parent Parent element OR selector of the parent element. If classname provided, function returns true for the first occurance of element with that class.\n * @returns {boolean}\n */\nHandsontable.Dom.isChildOf = function (child, parent) {\n  var node = child.parentNode;\n  var queriedParents = [];\n  if(typeof parent === \"string\") {\n    queriedParents = Array.prototype.slice.call(document.querySelectorAll(parent), 0);\n  } else {\n    queriedParents.push(parent);\n  }\n\n  while (node != null) {\n    if (queriedParents.indexOf(node) > - 1) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n};\n\n/**\n * Counts index of element within its parent\n * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true for Walkotnable\n * Otherwise would need to check for nodeType or use previousElementSibling\n * @see http://jsperf.com/sibling-index/10\n * @param {Element} elem\n * @return {Number}\n */\nHandsontable.Dom.index = function (elem) {\n  var i = 0;\n  if (elem.previousSibling) {\n    while (elem = elem.previousSibling) {\n      ++i\n    }\n  }\n  return i;\n};\n\nif (document.documentElement.classList) {\n  // HTML5 classList API\n  Handsontable.Dom.hasClass = function (ele, cls) {\n    return ele.classList.contains(cls);\n  };\n\n  Handsontable.Dom.addClass = function (ele, cls) {\n    if (cls) {\n      ele.classList.add(cls);\n    }\n  };\n\n  Handsontable.Dom.removeClass = function (ele, cls) {\n    ele.classList.remove(cls);\n  };\n}\nelse {\n  //http://snipplr.com/view/3561/addclass-removeclass-hasclass/\n  Handsontable.Dom.hasClass = function (ele, cls) {\n    return ele.className.match(new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)'));\n  };\n\n  Handsontable.Dom.addClass = function (ele, cls) {\n    if(ele.className == \"\") ele.className = cls;\n    else if (!this.hasClass(ele, cls)) ele.className += \" \" + cls;\n  };\n\n  Handsontable.Dom.removeClass = function (ele, cls) {\n    if (this.hasClass(ele, cls)) { //is this really needed?\n      var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n      ele.className = ele.className.replace(reg, ' ').trim(); //String.prototype.trim is defined in polyfill.js\n    }\n  };\n}\n\nHandsontable.Dom.removeTextNodes = function (elem, parent) {\n  if (elem.nodeType === 3) {\n    parent.removeChild(elem); //bye text nodes!\n  }\n  else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(elem.nodeName) > -1) {\n    var childs = elem.childNodes;\n    for (var i = childs.length - 1; i >= 0; i--) {\n      this.removeTextNodes(childs[i], elem);\n    }\n  }\n};\n\n/**\n * Remove childs function\n * WARNING - this doesn't unload events and data attached by jQuery\n * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9\n * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method\n * @param element\n * @returns {void}\n */\n//\nHandsontable.Dom.empty = function (element) {\n  var child;\n  while (child = element.lastChild) {\n    element.removeChild(child);\n  }\n};\n\nHandsontable.Dom.HTML_CHARACTERS = /(<(.*)>|&(.*);)/;\n\n/**\n * Insert content into element trying avoid innerHTML method.\n * @return {void}\n */\nHandsontable.Dom.fastInnerHTML = function (element, content) {\n  if (this.HTML_CHARACTERS.test(content)) {\n    element.innerHTML = content;\n  }\n  else {\n    this.fastInnerText(element, content);\n  }\n};\n\n/**\n * Insert text content into element\n * @return {void}\n */\nif (document.createTextNode('test').textContent) { //STANDARDS\n  Handsontable.Dom.fastInnerText = function (element, content) {\n    var child = element.firstChild;\n    if (child && child.nodeType === 3 && child.nextSibling === null) {\n      //fast lane - replace existing text node\n      //http://jsperf.com/replace-text-vs-reuse\n      child.textContent = content;\n    }\n    else {\n      //slow lane - empty element and insert a text node\n      this.empty(element);\n      element.appendChild(document.createTextNode(content));\n    }\n  };\n}\nelse { //IE8\n  Handsontable.Dom.fastInnerText = function (element, content) {\n    var child = element.firstChild;\n    if (child && child.nodeType === 3 && child.nextSibling === null) {\n      //fast lane - replace existing text node\n      //http://jsperf.com/replace-text-vs-reuse\n      child.data = content;\n    }\n    else {\n      //slow lane - empty element and insert a text node\n      this.empty(element);\n      element.appendChild(document.createTextNode(content));\n    }\n  };\n}\n\n/**\n * Returns true if element is attached to the DOM and visible, false otherwise\n * @param elem\n * @returns {boolean}\n */\nHandsontable.Dom.isVisible = function (elem) {\n  var next = elem;\n  while (next !== document.documentElement) { //until <html> reached\n    if (next === null) { //parent detached from DOM\n      return false;\n    }\n    else if (next.nodeType === 11) {  //nodeType == 1 -> DOCUMENT_FRAGMENT_NODE\n      if (next.host) { //this is Web Components Shadow DOM\n        //see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation\n        //according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet\n        if (next.host.impl) { //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled\n          return Handsontable.Dom.isVisible(next.host.impl);\n        }\n        else if (next.host) { //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled\n          return Handsontable.Dom.isVisible(next.host);\n        }\n        else {\n          throw new Error(\"Lost in Web Components world\");\n        }\n      }\n      else {\n        return false; //this is a node detached from document in IE8\n      }\n    }\n    else if (next.style.display === 'none') {\n      return false;\n    }\n    next = next.parentNode;\n  }\n  return true;\n};\n\n/**\n * Returns elements top and left offset relative to the document. Function is not compatible with jQuery offset.\n *\n * @param {HTMLElement} elem\n * @return {Object} Returns object with `top` and `left` props\n */\nHandsontable.Dom.offset = function (elem) {\n  var offsetLeft,\n    offsetTop,\n    lastElem,\n    docElem,\n    box;\n\n  docElem = document.documentElement;\n\n  if (this.hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {\n    // fixes problem with Firefox ignoring <caption> in TABLE offset (see also Handsontable.Dom.outerHeight)\n    // http://jsperf.com/offset-vs-getboundingclientrect/8\n    box = elem.getBoundingClientRect();\n\n    return {\n      top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n      left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n    };\n  }\n  offsetLeft = elem.offsetLeft;\n  offsetTop = elem.offsetTop;\n  lastElem = elem;\n\n  while (elem = elem.offsetParent) {\n    // from my observation, document.body always has scrollLeft/scrollTop == 0\n    if (elem === document.body) {\n      break;\n    }\n    offsetLeft += elem.offsetLeft;\n    offsetTop += elem.offsetTop;\n    lastElem = elem;\n  }\n\n  //slow - http://jsperf.com/offset-vs-getboundingclientrect/6\n  if (lastElem && lastElem.style.position === 'fixed') {\n    //if(lastElem !== document.body) { //faster but does gives false positive in Firefox\n    offsetLeft += window.pageXOffset || docElem.scrollLeft;\n    offsetTop += window.pageYOffset || docElem.scrollTop;\n  }\n\n  return {\n    left: offsetLeft,\n    top: offsetTop\n  };\n};\n\nHandsontable.Dom.getWindowScrollTop = function () {\n  var res = window.scrollY;\n  if (res == void 0) { //IE8-11\n    res = document.documentElement.scrollTop;\n  }\n  return res;\n};\n\nHandsontable.Dom.getWindowScrollLeft = function () {\n  var res = window.scrollX;\n  if (res == void 0) { //IE8-11\n    res = document.documentElement.scrollLeft;\n  }\n  return res;\n};\n\nHandsontable.Dom.getScrollTop = function (elem) {\n  if (elem === window) {\n    return Handsontable.Dom.getWindowScrollTop(elem);\n  }\n  else {\n    return elem.scrollTop;\n  }\n};\n\nHandsontable.Dom.getScrollLeft = function (elem) {\n  if (elem === window) {\n    return Handsontable.Dom.getWindowScrollLeft(elem);\n  }\n  else {\n    return elem.scrollLeft;\n  }\n};\n\nHandsontable.Dom.getComputedStyle = function (elem) {\n  return elem.currentStyle || document.defaultView.getComputedStyle(elem);\n};\n\nHandsontable.Dom.outerWidth = function (elem) {\n  return elem.offsetWidth;\n};\n\nHandsontable.Dom.outerHeight = function (elem) {\n  if (this.hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {\n    //fixes problem with Firefox ignoring <caption> in TABLE.offsetHeight\n    //jQuery (1.10.1) still has this unsolved\n    //may be better to just switch to getBoundingClientRect\n    //http://bililite.com/blog/2009/03/27/finding-the-size-of-a-table/\n    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0089.html\n    //http://bugs.jquery.com/ticket/2196\n    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0140.html#start140\n    return elem.offsetHeight + elem.firstChild.offsetHeight;\n  }\n  else {\n    return elem.offsetHeight;\n  }\n};\n\nHandsontable.Dom.innerHeight = function (elem) {\n  return elem.clientHeight || elem.innerHeight;\n};\n\nHandsontable.Dom.innerWidth = function (elem) {\n  return elem.clientWidth || elem.innerWidth;\n};\n\nHandsontable.Dom.addEvent = function(element, event, callback) {\n  if (window.addEventListener) {\n    element.addEventListener(event, callback, false)\n  } else {\n    element.attachEvent('on' + event, callback);\n  }\n};\n\nHandsontable.Dom.removeEvent = function(element, event, callback) {\n  if (window.removeEventListener) {\n    element.removeEventListener(event, callback, false);\n  } else {\n    element.detachEvent('on' + event, callback);\n  }\n};\n\n\n(function () {\n  var hasCaptionProblem;\n\n  function detectCaptionProblem() {\n    var TABLE = document.createElement('TABLE');\n    TABLE.style.borderSpacing = 0;\n    TABLE.style.borderWidth = 0;\n    TABLE.style.padding = 0;\n    var TBODY = document.createElement('TBODY');\n    TABLE.appendChild(TBODY);\n    TBODY.appendChild(document.createElement('TR'));\n    TBODY.firstChild.appendChild(document.createElement('TD'));\n    TBODY.firstChild.firstChild.innerHTML = '<tr><td>t<br>t</td></tr>';\n\n    var CAPTION = document.createElement('CAPTION');\n    CAPTION.innerHTML = 'c<br>c<br>c<br>c';\n    CAPTION.style.padding = 0;\n    CAPTION.style.margin = 0;\n    TABLE.insertBefore(CAPTION, TBODY);\n\n    document.body.appendChild(TABLE);\n    hasCaptionProblem = (TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight); //boolean\n    document.body.removeChild(TABLE);\n  }\n\n  Handsontable.Dom.hasCaptionProblem = function () {\n    if (hasCaptionProblem === void 0) {\n      detectCaptionProblem();\n    }\n    return hasCaptionProblem;\n  };\n\n  /**\n   * Returns caret position in text input\n   * @author http://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea\n   * @return {Number}\n   */\n  Handsontable.Dom.getCaretPosition = function (el) {\n    if (el.selectionStart) {\n      return el.selectionStart;\n    }\n    else if (document.selection) { //IE8\n      el.focus();\n      var r = document.selection.createRange();\n      if (r == null) {\n        return 0;\n      }\n      var re = el.createTextRange(),\n        rc = re.duplicate();\n      re.moveToBookmark(r.getBookmark());\n      rc.setEndPoint('EndToStart', re);\n      return rc.text.length;\n    }\n    return 0;\n  };\n\n  /**\n   * Returns end of the selection in text input\n   * @return {Number}\n   */\n  Handsontable.Dom.getSelectionEndPosition = function (el) {\n    if(el.selectionEnd) {\n      return el.selectionEnd;\n    } else if(document.selection) { //IE8\n      var r = document.selection.createRange();\n      if(r == null) {\n        return 0;\n      }\n      var re = el.createTextRange();\n\n      return re.text.indexOf(r.text) + r.text.length;\n    }\n  };\n\n  /**\n   * Sets caret position in text input\n   * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/\n   * @param {Element} el\n   * @param {Number} pos\n   * @param {Number} endPos\n   */\n  Handsontable.Dom.setCaretPosition = function (el, pos, endPos) {\n    if (endPos === void 0) {\n      endPos = pos;\n    }\n    if (el.setSelectionRange) {\n      el.focus();\n      el.setSelectionRange(pos, endPos);\n    }\n    else if (el.createTextRange) { //IE8\n      var range = el.createTextRange();\n      range.collapse(true);\n      range.moveEnd('character', endPos);\n      range.moveStart('character', pos);\n      range.select();\n    }\n  };\n\n  var cachedScrollbarWidth;\n  //http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes\n  function walkontableCalculateScrollbarWidth() {\n    var inner = document.createElement('p');\n    inner.style.width = \"100%\";\n    inner.style.height = \"200px\";\n\n    var outer = document.createElement('div');\n    outer.style.position = \"absolute\";\n    outer.style.top = \"0px\";\n    outer.style.left = \"0px\";\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"200px\";\n    outer.style.height = \"150px\";\n    outer.style.overflow = \"hidden\";\n    outer.appendChild(inner);\n\n    (document.body || document.documentElement).appendChild(outer);\n    var w1 = inner.offsetWidth;\n    outer.style.overflow = 'scroll';\n    var w2 = inner.offsetWidth;\n    if (w1 == w2) w2 = outer.clientWidth;\n\n    (document.body || document.documentElement).removeChild(outer);\n\n    return (w1 - w2);\n  }\n\n  /**\n   * Returns the computed width of the native browser scroll bar\n   * @return {Number} width\n   */\n  Handsontable.Dom.getScrollbarWidth = function () {\n    if (cachedScrollbarWidth === void 0) {\n      cachedScrollbarWidth = walkontableCalculateScrollbarWidth();\n    }\n    return cachedScrollbarWidth;\n  };\n\n  var isIE8 = !(document.createTextNode('test').textContent);\n  Handsontable.Dom.isIE8 = function () {\n    return isIE8;\n  };\n\n  var isIE9 = !!(document.documentMode);\n  Handsontable.Dom.isIE9 = function () {\n    return isIE9;\n  };\n\n  var isSafari = (/Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor));\n  Handsontable.Dom.isSafari = function () {\n    return isSafari;\n  };\n\n  /**\n   * Sets overlay position depending on it's type and used browser\n   */\n  Handsontable.Dom.setOverlayPosition = function (overlayElem, left, top) {\n    if (isIE8 || isIE9) {\n      overlayElem.style.top = top;\n      overlayElem.style.left = left;\n    } else if (isSafari) {\n      overlayElem.style['-webkit-transform'] = 'translate3d(' + left + ',' + top + ',0)';\n    } else {\n      overlayElem.style['transform'] = 'translate3d(' + left + ',' + top + ',0)';\n    }\n  };\n\n  Handsontable.Dom.getCssTransform = function (elem) {\n    var transform;\n\n    if(elem.style['transform'] && (transform = elem.style['transform']) != \"\") {\n      return ['transform', transform];\n    } else if (elem.style['-webkit-transform'] && (transform = elem.style['-webkit-transform']) != \"\") {\n      return ['-webkit-transform', transform];\n    } else {\n      return -1;\n    }\n  };\n\n  Handsontable.Dom.resetCssTransform = function (elem) {\n    if(elem['transform'] && elem['transform'] != \"\") {\n      elem['transform'] = \"\";\n    } else if(elem['-webkit-transform'] && elem['-webkit-transform'] != \"\") {\n      elem['-webkit-transform'] = \"\";\n    }\n  };\n\n})();\n\n\nif(!window.Handsontable){\n  var Handsontable = {};\n}\n\nHandsontable.countEventManagerListeners = 0; //used to debug memory leaks\n\nHandsontable.eventManager = function (instance) {\n  if (!instance) {\n    throw new Error ('instance not defined');\n  }\n\n  if (!instance.eventListeners) {\n    instance.eventListeners = [];\n  }\n\n  var addEvent = function (element, event, callback) {\n\n      var callbackProxy = function (event) {\n        if(event.target == void 0 && event.srcElement != void 0) {\n          if(event.definePoperty) {\n            event.definePoperty('target', {\n              value: event.srcElement\n            });\n          } else {\n            event.target = event.srcElement;\n          }\n        }\n\n        if(event.preventDefault == void 0) {\n          if(event.definePoperty) {\n            event.definePoperty('preventDefault', {\n              value: function() {\n                this.returnValue = false;\n              }\n            });\n          } else {\n            event.preventDefault = function () {\n              this.returnValue = false;\n            }\n          }\n        }\n\n        callback.call(this, event);\n      };\n\n      instance.eventListeners.push({\n        element: element,\n        event: event,\n        callback: callback,\n        callbackProxy: callbackProxy\n      });\n\n      if (window.addEventListener) {\n        element.addEventListener(event, callbackProxy, false)\n      } else {\n        element.attachEvent('on' + event, callbackProxy);\n      }\n\n      Handsontable.countEventManagerListeners++;\n    },\n    removeEvent = function (element, event, callback){\n      var len = instance.eventListeners.length;\n      while (len--) {\n        var tmpEv = instance.eventListeners[len];\n\n        if (tmpEv.event == event && tmpEv.element == element) {\n          if (callback && callback != tmpEv.callback) {\n            continue;\n          }\n\n          instance.eventListeners.splice(len, 1);\n          if (tmpEv.element.removeEventListener) {\n            tmpEv.element.removeEventListener(tmpEv.event, tmpEv.callbackProxy, false);\n          } else {\n            tmpEv.element.detachEvent('on' + tmpEv.event, tmpEv.callbackProxy);\n          }\n\n          Handsontable.countEventManagerListeners--;\n        }\n      }\n    },\n    clearEvents = function () {\n      var len = instance.eventListeners.length;\n      while(len--) {\n       var event = instance.eventListeners[len];\n       removeEvent(event.element, event.event, event.callback);\n      }\n    },\n    fireEvent = function (element, type) {\n      var options = {\n        bubbles: true,\n        cancelable: (type !== \"mousemove\"),\n        view: window,\n        detail: 0,\n        screenX: 0,\n        screenY: 0,\n        clientX: 1,\n        clientY: 1,\n        ctrlKey: false,\n        altKey: false,\n        shiftKey: false,\n        metaKey: false,\n        button: 0,\n        relatedTarget: undefined\n      };\n\n      var event;\n      if ( document.createEvent ) {\n        event = document.createEvent(\"MouseEvents\");\n        event.initMouseEvent(type, options.bubbles, options.cancelable,\n          options.view, options.detail,\n          options.screenX, options.screenY, options.clientX, options.clientY,\n          options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,\n          options.button, options.relatedTarget || document.body.parentNode);\n\n      } else {\n        event = document.createEventObject();\n      }\n\n\n\n      if (element.dispatchEvent) {\n        element.dispatchEvent(event);\n      } else {\n        element.fireEvent('on' + type, event);\n      }\n    };\n\n  return {\n    addEventListener: addEvent,\n    removeEventListener: removeEvent,\n    clear: clearEvents,\n    fireEvent: fireEvent\n  }\n};\n\n/**\n * Handsontable TableView constructor\n * @param {Object} instance\n */\nHandsontable.TableView = function (instance) {\n  var that = this\n\n\n  this.eventManager = Handsontable.eventManager(instance);\n  this.instance = instance;\n  this.settings = instance.getSettings();\n\n\n  var originalStyle = instance.rootElement.getAttribute('style');\n  if(originalStyle) {\n    instance.rootElement.setAttribute('data-originalstyle', originalStyle); //needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions\n  }\n\n  Handsontable.Dom.addClass(instance.rootElement,'handsontable');\n//  instance.rootElement.addClass('handsontable');\n\n  var table = document.createElement('TABLE');\n  table.className = 'htCore';\n  this.THEAD = document.createElement('THEAD');\n  table.appendChild(this.THEAD);\n  this.TBODY = document.createElement('TBODY');\n  table.appendChild(this.TBODY);\n\n  instance.table = table;\n\n\n  instance.container.insertBefore(table, instance.container.firstChild);\n\n  this.eventManager.addEventListener(instance.rootElement,'mousedown', function (event) {\n    if (!that.isTextSelectionAllowed(event.target)) {\n      clearTextSelection();\n      event.preventDefault();\n      window.focus(); //make sure that window that contains HOT is active. Important when HOT is in iframe.\n    }\n  });\n\n  this.eventManager.addEventListener(document.documentElement, 'keyup',function (event) {\n    if (instance.selection.isInProgress() && !event.shiftKey) {\n      instance.selection.finish();\n    }\n  });\n\n  var isMouseDown;\n  this.isMouseDown = function () {\n    return isMouseDown;\n  };\n\n  this.eventManager.addEventListener(document.documentElement, 'mouseup', function (event) {\n    if (instance.selection.isInProgress() && event.which === 1) { //is left mouse button\n      instance.selection.finish();\n    }\n\n    isMouseDown = false;\n\n    if (Handsontable.helper.isOutsideInput(document.activeElement)) {\n      instance.unlisten();\n    }\n  });\n\n  this.eventManager.addEventListener(document.documentElement, 'mousedown',function (event) {\n    var next = event.target;\n\n    if (isMouseDown) {\n      return; //it must have been started in a cell\n    }\n\n    if (next !== that.wt.wtTable.spreader) { //immediate click on \"spreader\" means click on the right side of vertical scrollbar\n      while (next !== document.documentElement) {\n        if (next === null) {\n          return; //click on something that was a row but now is detached (possibly because your click triggered a rerender)\n        }\n       if (next === instance.rootElement) {\n          return; //click inside container\n        }\n        next = next.parentNode;\n      }\n    }\n\n    //function did not return until here, we have an outside click!\n\n    if (that.settings.outsideClickDeselects) {\n      instance.deselectCell();\n    }\n    else {\n      instance.destroyEditor();\n    }\n  });\n\n\n\n  this.eventManager.addEventListener(table, 'selectstart', function (event) {\n    if (that.settings.fragmentSelection) {\n      return;\n    }\n\n    //https://github.com/handsontable/handsontable/issues/160\n    //selectstart is IE only event. Prevent text from being selected when performing drag down in IE8\n    event.preventDefault();\n  });\n\n  var clearTextSelection = function () {\n    //http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\n    if (window.getSelection) {\n      if (window.getSelection().empty) {  // Chrome\n        window.getSelection().empty();\n      } else if (window.getSelection().removeAllRanges) {  // Firefox\n        window.getSelection().removeAllRanges();\n      }\n    } else if (document.selection) {  // IE?\n      document.selection.empty();\n    }\n  };\n\n  var selections = [\n    new WalkontableSelection({\n      className: 'current',\n      border: {\n        width: 2,\n        color: '#5292F7',\n        //style: 'solid', //not used\n        cornerVisible: function () {\n          return that.settings.fillHandle && !that.isCellEdited() && !instance.selection.isMultiple();\n        },\n        multipleSelectionHandlesVisible: function () {\n          return !that.isCellEdited() && !instance.selection.isMultiple();\n        }\n      }\n    }),\n    new WalkontableSelection({\n      className: 'area',\n      border: {\n        width: 1,\n        color: '#89AFF9',\n        //style: 'solid', // not used\n        cornerVisible: function () {\n          return that.settings.fillHandle && !that.isCellEdited() && instance.selection.isMultiple()\n        },\n          multipleSelectionHandlesVisible: function () {\n          return !that.isCellEdited() && instance.selection.isMultiple();\n        }\n      }\n    }),\n    new WalkontableSelection({\n      className: 'highlight',\n      highlightRowClassName: that.settings.currentRowClassName,\n      highlightColumnClassName: that.settings.currentColClassName\n    }),\n    new WalkontableSelection({\n      className: 'fill',\n      border: {\n        width: 1,\n        color: 'red'\n        //style: 'solid' // not used\n      }\n    })\n  ];\n  selections.current = selections[0];\n  selections.area = selections[1];\n  selections.highlight = selections[2];\n  selections.fill = selections[3];\n\n  var walkontableConfig = {\n    debug: function () {\n      return that.settings.debug;\n    },\n    table: table,\n    stretchH: this.settings.stretchH,\n    data: instance.getDataAtCell,\n    totalRows: instance.countRows,\n    totalColumns: instance.countCols,\n    fixedColumnsLeft: function () {\n      return that.settings.fixedColumnsLeft;\n    },\n    fixedRowsTop: function () {\n      return that.settings.fixedRowsTop;\n    },\n    renderAllRows: that.settings.renderAllRows,\n    rowHeaders: function () {\n      var arr = [];\n      if(instance.hasRowHeaders()) {\n        arr.push(function (index, TH) {\n          that.appendRowHeader(index, TH);\n        });\n      }\n      Handsontable.hooks.run(instance, 'afterGetRowHeaderRenderers', arr);\n      return arr;\n    },\n    columnHeaders: function () {\n\n      var arr = [];\n      if(instance.hasColHeaders()) {\n        arr.push(function (index, TH) {\n          that.appendColHeader(index, TH);\n        });\n      }\n      Handsontable.hooks.run(instance, 'afterGetColumnHeaderRenderers', arr);\n      return arr;\n    },\n    columnWidth: instance.getColWidth,\n    rowHeight: instance.getRowHeight,\n    cellRenderer: function (row, col, TD) {\n\n      var prop = that.instance.colToProp(col)\n        , cellProperties = that.instance.getCellMeta(row, col)\n        , renderer = that.instance.getCellRenderer(cellProperties);\n\n      var value = that.instance.getDataAtRowProp(row, prop);\n\n      renderer(that.instance, TD, row, col, prop, value, cellProperties);\n      Handsontable.hooks.run(that.instance, 'afterRenderer', TD, row, col, prop, value, cellProperties);\n\n    },\n    selections: selections,\n    hideBorderOnMouseDownOver: function () {\n      return that.settings.fragmentSelection;\n    },\n    onCellMouseDown: function (event, coords, TD, wt) {\n      instance.listen();\n      that.activeWt = wt;\n\n      isMouseDown = true;\n\n      Handsontable.hooks.run(instance, 'beforeOnCellMouseDown', event, coords, TD);\n\n      Handsontable.Dom.enableImmediatePropagation(event);\n\n      if (!event.isImmediatePropagationStopped()) {\n\n        if (event.button === 2 && instance.selection.inInSelection(coords)) { //right mouse button\n          //do nothing\n        }\n        else if (event.shiftKey) {\n          if (coords.row >= 0 && coords.col >= 0) {\n            instance.selection.setRangeEnd(coords);\n          }\n        }\n        else {\n          if (coords.row < 0 || coords.col < 0) {\n            if (coords.row < 0) {\n              instance.selectCell(0, coords.col, instance.countRows() - 1, coords.col);\n              instance.selection.setSelectedHeaders(false, true);\n            }\n            if (coords.col < 0) {\n              instance.selectCell(coords.row, 0, coords.row, instance.countCols() - 1);\n              instance.selection.setSelectedHeaders(true, false);\n            }\n          }\n          else {\n            instance.selection.setRangeStart(coords);\n          }\n        }\n\n        Handsontable.hooks.run(instance, 'afterOnCellMouseDown', event, coords, TD);\n\n        that.activeWt = that.wt;\n      }\n    },\n    /*onCellMouseOut: function (/*event, coords, TD* /) {\n     if (isMouseDown && that.settings.fragmentSelection === 'single') {\n     clearTextSelection(); //otherwise text selection blinks during multiple cells selection\n     }\n     },*/\n    onCellMouseOver: function (event, coords, TD, wt) {\n      that.activeWt = wt;\n      if (coords.row >= 0 && coords.col >= 0) { //is not a header\n        if (isMouseDown) {\n          /*if (that.settings.fragmentSelection === 'single') {\n           clearTextSelection(); //otherwise text selection blinks during multiple cells selection\n           }*/\n          instance.selection.setRangeEnd(coords);\n        }\n      } else {\n        if (isMouseDown) {\n          // multi select columns\n          if (coords.row < 0) {\n            instance.selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, coords.col));\n            instance.selection.setSelectedHeaders(false, true);\n          }\n\n          // multi select rows\n          if (coords.col < 0) {\n            instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, instance.countCols() - 1));\n            instance.selection.setSelectedHeaders(true, false);\n          }\n        }\n      }\n\n      Handsontable.hooks.run(instance, 'afterOnCellMouseOver', event, coords, TD);\n      that.activeWt = that.wt;\n    },\n    onCellCornerMouseDown: function (event) {\n      event.preventDefault();\n      Handsontable.hooks.run(instance, 'afterOnCellCornerMouseDown', event);\n    },\n    beforeDraw: function (force) {\n      that.beforeRender(force);\n    },\n    onDraw: function (force) {\n      that.onDraw(force);\n    },\n    onScrollVertically: function () {\n      instance.runHooks('afterScrollVertically');\n    },\n    onScrollHorizontally: function () {\n      instance.runHooks('afterScrollHorizontally');\n    },\n    onBeforeDrawBorders: function (corners, borderClassName) {\n      instance.runHooks('beforeDrawBorders', corners, borderClassName);\n    },\n    onBeforeTouchScroll: function () {\n      instance.runHooks('beforeTouchScroll');\n    },\n    onAfterMomentumScroll: function () {\n      instance.runHooks('afterMomentumScroll');\n    },\n    viewportRowCalculatorOverride: function (calc) {\n      if (that.settings.viewportRowRenderingOffset) {\n        calc.startRow = Math.max(calc.startRow - that.settings.viewportRowRenderingOffset, 0);\n        calc.endRow = Math.min(calc.endRow + that.settings.viewportRowRenderingOffset, instance.countRows() - 1);\n      }\n      instance.runHooks('afterViewportRowCalculatorOverride', calc);\n    },\n    viewportColumnCalculatorOverride: function (calc) {\n      if (that.settings.viewportColumnRenderingOffset) {\n        calc.startColumn = Math.max(calc.startColumn - that.settings.viewportColumnRenderingOffset, 0);\n        calc.endColumn = Math.min(calc.endColumn + that.settings.viewportColumnRenderingOffset, instance.countCols() - 1);\n      }\n      instance.runHooks('afterViewportColumnCalculatorOverride', calc);\n    }\n  };\n\n  Handsontable.hooks.run(instance, 'beforeInitWalkontable', walkontableConfig);\n\n  this.wt = new Walkontable(walkontableConfig);\n  this.activeWt = this.wt;\n\n  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'mousedown', function (event) {\n    if (event.target === that.wt.wtTable.spreader && event.which === 3) { //right mouse button exactly on spreader means right clickon the right hand side of vertical scrollbar\n      Handsontable.helper.stopPropagation(event);\n      //event.stopPropagation();\n    }\n  });\n\n  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'contextmenu', function (event) {\n    if (event.target === that.wt.wtTable.spreader && event.which === 3) { //right mouse button exactly on spreader means right clickon the right hand side of vertical scrollbar\n      Handsontable.helper.stopPropagation(event);\n      //event.stopPropagation();\n    }\n  });\n\n\n  this.eventManager.addEventListener(document.documentElement, 'click', function () {\n    if (that.settings.observeDOMVisibility) {\n      if (that.wt.drawInterrupted) {\n        that.instance.forceFullRender = true;\n        that.render();\n      }\n    }\n  });\n};\n\nHandsontable.TableView.prototype.isTextSelectionAllowed = function (el) {\n  if (Handsontable.helper.isInput(el)) {\n    return (true);\n  }\n  if (this.settings.fragmentSelection && Handsontable.Dom.isChildOf(el, this.TBODY)) {\n    return (true);\n  }\n  return false;\n};\n\nHandsontable.TableView.prototype.isCellEdited = function () {\n  var activeEditor = this.instance.getActiveEditor();\n  return activeEditor && activeEditor.isOpened();\n};\n\nHandsontable.TableView.prototype.beforeRender = function (force) {\n  if (force) { //force = did Walkontable decide to do full render\n    Handsontable.hooks.run(this.instance, 'beforeRender', this.instance.forceFullRender); //this.instance.forceFullRender = did Handsontable request full render?\n  }\n};\n\nHandsontable.TableView.prototype.onDraw = function (force) {\n  if (force) { //force = did Walkontable decide to do full render\n    Handsontable.hooks.run(this.instance, 'afterRender', this.instance.forceFullRender); //this.instance.forceFullRender = did Handsontable request full render?\n  }\n};\n\nHandsontable.TableView.prototype.render = function () {\n  this.wt.draw(!this.instance.forceFullRender);\n  this.instance.forceFullRender = false;\n//  this.instance.rootElement.triggerHandler('render.handsontable');\n};\n\n/**\n * Returns td object given coordinates\n * @param {WalkontableCellCoords} coords\n * @param {Boolean} topmost\n */\nHandsontable.TableView.prototype.getCellAtCoords = function (coords, topmost) {\n  var td = this.wt.getCell(coords, topmost);\n  //var td = this.wt.wtTable.getCell(coords);\n  if (td < 0) { //there was an exit code (cell is out of bounds)\n    return null;\n  }\n  else {\n    return td;\n  }\n};\n\n/**\n * Scroll viewport to selection\n * @param {WalkontableCellCoords} coords\n */\nHandsontable.TableView.prototype.scrollViewport = function (coords) {\n  this.wt.scrollViewport(coords);\n};\n\n/**\n * Append row header to a TH element\n * @param row\n * @param TH\n */\nHandsontable.TableView.prototype.appendRowHeader = function (row, TH) {\n  var DIV = document.createElement('DIV'),\n    SPAN = document.createElement('SPAN');\n\n  DIV.className = 'relative';\n  SPAN.className = 'rowHeader';\n\n  if (row > -1) {\n    Handsontable.Dom.fastInnerHTML(SPAN, this.instance.getRowHeader(row));\n  } else {\n    Handsontable.Dom.fastInnerText(SPAN, String.fromCharCode(160)); // workaround for https://github.com/handsontable/handsontable/issues/1946\n  }\n\n  DIV.appendChild(SPAN);\n  Handsontable.Dom.empty(TH);\n\n  TH.appendChild(DIV);\n\n  Handsontable.hooks.run(this.instance, 'afterGetRowHeader', row, TH);\n};\n\n/**\n * Append column header to a TH element\n * @param col\n * @param TH\n */\nHandsontable.TableView.prototype.appendColHeader = function (col, TH) {\n  var DIV = document.createElement('DIV')\n    , SPAN = document.createElement('SPAN');\n\n  DIV.className = 'relative';\n  SPAN.className = 'colHeader';\n\n  if (col > -1) {\n    Handsontable.Dom.fastInnerHTML(SPAN, this.instance.getColHeader(col));\n  } else {\n    Handsontable.Dom.fastInnerText(SPAN, String.fromCharCode(160)); // workaround for https://github.com/handsontable/handsontable/issues/1946\n  }\n  DIV.appendChild(SPAN);\n\n  Handsontable.Dom.empty(TH);\n  TH.appendChild(DIV);\n  Handsontable.hooks.run(this.instance, 'afterGetColHeader', col, TH);\n};\n\n/**\n * Given a element's left position relative to the viewport, returns maximum element width until the right edge of the viewport (before scrollbar)\n * @param {Number} leftOffset\n * @return {Number}\n */\nHandsontable.TableView.prototype.maximumVisibleElementWidth = function (leftOffset) {\n  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();\n  var maxWidth = workspaceWidth - leftOffset;\n  return maxWidth > 0 ? maxWidth : 0;\n};\n\n/**\n * Given a element's top position relative to the viewport, returns maximum element height until the bottom edge of the viewport (before scrollbar)\n * @param {Number} topOffset\n * @return {Number}\n */\nHandsontable.TableView.prototype.maximumVisibleElementHeight = function (topOffset) {\n  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();\n  var maxHeight = workspaceHeight - topOffset;\n  return maxHeight > 0 ? maxHeight : 0;\n};\n\nHandsontable.TableView.prototype.mainViewIsActive = function () {\n  return this.wt === this.activeWt;\n};\n\nHandsontable.TableView.prototype.destroy = function () {\n  this.wt.destroy();\n  this.eventManager.clear();\n};\n\n/**\n * Utility to register editors and common namespace for keeping reference to all editor classes\n */\n(function (Handsontable) {\n  'use strict';\n\n  function RegisteredEditor(editorClass) {\n    var clazz, instances;\n\n    instances = {};\n    clazz = editorClass;\n\n    this.getInstance = function (hotInstance) {\n      if (!(hotInstance.guid in instances)) {\n        instances[hotInstance.guid] = new clazz(hotInstance);\n      }\n\n      return instances[hotInstance.guid];\n    }\n\n  }\n\n  var registeredEditorNames = {};\n  var registeredEditorClasses = new WeakMap();\n\n  Handsontable.editors = {\n\n    /**\n     * Registers editor under given name\n     * @param {String} editorName\n     * @param {Function} editorClass\n     */\n    registerEditor: function (editorName, editorClass) {\n      var editor = new RegisteredEditor(editorClass);\n      if (typeof editorName === \"string\") {\n        registeredEditorNames[editorName] = editor;\n      }\n      registeredEditorClasses.set(editorClass, editor);\n    },\n\n    /**\n     * Returns instance (singleton) of editor class\n     * @param {String|Function} editorName/editorClass\n     * @returns {Function} editorClass\n     */\n    getEditor: function (editorName, hotInstance) {\n      var editor;\n      if (typeof editorName == 'function') {\n        if (!(registeredEditorClasses.get(editorName))) {\n          this.registerEditor(null, editorName);\n        }\n        editor = registeredEditorClasses.get(editorName);\n      }\n      else if (typeof editorName == 'string') {\n        editor = registeredEditorNames[editorName];\n      }\n      else {\n        throw Error('Only strings and functions can be passed as \"editor\" parameter ');\n      }\n\n      if (!editor) {\n        throw Error('No editor registered under name \"' + editorName + '\"');\n      }\n\n      return editor.getInstance(hotInstance);\n    }\n\n  };\n\n\n})(Handsontable);\n\n(function(Handsontable){\n  'use strict';\n\n  Handsontable.EditorManager = function(instance, priv, selection){\n    var that = this;\n    var keyCodes = Handsontable.helper.keyCode;\n    var destroyed = false;\n\n    var eventManager = Handsontable.eventManager(instance);\n\n    var activeEditor;\n\n    var init = function () {\n\n      function onKeyDown(event) {\n\n        if (!instance.isListening()) {\n          return;\n        }\n\n        Handsontable.hooks.run(instance, 'beforeKeyDown', event);\n\n        if(destroyed) {\n          return;\n        }\n\n        Handsontable.Dom.enableImmediatePropagation(event);\n\n        if (!event.isImmediatePropagationStopped()) {\n\n          priv.lastKeyCode = event.keyCode;\n          if (selection.isSelected()) {\n            var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n\n            if (!activeEditor.isWaiting()) {\n              if (!Handsontable.helper.isMetaKey(event.keyCode) && !ctrlDown && !that.isEditorOpened()) {\n                that.openEditor(\"\");\n                return;\n              }\n            }\n\n            var rangeModifier = event.shiftKey ? selection.setRangeEnd : selection.setRangeStart;\n\n              switch (event.keyCode) {\n\n                case keyCodes.A:\n                  if (ctrlDown) {\n                    selection.selectAll(); //select all cells\n\n                    event.preventDefault();\n                    Handsontable.helper.stopPropagation(event);\n                    //event.stopPropagation();\n                  }\n                  break;\n\n                case keyCodes.ARROW_UP:\n\n                  if (that.isEditorOpened() && !activeEditor.isWaiting()){\n                    that.closeEditorAndSaveChanges(ctrlDown);\n                  }\n\n                  moveSelectionUp(event.shiftKey);\n\n                  event.preventDefault();\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.ARROW_DOWN:\n                  if (that.isEditorOpened() && !activeEditor.isWaiting()){\n                    that.closeEditorAndSaveChanges(ctrlDown);\n                  }\n\n                  moveSelectionDown(event.shiftKey);\n\n                  event.preventDefault();\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.ARROW_RIGHT:\n                  if(that.isEditorOpened()  && !activeEditor.isWaiting()){\n                    that.closeEditorAndSaveChanges(ctrlDown);\n                  }\n\n                  moveSelectionRight(event.shiftKey);\n\n                  event.preventDefault();\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.ARROW_LEFT:\n                  if(that.isEditorOpened() && !activeEditor.isWaiting()){\n                    that.closeEditorAndSaveChanges(ctrlDown);\n                  }\n\n                  moveSelectionLeft(event.shiftKey);\n\n                  event.preventDefault();\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.TAB:\n                  var tabMoves = typeof priv.settings.tabMoves === 'function' ? priv.settings.tabMoves(event) : priv.settings.tabMoves;\n                  if (event.shiftKey) {\n                    selection.transformStart(-tabMoves.row, -tabMoves.col); //move selection left\n                  }\n                  else {\n                    selection.transformStart(tabMoves.row, tabMoves.col, true); //move selection right (add a new column if needed)\n                  }\n                  event.preventDefault();\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.BACKSPACE:\n                case keyCodes.DELETE:\n                  selection.empty(event);\n                  that.prepareEditor();\n                  event.preventDefault();\n                  break;\n\n                case keyCodes.F2: /* F2 */\n                  that.openEditor();\n                  event.preventDefault(); //prevent Opera from opening Go to Page dialog\n                  break;\n\n                case keyCodes.ENTER: /* return/enter */\n                  if(that.isEditorOpened()){\n\n                    if (activeEditor.state !== Handsontable.EditorState.WAITING){\n                      that.closeEditorAndSaveChanges(ctrlDown);\n                    }\n\n                    moveSelectionAfterEnter(event.shiftKey);\n\n                  } else {\n\n                    if (instance.getSettings().enterBeginsEditing){\n                      that.openEditor();\n                    } else {\n                      moveSelectionAfterEnter(event.shiftKey);\n                    }\n\n                  }\n\n                  event.preventDefault(); //don't add newline to field\n                  event.stopImmediatePropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.ESCAPE:\n                  if(that.isEditorOpened()){\n                    that.closeEditorAndRestoreOriginalValue(ctrlDown);\n                  }\n                  event.preventDefault();\n                  break;\n\n                case keyCodes.HOME:\n                  if (event.ctrlKey || event.metaKey) {\n                    rangeModifier(new WalkontableCellCoords(0, priv.selRange.from.col));\n                  }\n                  else {\n                    rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, 0));\n                  }\n                  event.preventDefault(); //don't scroll the window\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.END:\n                  if (event.ctrlKey || event.metaKey) {\n                    rangeModifier(new WalkontableCellCoords(instance.countRows() - 1, priv.selRange.from.col));\n                  }\n                  else {\n                    rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, instance.countCols() - 1));\n                  }\n                  event.preventDefault(); //don't scroll the window\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.PAGE_UP:\n                  selection.transformStart(-instance.countVisibleRows(), 0);\n                  event.preventDefault(); //don't page up the window\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n\n                case keyCodes.PAGE_DOWN:\n                  selection.transformStart(instance.countVisibleRows(), 0);\n                  event.preventDefault(); //don't page down the window\n                  Handsontable.helper.stopPropagation(event);\n                  //event.stopPropagation(); //required by HandsontableEditor\n                  break;\n              }\n\n          }\n        }\n      }\n\n      instance.addHook('afterDocumentKeyDown', function(originalEvent){\n        onKeyDown(originalEvent);\n      });\n\n      eventManager.addEventListener(document, 'keydown', function (ev){\n        instance.runHooks('afterDocumentKeyDown', ev);\n      });\n\n      function onDblClick(event, coords, elem) {\n        if(elem.nodeName == \"TD\") { //may be TD or TH\n          that.openEditor();\n        }\n      }\n\n      instance.view.wt.update('onCellDblClick', onDblClick);\n\n      instance.addHook('afterDestroy', function(){\n        destroyed = true;\n      });\n\n      function moveSelectionAfterEnter(shiftKey){\n        var enterMoves = typeof priv.settings.enterMoves === 'function' ? priv.settings.enterMoves(event) : priv.settings.enterMoves;\n\n        if (shiftKey) {\n          selection.transformStart(-enterMoves.row, -enterMoves.col); //move selection up\n        }\n        else {\n          selection.transformStart(enterMoves.row, enterMoves.col, true); //move selection down (add a new row if needed)\n        }\n      }\n\n      function moveSelectionUp(shiftKey){\n        if (shiftKey) {\n          selection.transformEnd(-1, 0);\n        }\n        else {\n          selection.transformStart(-1, 0);\n        }\n      }\n\n      function moveSelectionDown(shiftKey){\n        if (shiftKey) {\n          selection.transformEnd(1, 0); //expanding selection down with shift\n        }\n        else {\n          selection.transformStart(1, 0); //move selection down\n        }\n      }\n\n      function moveSelectionRight(shiftKey){\n        if (shiftKey) {\n          selection.transformEnd(0, 1);\n        }\n        else {\n          selection.transformStart(0, 1);\n        }\n      }\n\n      function moveSelectionLeft(shiftKey){\n        if (shiftKey) {\n          selection.transformEnd(0, -1);\n        }\n        else {\n          selection.transformStart(0, -1);\n        }\n      }\n    };\n\n    /**\n     * Destroy current editor, if exists\n     * @param {Boolean} revertOriginal\n     */\n    this.destroyEditor = function (revertOriginal) {\n      this.closeEditor(revertOriginal);\n    };\n\n    this.getActiveEditor = function () {\n      return activeEditor;\n    };\n\n    /**\n     * Prepare text input to be displayed at given grid cell\n     */\n    this.prepareEditor = function () {\n\n      if (activeEditor && activeEditor.isWaiting()){\n\n        this.closeEditor(false, false, function(dataSaved){\n          if(dataSaved){\n            that.prepareEditor();\n          }\n        });\n\n        return;\n      }\n\n      var row = priv.selRange.highlight.row;\n      var col = priv.selRange.highlight.col;\n      var prop = instance.colToProp(col);\n      var td = instance.getCell(row, col);\n      var originalValue = instance.getDataAtCell(row, col);\n      var cellProperties = instance.getCellMeta(row, col);\n\n      var editorClass = instance.getCellEditor(cellProperties);\n      activeEditor = Handsontable.editors.getEditor(editorClass, instance);\n\n      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);\n\n    };\n\n    this.isEditorOpened = function () {\n      return activeEditor.isOpened();\n    };\n\n    this.openEditor = function (initialValue) {\n      if (!activeEditor.cellProperties.readOnly){\n        activeEditor.beginEditing(initialValue);\n      }\n    };\n\n    this.closeEditor = function (restoreOriginalValue, ctrlDown, callback) {\n\n      if (!activeEditor){\n        if(callback) {\n          callback(false);\n        }\n      }\n      else {\n        activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);\n      }\n    };\n\n    this.closeEditorAndSaveChanges = function(ctrlDown){\n      return this.closeEditor(false, ctrlDown);\n    };\n\n    this.closeEditorAndRestoreOriginalValue = function(ctrlDown){\n      return this.closeEditor(true, ctrlDown);\n    };\n\n    init();\n  };\n\n})(Handsontable);\n\n/**\n * Utility to register renderers and common namespace for keeping reference to all renderers classes\n */\n(function (Handsontable) {\n  'use strict';\n\n  var registeredRenderers = {};\n\n  Handsontable.renderers = {\n\n    /**\n     * Registers renderer under given name\n     * @param {String} rendererName\n     * @param {Function} rendererFunction\n     */\n    registerRenderer: function (rendererName, rendererFunction) {\n      registeredRenderers[rendererName] = rendererFunction\n    },\n\n    /**\n     * @param {String|Function} rendererName/rendererFunction\n     * @returns {Function} rendererFunction\n     */\n    getRenderer: function (rendererName) {\n      if (typeof rendererName == 'function'){\n        return rendererName;\n      }\n\n      if (typeof rendererName != 'string'){\n        throw Error('Only strings and functions can be passed as \"renderer\" parameter ');\n      }\n\n      if (!(rendererName in registeredRenderers)) {\n        throw Error('No editor registered under name \"' + rendererName + '\"');\n      }\n\n      return registeredRenderers[rendererName];\n    }\n\n  };\n\n\n})(Handsontable);\n\nHandsontable.helper = {};\n\n/**\n * Returns true if keyCode represents a printable character\n * @param {Number} keyCode\n * @return {Boolean}\n */\nHandsontable.helper.isPrintableChar = function (keyCode) {\n  return ((keyCode == 32) || //space\n    (keyCode >= 48 && keyCode <= 57) || //0-9\n    (keyCode >= 96 && keyCode <= 111) || //numpad\n    (keyCode >= 186 && keyCode <= 192) || //;=,-./`\n    (keyCode >= 219 && keyCode <= 222) || //[]{}\\|\"'\n    keyCode >= 226 || //special chars (229 for Asian chars)\n    (keyCode >= 65 && keyCode <= 90)); //a-z\n};\n\nHandsontable.helper.isMetaKey = function (keyCode) {\n  var keyCodes = Handsontable.helper.keyCode;\n  var metaKeys = [\n    keyCodes.ARROW_DOWN,\n    keyCodes.ARROW_UP,\n    keyCodes.ARROW_LEFT,\n    keyCodes.ARROW_RIGHT,\n    keyCodes.HOME,\n    keyCodes.END,\n    keyCodes.DELETE,\n    keyCodes.BACKSPACE,\n    keyCodes.F1,\n    keyCodes.F2,\n    keyCodes.F3,\n    keyCodes.F4,\n    keyCodes.F5,\n    keyCodes.F6,\n    keyCodes.F7,\n    keyCodes.F8,\n    keyCodes.F9,\n    keyCodes.F10,\n    keyCodes.F11,\n    keyCodes.F12,\n    keyCodes.TAB,\n    keyCodes.PAGE_DOWN,\n    keyCodes.PAGE_UP,\n    keyCodes.ENTER,\n    keyCodes.ESCAPE,\n    keyCodes.SHIFT,\n    keyCodes.CAPS_LOCK,\n    keyCodes.ALT\n  ];\n\n  return metaKeys.indexOf(keyCode) != -1;\n};\n\nHandsontable.helper.isCtrlKey = function (keyCode) {\n\n  var keys = Handsontable.helper.keyCode;\n\n  return [keys.CONTROL_LEFT, 224, keys.COMMAND_LEFT, keys.COMMAND_RIGHT].indexOf(keyCode) != -1;\n};\n\n/**\n * Converts a value to string\n * @param value\n * @return {String}\n */\nHandsontable.helper.stringify = function (value) {\n  switch (typeof value) {\n    case 'string':\n    case 'number':\n      return value + '';\n\n    case 'object':\n      if (value === null) {\n        return '';\n      }\n      else {\n        return value.toString();\n      }\n\n    case 'undefined':\n      return '';\n\n    default:\n      return value.toString();\n  }\n};\n\n/**\n * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc\n * @param index\n * @returns {String}\n */\nHandsontable.helper.spreadsheetColumnLabel = function (index) {\n  var dividend = index + 1;\n  var columnLabel = '';\n  var modulo;\n  while (dividend > 0) {\n    modulo = (dividend - 1) % 26;\n    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;\n    dividend = parseInt((dividend - modulo) / 26, 10);\n  }\n  return columnLabel;\n};\n\n/**\n * Creates 2D array of Excel-like values \"A1\", \"A2\", ...\n * @param rowCount\n * @param colCount\n * @returns {Array}\n */\nHandsontable.helper.createSpreadsheetData = function(rowCount, colCount) {\n  rowCount = typeof rowCount === 'number' ? rowCount : 100;\n  colCount = typeof colCount === 'number' ? colCount : 4;\n\n  var rows = []\n    , i\n    , j;\n\n  for (i = 0; i < rowCount; i++) {\n    var row = [];\n    for (j = 0; j < colCount; j++) {\n      row.push(Handsontable.helper.spreadsheetColumnLabel(j) + (i + 1));\n    }\n    rows.push(row);\n  }\n  return rows;\n}\n\nHandsontable.helper.createSpreadsheetObjectData = function(rowCount, colCount) {\n  rowCount = typeof rowCount === 'number' ? rowCount : 100;\n  colCount = typeof colCount === 'number' ? colCount : 4;\n\n  var rows = []\n    , i\n    , j;\n\n  for (i = 0; i < rowCount; i++) {\n    var row = {};\n    for (j = 0; j < colCount; j++) {\n      row['prop' + j] = Handsontable.helper.spreadsheetColumnLabel(j) + (i + 1)\n    }\n    rows.push(row);\n  }\n  return rows;\n}\n\n/**\n * Checks if value of n is a numeric one\n * http://jsperf.com/isnan-vs-isnumeric/4\n * @param n\n * @returns {boolean}\n */\nHandsontable.helper.isNumeric = function (n) {\n    var t = typeof n;\n    return t == 'number' ? !isNaN(n) && isFinite(n) :\n           t == 'string' ? !n.length ? false :\n           n.length == 1 ? /\\d/.test(n) :\n           /^\\s*[+-]?\\s*(?:(?:\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?)|(?:0x[a-f\\d]+))\\s*$/i.test(n) :\n           t == 'object' ? !!n && typeof n.valueOf() == \"number\" && !(n instanceof Date) : false;\n};\n\n/**\n * Generates a random hex string. Used as namespace for Handsontable instance events.\n * @return {String} - 16 character random string: \"92b1bfc74ec4\"\n */\nHandsontable.helper.randomString = function () {\n  return walkontableRandomString();\n};\n\n/**\n * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.\n * Creates temporary dummy function to call it as constructor.\n * Described in ticket: https://github.com/handsontable/handsontable/pull/516\n * @param  {Object} Child  child class\n * @param  {Object} Parent parent class\n * @return {Object}        extended Child\n */\nHandsontable.helper.inherit = function (Child, Parent) {\n  Parent.prototype.constructor = Parent;\n  Child.prototype = new Parent();\n  Child.prototype.constructor = Child;\n  return Child;\n};\n\n/**\n * Perform shallow extend of a target object with extension's own properties\n * @param {Object} target An object that will receive the new properties\n * @param {Object} extension An object containing additional properties to merge into the target\n */\nHandsontable.helper.extend = function (target, extension) {\n  for (var i in extension) {\n    if (extension.hasOwnProperty(i)) {\n      target[i] = extension[i];\n    }\n  }\n};\n\n/**\n * Perform deep extend of a target object with extension's own properties\n * @param {Object} target An object that will receive the new properties\n * @param {Object} extension An object containing additional properties to merge into the target\n */\nHandsontable.helper.deepExtend = function (target, extension) {\n  for (var key in extension) {\n    if (extension.hasOwnProperty(key)) {\n      if (extension[key] && typeof extension[key] === 'object') {\n        if (!target[key]) {\n          if (Array.isArray(extension[key])) {\n            target[key] = [];\n          }\n          else {\n            target[key] = {};\n          }\n        }\n        Handsontable.helper.deepExtend(target[key], extension[key]);\n      }\n      else {\n        target[key] = extension[key];\n      }\n    }\n  }\n};\n\n/**\n * Perform deep clone of an object\n * WARNING! Only clones JSON properties. Will cause error when `obj` contains a function, Date, etc\n * @param {Object} obj An object that will be cloned\n * @return {Object}\n */\nHandsontable.helper.deepClone = function (obj) {\n  if (typeof obj === \"object\") {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  else {\n    return obj;\n  }\n};\n\nHandsontable.helper.getPrototypeOf = function (obj) {\n  var prototype;\n\n  if(typeof obj.__proto__ == \"object\"){\n    prototype = obj.__proto__;\n  } else {\n    var oldConstructor,\n        constructor = obj.constructor;\n\n    if (typeof obj.constructor == \"function\") {\n      oldConstructor = constructor;\n\n      if (delete obj.constructor){\n        constructor = obj.constructor; // get real constructor\n        obj.constructor = oldConstructor; // restore constructor\n      }\n\n\n    }\n\n    prototype = constructor ? constructor.prototype : null; // needed for IE\n\n  }\n\n  return prototype;\n};\n\n/**\n * Factory for columns constructors.\n * @param {Object} GridSettings\n * @param {Array} conflictList\n * @return {Object} ColumnSettings\n */\nHandsontable.helper.columnFactory = function (GridSettings, conflictList) {\n  function ColumnSettings () {}\n\n  Handsontable.helper.inherit(ColumnSettings, GridSettings);\n\n  // Clear conflict settings\n  for (var i = 0, len = conflictList.length; i < len; i++) {\n    ColumnSettings.prototype[conflictList[i]] = void 0;\n  }\n\n  return ColumnSettings;\n};\n\nHandsontable.helper.translateRowsToColumns = function (input) {\n  var i\n    , ilen\n    , j\n    , jlen\n    , output = []\n    , olen = 0;\n\n  for (i = 0, ilen = input.length; i < ilen; i++) {\n    for (j = 0, jlen = input[i].length; j < jlen; j++) {\n      if (j == olen) {\n        output.push([]);\n        olen++;\n      }\n      output[j].push(input[i][j])\n    }\n  }\n  return output;\n};\n\nHandsontable.helper.to2dArray = function (arr) {\n  var i = 0\n    , ilen = arr.length;\n  while (i < ilen) {\n    arr[i] = [arr[i]];\n    i++;\n  }\n};\n\nHandsontable.helper.extendArray = function (arr, extension) {\n  var i = 0\n    , ilen = extension.length;\n  while (i < ilen) {\n    arr.push(extension[i]);\n    i++;\n  }\n};\n\n/**\n * Determines if the given DOM element is an input field.\n * Notice: By 'input' we mean input, textarea and select nodes\n * @param element - DOM element\n * @returns {boolean}\n */\nHandsontable.helper.isInput = function (element) {\n  var inputs = ['INPUT', 'SELECT', 'TEXTAREA'];\n\n  return inputs.indexOf(element.nodeName) > -1;\n}\n\n/**\n * Determines if the given DOM element is an input field placed OUTSIDE of HOT.\n * Notice: By 'input' we mean input, textarea and select nodes\n * @param element - DOM element\n * @returns {boolean}\n */\nHandsontable.helper.isOutsideInput = function (element) {\n  return Handsontable.helper.isInput(element) && element.className.indexOf('handsontableInput') == -1;\n};\n\nHandsontable.helper.keyCode = {\n  MOUSE_LEFT: 1,\n  MOUSE_RIGHT: 3,\n  MOUSE_MIDDLE: 2,\n  BACKSPACE: 8,\n  COMMA: 188,\n  INSERT: 45,\n  DELETE: 46,\n  END: 35,\n  ENTER: 13,\n  ESCAPE: 27,\n  CONTROL_LEFT: 91,\n  COMMAND_LEFT: 17,\n  COMMAND_RIGHT: 93,\n  ALT: 18,\n  HOME: 36,\n  PAGE_DOWN: 34,\n  PAGE_UP: 33,\n  PERIOD: 190,\n  SPACE: 32,\n  SHIFT: 16,\n  CAPS_LOCK: 20,\n  TAB: 9,\n  ARROW_RIGHT: 39,\n  ARROW_LEFT: 37,\n  ARROW_UP: 38,\n  ARROW_DOWN: 40,\n  F1: 112,\n  F2: 113,\n  F3: 114,\n  F4: 115,\n  F5: 116,\n  F6: 117,\n  F7: 118,\n  F8: 119,\n  F9: 120,\n  F10: 121,\n  F11: 122,\n  F12: 123,\n  A: 65,\n  X: 88,\n  C: 67,\n  V: 86\n};\n\n/**\n * Determines whether given object is a plain Object.\n * Note: String and Array are not plain Objects\n * @param {*} obj\n * @returns {boolean}\n */\nHandsontable.helper.isObject = function (obj) {\n  return Object.prototype.toString.call(obj) == '[object Object]';\n};\n\nHandsontable.helper.pivot = function (arr) {\n  var pivotedArr = [];\n\n  if(!arr || arr.length == 0 || !arr[0] || arr[0].length == 0){\n    return pivotedArr;\n  }\n\n  var rowCount = arr.length;\n  var colCount = arr[0].length;\n\n  for(var i = 0; i < rowCount; i++){\n    for(var j = 0; j < colCount; j++){\n      if(!pivotedArr[j]){\n        pivotedArr[j] = [];\n      }\n\n      pivotedArr[j][i] = arr[i][j];\n    }\n  }\n\n  return pivotedArr;\n\n};\n\nHandsontable.helper.proxy = function (fun, context) {\n  return function () {\n    return fun.apply(context, arguments);\n  };\n};\n\n/**\n * Factory that produces a function for searching methods (or any properties) which could be defined directly in\n * table configuration or implicitly, within cell type definition.\n *\n * For example: renderer can be defined explicitly using \"renderer\" property in column configuration or it can be\n * defined implicitly using \"type\" property.\n *\n * Methods/properties defined explicitly always takes precedence over those defined through \"type\".\n *\n * If the method/property is not found in an object, searching is continued recursively through prototype chain, until\n * it reaches the Object.prototype.\n *\n *\n * @param methodName {String} name of the method/property to search (i.e. 'renderer', 'validator', 'copyable')\n * @param allowUndefined {Boolean} [optional] if false, the search is continued if methodName has not been found in cell \"type\"\n * @returns {Function}\n */\nHandsontable.helper.cellMethodLookupFactory = function (methodName, allowUndefined) {\n\n  allowUndefined = typeof allowUndefined == 'undefined' ? true : allowUndefined;\n\n  return function cellMethodLookup (row, col) {\n\n    return (function getMethodFromProperties(properties) {\n\n      if (!properties){\n\n        return;                       //method not found\n\n      }\n      else if (properties.hasOwnProperty(methodName) && properties[methodName] !== void 0) { //check if it is own and is not empty\n\n        return properties[methodName];  //method defined directly\n\n      } else if (properties.hasOwnProperty('type') && properties.type) { //check if it is own and is not empty\n\n        var type;\n\n        if(typeof properties.type != 'string' ){\n          throw new Error('Cell type must be a string ');\n        }\n\n        type = translateTypeNameToObject(properties.type);\n\n        if (type.hasOwnProperty(methodName)) {\n          return type[methodName]; //method defined in type.\n        } else if (allowUndefined) {\n          return; //method does not defined in type (eg. validator), returns undefined\n        }\n\n      }\n\n      return getMethodFromProperties(Handsontable.helper.getPrototypeOf(properties));\n\n    })(typeof row == 'number' ? this.getCellMeta(row, col) : row);\n\n  };\n\n  function translateTypeNameToObject(typeName) {\n    var type = Handsontable.cellTypes[typeName];\n\n    if(typeof type == 'undefined'){\n      throw new Error('You declared cell type \"' + typeName + '\" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');\n    }\n\n    return type;\n  }\n\n};\n\nHandsontable.helper.isMobileBrowser = function (userAgent) {\n  if(!userAgent) {\n    userAgent = navigator.userAgent;\n  }\n  return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent));\n\n  // Logic for checking the specific mobile browser\n  //\n  /* var type = type != void 0 ? type.toLowerCase() : ''\n    , result;\n  switch(type) {\n    case '':\n      result = (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));\n      return result;\n      break;\n    case 'ipad':\n      return navigator.userAgent.indexOf('iPad') > -1;\n      break;\n    case 'android':\n      return navigator.userAgent.indexOf('Android') > -1;\n      break;\n    case 'windows':\n      return navigator.userAgent.indexOf('IEMobile') > -1;\n      break;\n    default:\n      throw new Error('Invalid isMobileBrowser argument');\n      break;\n  } */\n};\n\nHandsontable.helper.isTouchSupported = function () {\n  return ('ontouchstart' in window);\n};\n\nHandsontable.helper.stopPropagation = function (event) {\n  // ie8\n  //http://msdn.microsoft.com/en-us/library/ie/ff975462(v=vs.85).aspx\n  if (typeof (event.stopPropagation) === 'function') {\n    event.stopPropagation();\n  }\n  else {\n    event.cancelBubble = true;\n  }\n};\n\nHandsontable.helper.pageX = function (event) {\n  if (event.pageX) {\n    return event.pageX;\n  }\n\n  var scrollLeft = Handsontable.Dom.getWindowScrollLeft();\n  var cursorX = event.clientX + scrollLeft;\n\n  return cursorX;\n};\n\nHandsontable.helper.pageY = function (event) {\n  if (event.pageY) {\n    return event.pageY;\n  }\n\n  var scrollTop = Handsontable.Dom.getWindowScrollTop();\n  var cursorY = event.clientY + scrollTop;\n\n  return cursorY;\n};\n\n(function (Handsontable) {\n  'use strict';\n\n  /**\n   * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names\n   * TODO refactor arguments of methods getRange, getText to be numbers (not objects)\n   * TODO remove priv, GridSettings from object constructor\n   *\n   * @param instance\n   * @param priv\n   * @param GridSettings\n   * @constructor\n   */\n  Handsontable.DataMap = function (instance, priv, GridSettings) {\n    this.instance = instance;\n    this.priv = priv;\n    this.GridSettings = GridSettings;\n    this.dataSource = this.instance.getSettings().data;\n\n    if (this.dataSource[0]) {\n      this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);\n    }\n    else {\n      this.duckSchema = {};\n    }\n    this.createMap();\n  };\n\n  Handsontable.DataMap.prototype.DESTINATION_RENDERER = 1;\n  Handsontable.DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;\n\n  Handsontable.DataMap.prototype.recursiveDuckSchema = function (obj) {\n    var schema;\n    if (!Array.isArray(obj)){\n      schema = {};\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          if (typeof obj[i] === \"object\" && !Array.isArray(obj[i])) {\n            schema[i] = this.recursiveDuckSchema(obj[i]);\n          }\n          else {\n            schema[i] = null;\n          }\n        }\n      }\n    }\n    else {\n      schema = [];\n    }\n    return schema;\n  };\n\n  Handsontable.DataMap.prototype.recursiveDuckColumns = function (schema, lastCol, parent) {\n    var prop, i;\n    if (typeof lastCol === 'undefined') {\n      lastCol = 0;\n      parent = '';\n    }\n    if (typeof schema === \"object\" && !Array.isArray(schema)) {\n      for (i in schema) {\n        if (schema.hasOwnProperty(i)) {\n          if (schema[i] === null) {\n            prop = parent + i;\n            this.colToPropCache.push(prop);\n            this.propToColCache.set(prop, lastCol);\n\n            lastCol++;\n          }\n          else {\n            lastCol = this.recursiveDuckColumns(schema[i], lastCol, i + '.');\n          }\n        }\n      }\n    }\n    return lastCol;\n  };\n\n  Handsontable.DataMap.prototype.createMap = function () {\n    var i, ilen, schema = this.getSchema();\n    if (typeof schema === \"undefined\") {\n      throw new Error(\"trying to create `columns` definition but you didnt' provide `schema` nor `data`\");\n    }\n    this.colToPropCache = [];\n    this.propToColCache = new MultiMap();\n    var columns = this.instance.getSettings().columns;\n    if (columns) {\n      for (i = 0, ilen = columns.length; i < ilen; i++) {\n\n        if (typeof columns[i].data != 'undefined'){\n          this.colToPropCache[i] = columns[i].data;\n          this.propToColCache.set(columns[i].data, i);\n        }\n\n      }\n    }\n    else {\n      this.recursiveDuckColumns(schema);\n    }\n  };\n\n  Handsontable.DataMap.prototype.colToProp = function (col) {\n    col = Handsontable.hooks.execute(this.instance, 'modifyCol', col);\n    if (this.colToPropCache && typeof this.colToPropCache[col] !== 'undefined') {\n      return this.colToPropCache[col];\n    }\n    else {\n      return col;\n    }\n  };\n\n  Handsontable.DataMap.prototype.propToCol = function (prop) {\n    var col;\n    if (typeof this.propToColCache.get(prop) !== 'undefined') {\n      col = this.propToColCache.get(prop);\n    } else {\n      col = prop;\n    }\n    col = Handsontable.hooks.execute(this.instance, 'modifyCol', col);\n    return col;\n  };\n\n  Handsontable.DataMap.prototype.getSchema = function () {\n    var schema = this.instance.getSettings().dataSchema;\n    if (schema) {\n      if (typeof schema === 'function') {\n        return schema();\n      }\n      return schema;\n    }\n    return this.duckSchema;\n  };\n\n  /**\n   * Creates row at the bottom of the data array\n   * @param {Number} [index] Optional. Index of the row before which the new row will be inserted\n   */\n  Handsontable.DataMap.prototype.createRow = function (index, amount, createdAutomatically) {\n    var row\n      , colCount = this.instance.countCols()\n      , numberOfCreatedRows = 0\n      , currentIndex;\n\n    if (!amount) {\n      amount = 1;\n    }\n\n    if (typeof index !== 'number' || index >= this.instance.countRows()) {\n      index = this.instance.countRows();\n    }\n\n    currentIndex = index;\n    var maxRows = this.instance.getSettings().maxRows;\n    while (numberOfCreatedRows < amount && this.instance.countRows() < maxRows) {\n\n      if (this.instance.dataType === 'array') {\n        row = [];\n        for (var c = 0; c < colCount; c++) {\n          row.push(null);\n        }\n      }\n      else if (this.instance.dataType === 'function') {\n        row = this.instance.getSettings().dataSchema(index);\n      }\n      else {\n        row = {};\n        Handsontable.helper.deepExtend(row, this.getSchema());\n      }\n\n      if (index === this.instance.countRows()) {\n        this.dataSource.push(row);\n      }\n      else {\n        this.dataSource.splice(index, 0, row);\n      }\n\n      numberOfCreatedRows++;\n      currentIndex++;\n    }\n\n\n    Handsontable.hooks.run(this.instance, 'afterCreateRow', index, numberOfCreatedRows, createdAutomatically);\n    this.instance.forceFullRender = true; //used when data was changed\n\n    return numberOfCreatedRows;\n  };\n\n  /**\n   * Creates col at the right of the data array\n   * @param {Number} [index] Optional. Index of the column before which the new column will be inserted\n   *   * @param {Number} [amount] Optional.\n   */\n  Handsontable.DataMap.prototype.createCol = function (index, amount, createdAutomatically) {\n    if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {\n      throw new Error(\"Cannot create new column. When data source in an object, \" +\n        \"you can only have as much columns as defined in first data row, data schema or in the 'columns' setting.\" +\n        \"If you want to be able to add new columns, you have to use array datasource.\");\n    }\n    var rlen = this.instance.countRows()\n      , data = this.dataSource\n      , constructor\n      , numberOfCreatedCols = 0\n      , currentIndex;\n\n    if (!amount) {\n      amount = 1;\n    }\n\n    currentIndex = index;\n\n    var maxCols = this.instance.getSettings().maxCols;\n    while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {\n      constructor = Handsontable.helper.columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);\n      if (typeof index !== 'number' || index >= this.instance.countCols()) {\n        for (var r = 0; r < rlen; r++) {\n          if (typeof data[r] === 'undefined') {\n            data[r] = [];\n          }\n          data[r].push(null);\n        }\n        // Add new column constructor\n        this.priv.columnSettings.push(constructor);\n      }\n      else {\n        for (var r = 0; r < rlen; r++) {\n          data[r].splice(currentIndex, 0, null);\n        }\n        // Add new column constructor at given index\n        this.priv.columnSettings.splice(currentIndex, 0, constructor);\n      }\n\n      numberOfCreatedCols++;\n      currentIndex++;\n    }\n\n    Handsontable.hooks.run(this.instance, 'afterCreateCol', index, numberOfCreatedCols, createdAutomatically);\n    this.instance.forceFullRender = true; //used when data was changed\n\n    return numberOfCreatedCols;\n  };\n\n  /**\n   * Removes row from the data array\n   * @param {Number} [index] Optional. Index of the row to be removed. If not provided, the last row will be removed\n   * @param {Number} [amount] Optional. Amount of the rows to be removed. If not provided, one row will be removed\n   */\n  Handsontable.DataMap.prototype.removeRow = function (index, amount) {\n    if (!amount) {\n      amount = 1;\n    }\n    if (typeof index !== 'number') {\n      index = -amount;\n    }\n\n    index = (this.instance.countRows() + index) % this.instance.countRows();\n\n    // We have to map the physical row ids to logical and than perform removing with (possibly) new row id\n    var logicRows = this.physicalRowsToLogical(index, amount);\n\n    var actionWasNotCancelled = Handsontable.hooks.execute(this.instance, 'beforeRemoveRow', index, amount);\n\n    if (actionWasNotCancelled === false) {\n      return;\n    }\n\n    var data = this.dataSource;\n    var newData = data.filter(function (row, index) {\n      return logicRows.indexOf(index) == -1;\n    });\n\n    data.length = 0;\n    Array.prototype.push.apply(data, newData);\n\n    Handsontable.hooks.run(this.instance, 'afterRemoveRow', index, amount);\n\n    this.instance.forceFullRender = true; //used when data was changed\n  };\n\n  /**\n   * Removes column from the data array\n   * @param {Number} [index] Optional. Index of the column to be removed. If not provided, the last column will be removed\n   * @param {Number} [amount] Optional. Amount of the columns to be removed. If not provided, one column will be removed\n   */\n  Handsontable.DataMap.prototype.removeCol = function (index, amount) {\n    if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {\n      throw new Error(\"cannot remove column with object data source or columns option specified\");\n    }\n    if (!amount) {\n      amount = 1;\n    }\n    if (typeof index !== 'number') {\n      index = -amount;\n    }\n\n    index = (this.instance.countCols() + index) % this.instance.countCols();\n\n    var actionWasNotCancelled = Handsontable.hooks.execute(this.instance, 'beforeRemoveCol', index, amount);\n\n    if (actionWasNotCancelled === false) {\n      return;\n    }\n\n    var data = this.dataSource;\n    for (var r = 0, rlen = this.instance.countRows(); r < rlen; r++) {\n      data[r].splice(index, amount);\n    }\n    this.priv.columnSettings.splice(index, amount);\n\n    Handsontable.hooks.run(this.instance, 'afterRemoveCol', index, amount);\n    this.instance.forceFullRender = true; //used when data was changed\n  };\n\n  /**\n   * Add / removes data from the column\n   * @param {Number} col Index of column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array\n   */\n  Handsontable.DataMap.prototype.spliceCol = function (col, index, amount/*, elements...*/) {\n    var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];\n\n    var colData = this.instance.getDataAtCol(col);\n    var removed = colData.slice(index, index + amount);\n    var after = colData.slice(index + amount);\n\n    Handsontable.helper.extendArray(elements, after);\n    var i = 0;\n    while (i < amount) {\n      elements.push(null); //add null in place of removed elements\n      i++;\n    }\n    Handsontable.helper.to2dArray(elements);\n    this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n\n    return removed;\n  };\n\n  /**\n   * Add / removes data from the row\n   * @param {Number} row Index of row in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array\n   */\n  Handsontable.DataMap.prototype.spliceRow = function (row, index, amount/*, elements...*/) {\n    var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];\n\n    var rowData = this.instance.getSourceDataAtRow(row);\n    var removed = rowData.slice(index, index + amount);\n    var after = rowData.slice(index + amount);\n\n    Handsontable.helper.extendArray(elements, after);\n    var i = 0;\n    while (i < amount) {\n      elements.push(null); //add null in place of removed elements\n      i++;\n    }\n    this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n\n    return removed;\n  };\n\n  /**\n   * Returns single value from the data array\n   * @param {Number} row\n   * @param {Number} prop\n   */\n  Handsontable.DataMap.prototype.get = function (row, prop) {\n    row = Handsontable.hooks.execute(this.instance, 'modifyRow', row);\n    if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n      var sliced = prop.split(\".\");\n      var out = this.dataSource[row];\n      if (!out) {\n        return null;\n      }\n      for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n        out = out[sliced[i]];\n        if (typeof out === 'undefined') {\n          return null;\n        }\n      }\n      return out;\n    }\n    else if (typeof prop === 'function') {\n      /**\n       *  allows for interacting with complex structures, for example\n       *  d3/jQuery getter/setter properties:\n       *\n       *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}\n       */\n      return prop(this.dataSource.slice(\n        row,\n        row + 1\n      )[0]);\n    }\n    else {\n      return this.dataSource[row] ? this.dataSource[row][prop] : null;\n    }\n  };\n\n  var copyableLookup = Handsontable.helper.cellMethodLookupFactory('copyable', false);\n\n  /**\n   * Returns single value from the data array (intended for clipboard copy to an external application)\n   * @param {Number} row\n   * @param {Number} prop\n   * @return {String}\n   */\n  Handsontable.DataMap.prototype.getCopyable = function (row, prop) {\n    if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n      return this.get(row, prop);\n    }\n    return '';\n  };\n\n  /**\n   * Saves single value to the data array\n   * @param {Number} row\n   * @param {Number} prop\n   * @param {String} value\n   * @param {String} [source] Optional. Source of hook runner.\n   */\n  Handsontable.DataMap.prototype.set = function (row, prop, value, source) {\n    row = Handsontable.hooks.execute(this.instance, 'modifyRow', row, source || \"datamapGet\");\n    if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n      var sliced = prop.split(\".\");\n      var out = this.dataSource[row];\n      for (var i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n\n        if (typeof out[sliced[i]] === 'undefined'){\n          out[sliced[i]] = {};\n        }\n        out = out[sliced[i]];\n      }\n      out[sliced[i]] = value;\n    }\n    else if (typeof prop === 'function') {\n      /* see the `function` handler in `get` */\n      prop(this.dataSource.slice(\n        row,\n        row + 1\n      )[0], value);\n    }\n    else {\n      this.dataSource[row][prop] = value;\n    }\n  };\n\n  /**\n   * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n   * The trick is, the physical row id (stored in settings.data) is not necessary the same\n   * as the logical (displayed) row id (e.g. when sorting is applied).\n   */\n  Handsontable.DataMap.prototype.physicalRowsToLogical = function (index, amount) {\n    var totalRows = this.instance.countRows();\n    var physicRow = (totalRows + index) % totalRows;\n    var logicRows = [];\n    var rowsToRemove = amount;\n    var row;\n\n    while (physicRow < totalRows && rowsToRemove) {\n      row = Handsontable.hooks.execute(this.instance, 'modifyRow', physicRow);\n      logicRows.push(row);\n\n      rowsToRemove--;\n      physicRow++;\n    }\n\n    return logicRows;\n  };\n\n  /**\n   * Clears the data array\n   */\n  Handsontable.DataMap.prototype.clear = function () {\n    for (var r = 0; r < this.instance.countRows(); r++) {\n      for (var c = 0; c < this.instance.countCols(); c++) {\n        this.set(r, this.colToProp(c), '');\n      }\n    }\n  };\n\n  /**\n   * Returns the data array\n   * @return {Array}\n   */\n  Handsontable.DataMap.prototype.getAll = function () {\n    return this.dataSource;\n  };\n\n  /**\n   * Returns data range as array\n   * @param {Object} start Start selection position\n   * @param {Object} end End selection position\n   * @param {Number} destination Destination of datamap.get\n   * @return {Array}\n   */\n  Handsontable.DataMap.prototype.getRange = function (start, end, destination) {\n    var r, rlen, c, clen, output = [], row;\n    var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n    rlen = Math.max(start.row, end.row);\n    clen = Math.max(start.col, end.col);\n    for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n      row = [];\n      for (c = Math.min(start.col, end.col); c <= clen; c++) {\n        row.push(getFn.call(this, r, this.colToProp(c)));\n      }\n      output.push(row);\n    }\n    return output;\n  };\n\n  /**\n   * Return data as text (tab separated columns)\n   * @param {Object} start (Optional) Start selection position\n   * @param {Object} end (Optional) End selection position\n   * @return {String}\n   */\n  Handsontable.DataMap.prototype.getText = function (start, end) {\n    return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_RENDERER));\n  };\n\n  /**\n   * Return data as copyable text (tab separated columns intended for clipboard copy to an external application)\n   * @param {Object} start (Optional) Start selection position\n   * @param {Object} end (Optional) End selection position\n   * @return {String}\n   */\n  Handsontable.DataMap.prototype.getCopyableText = function (start, end) {\n    return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));\n  };\n\n})(Handsontable);\n\n(function (Handsontable) {\n  'use strict';\n\n  /*\n    Adds appropriate CSS class to table cell, based on cellProperties\n   */\n  Handsontable.renderers.cellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {\n    if (cellProperties.className) {\n      if(TD.className) {\n        TD.className = TD.className + \" \" + cellProperties.className;\n      } else {\n        TD.className = cellProperties.className;\n      }\n\n    }\n\n    if (cellProperties.readOnly) {\n      Handsontable.Dom.addClass(TD, cellProperties.readOnlyCellClassName);\n    }\n\n    if (cellProperties.valid === false && cellProperties.invalidCellClassName) {\n      Handsontable.Dom.addClass(TD, cellProperties.invalidCellClassName);\n    }\n\n    if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {\n      Handsontable.Dom.addClass(TD, cellProperties.noWordWrapClassName);\n    }\n\n    if (!value && cellProperties.placeholder) {\n      Handsontable.Dom.addClass(TD, cellProperties.placeholderCellClassName);\n    }\n  }\n\n})(Handsontable);\n/**\n * Default text renderer\n * @param {Object} instance Handsontable instance\n * @param {Element} TD Table cell where to render\n * @param {Number} row\n * @param {Number} col\n * @param {String|Number} prop Row object property name\n * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)\n * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)\n */\n(function (Handsontable) {\n  'use strict';\n\n  var TextRenderer = function (instance, TD, row, col, prop, value, cellProperties) {\n\n    Handsontable.renderers.cellDecorator.apply(this, arguments);\n\n    if (!value && cellProperties.placeholder) {\n      value = cellProperties.placeholder;\n    }\n\n    var escaped = Handsontable.helper.stringify(value);\n\n    if (cellProperties.rendererTemplate) {\n      Handsontable.Dom.empty(TD);\n      var TEMPLATE = document.createElement('TEMPLATE');\n      TEMPLATE.setAttribute('bind', '{{}}');\n      TEMPLATE.innerHTML = cellProperties.rendererTemplate;\n      HTMLTemplateElement.decorate(TEMPLATE);\n      TEMPLATE.model = instance.getSourceDataAtRow(row);\n      TD.appendChild(TEMPLATE);\n    }\n    else {\n      Handsontable.Dom.fastInnerText(TD, escaped); //this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n    }\n\n  };\n\n  //Handsontable.TextRenderer = TextRenderer; //Left for backward compatibility\n  Handsontable.renderers.TextRenderer = TextRenderer;\n  Handsontable.renderers.registerRenderer('text', TextRenderer);\n\n})(Handsontable);\n\n(function (Handsontable) {\n\n  var clonableWRAPPER = document.createElement('DIV');\n  clonableWRAPPER.className = 'htAutocompleteWrapper';\n\n  var clonableARROW = document.createElement('DIV');\n  clonableARROW.className = 'htAutocompleteArrow';\n  clonableARROW.appendChild(document.createTextNode(String.fromCharCode(9660))); // workaround for https://github.com/handsontable/handsontable/issues/1946\n//this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n\n  var wrapTdContentWithWrapper = function(TD, WRAPPER){\n    WRAPPER.innerHTML = TD.innerHTML;\n    Handsontable.Dom.empty(TD);\n    TD.appendChild(WRAPPER);\n  };\n\n  /**\n   * Autocomplete renderer\n   * @param {Object} instance Handsontable instance\n   * @param {Element} TD Table cell where to render\n   * @param {Number} row\n   * @param {Number} col\n   * @param {String|Number} prop Row object property name\n   * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)\n   * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)\n   */\n  var AutocompleteRenderer = function (instance, TD, row, col, prop, value, cellProperties) {\n\n    var WRAPPER = clonableWRAPPER.cloneNode(true); //this is faster than createElement\n    var ARROW = clonableARROW.cloneNode(true); //this is faster than createElement\n\n    Handsontable.renderers.TextRenderer(instance, TD, row, col, prop, value, cellProperties);\n\n    TD.appendChild(ARROW);\n    Handsontable.Dom.addClass(TD, 'htAutocomplete');\n\n\n    if (!TD.firstChild) { //http://jsperf.com/empty-node-if-needed\n      //otherwise empty fields appear borderless in demo/renderers.html (IE)\n      TD.appendChild(document.createTextNode(String.fromCharCode(160))); // workaround for https://github.com/handsontable/handsontable/issues/1946\n      //this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n    }\n\n\n\n    if (!instance.acArrowListener) {\n      var eventManager = Handsontable.eventManager(instance);\n\n      //not very elegant but easy and fast\n      instance.acArrowListener = function (event) {\n        if (Handsontable.Dom.hasClass(event.target,'htAutocompleteArrow')) {\n          instance.view.wt.getSetting('onCellDblClick', null, new WalkontableCellCoords(row, col), TD);\n        }\n      };\n\n      eventManager.addEventListener(instance.rootElement,'mousedown',instance.acArrowListener);\n\n      //We need to unbind the listener after the table has been destroyed\n      instance.addHookOnce('afterDestroy', function () {\n        eventManager.clear();\n      });\n\n    }\n  };\n\n  Handsontable.AutocompleteRenderer = AutocompleteRenderer;\n  Handsontable.renderers.AutocompleteRenderer = AutocompleteRenderer;\n  Handsontable.renderers.registerRenderer('autocomplete', AutocompleteRenderer);\n})(Handsontable);\n\n/**\n * Checkbox renderer\n * @param {Object} instance Handsontable instance\n * @param {Element} TD Table cell where to render\n * @param {Number} row\n * @param {Number} col\n * @param {String|Number} prop Row object property name\n * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)\n * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)\n */\n(function (Handsontable) {\n\n  'use strict';\n\n  var clonableINPUT = document.createElement('INPUT');\n  clonableINPUT.className = 'htCheckboxRendererInput';\n  clonableINPUT.type = 'checkbox';\n  clonableINPUT.setAttribute('autocomplete', 'off');\n\n  var CheckboxRenderer = function (instance, TD, row, col, prop, value, cellProperties) {\n\n    var eventManager = Handsontable.eventManager(instance);\n\n    if (typeof cellProperties.checkedTemplate === \"undefined\") {\n      cellProperties.checkedTemplate = true;\n    }\n    if (typeof cellProperties.uncheckedTemplate === \"undefined\") {\n      cellProperties.uncheckedTemplate = false;\n    }\n\n    Handsontable.Dom.empty(TD); //TODO identify under what circumstances this line can be removed\n\n    var INPUT = clonableINPUT.cloneNode(false); //this is faster than createElement\n\n    if (value === cellProperties.checkedTemplate || value === Handsontable.helper.stringify(cellProperties.checkedTemplate)) {\n      INPUT.checked = true;\n      TD.appendChild(INPUT);\n    }\n    else if (value === cellProperties.uncheckedTemplate || value === Handsontable.helper.stringify(cellProperties.uncheckedTemplate)) {\n      TD.appendChild(INPUT);\n    }\n    else if (value === null) { //default value\n      INPUT.className += ' noValue';\n      TD.appendChild(INPUT);\n    }\n    else {\n      Handsontable.Dom.fastInnerText(TD, '#bad value#'); //this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n    }\n\n    if (cellProperties.readOnly) {\n      eventManager.addEventListener(INPUT,'click',function (event) {\n        event.preventDefault();\n      });\n    }\n    else {\n      eventManager.addEventListener(INPUT,'mousedown',function (event) {\n        Handsontable.helper.stopPropagation(event);\n        //event.stopPropagation(); //otherwise can confuse cell mousedown handler\n      });\n\n      eventManager.addEventListener(INPUT,'mouseup',function (event) {\n        Handsontable.helper.stopPropagation(event);\n        //event.stopPropagation(); //otherwise can confuse cell dblclick handler\n      });\n\n      eventManager.addEventListener(INPUT,'change',function () {\n        if (this.checked) {\n          instance.setDataAtRowProp(row, prop, cellProperties.checkedTemplate);\n        }\n        else {\n          instance.setDataAtRowProp(row, prop, cellProperties.uncheckedTemplate);\n        }\n      });\n    }\n\n    if(!instance.CheckboxRenderer || !instance.CheckboxRenderer.beforeKeyDownHookBound){\n      instance.CheckboxRenderer = {\n        beforeKeyDownHookBound : true\n      };\n\n      instance.addHook('beforeKeyDown', function(event){\n\n        Handsontable.Dom.enableImmediatePropagation(event);\n\n        if(event.keyCode == Handsontable.helper.keyCode.SPACE || event.keyCode == Handsontable.helper.keyCode.ENTER){\n\n          var cell, checkbox, cellProperties;\n\n          var selRange = instance.getSelectedRange();\n          var topLeft = selRange.getTopLeftCorner();\n          var bottomRight = selRange.getBottomRightCorner();\n\n          for(var row = topLeft.row; row <= bottomRight.row; row++ ){\n            for(var col = topLeft.col; col <= bottomRight.col; col++){\n              cell = instance.getCell(row, col);\n              cellProperties = instance.getCellMeta(row, col);\n\n              checkbox = cell.querySelectorAll('input[type=checkbox]');\n\n              if(checkbox.length > 0 && !cellProperties.readOnly){\n\n                if(!event.isImmediatePropagationStopped()){\n                  event.stopImmediatePropagation();\n                  event.preventDefault();\n                }\n\n                for(var i = 0, len = checkbox.length; i < len; i++){\n                  checkbox[i].checked = !checkbox[i].checked;\n                  eventManager.fireEvent(checkbox[i], 'change');\n                }\n\n              }\n\n            }\n          }\n        }\n      });\n    }\n\n  };\n\n  Handsontable.CheckboxRenderer = CheckboxRenderer;\n  Handsontable.renderers.CheckboxRenderer = CheckboxRenderer;\n  Handsontable.renderers.registerRenderer('checkbox', CheckboxRenderer);\n\n})(Handsontable);\n\n/**\n * Numeric cell renderer\n * @param {Object} instance Handsontable instance\n * @param {Element} TD Table cell where to render\n * @param {Number} row\n * @param {Number} col\n * @param {String|Number} prop Row object property name\n * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)\n * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)\n */\n(function (Handsontable) {\n\n  'use strict';\n\n  var NumericRenderer = function (instance, TD, row, col, prop, value, cellProperties) {\n    if (Handsontable.helper.isNumeric(value)) {\n      if (typeof cellProperties.language !== 'undefined') {\n        numeral.language(cellProperties.language)\n      }\n      value = numeral(value).format(cellProperties.format || '0'); //docs: http://numeraljs.com/\n      Handsontable.Dom.addClass(TD, 'htNumeric');\n    }\n    Handsontable.renderers.TextRenderer(instance, TD, row, col, prop, value, cellProperties);\n  };\n\n  Handsontable.NumericRenderer = NumericRenderer; //Left for backward compatibility with versions prior 0.10.0\n  Handsontable.renderers.NumericRenderer = NumericRenderer;\n  Handsontable.renderers.registerRenderer('numeric', NumericRenderer);\n\n})(Handsontable);\n(function(Handosntable){\n\n  'use strict';\n\n  var PasswordRenderer = function (instance, TD, row, col, prop, value, cellProperties) {\n    Handsontable.renderers.TextRenderer.apply(this, arguments);\n\n    value = TD.innerHTML;\n\n    var hash;\n    var hashLength = cellProperties.hashLength || value.length;\n    var hashSymbol = cellProperties.hashSymbol || '*';\n\n    for( hash = ''; hash.split(hashSymbol).length - 1 < hashLength; hash += hashSymbol);\n\n    Handsontable.Dom.fastInnerHTML(TD, hash);\n\n  };\n\n  Handosntable.PasswordRenderer = PasswordRenderer;\n  Handosntable.renderers.PasswordRenderer = PasswordRenderer;\n  Handosntable.renderers.registerRenderer('password', PasswordRenderer);\n\n})(Handsontable);\n(function (Handsontable) {\n\n  function HtmlRenderer(instance, TD, row, col, prop, value, cellProperties){\n\n    Handsontable.renderers.cellDecorator.apply(this, arguments);\n\n    Handsontable.Dom.fastInnerHTML(TD, value);\n  }\n\n  Handsontable.renderers.registerRenderer('html', HtmlRenderer);\n  Handsontable.renderers.HtmlRenderer = HtmlRenderer;\n\n})(Handsontable);\n\n(function (Handsontable) {\n  'use strict';\n\n  Handsontable.EditorState = {\n    VIRGIN: 'STATE_VIRGIN', //before editing\n    EDITING: 'STATE_EDITING',\n    WAITING: 'STATE_WAITING', //waiting for async validation\n    FINISHED: 'STATE_FINISHED'\n  };\n\n  function BaseEditor(instance) {\n    this.instance = instance;\n    this.state = Handsontable.EditorState.VIRGIN;\n\n    this._opened = false;\n    this._closeCallback = null;\n\n    this.init();\n  }\n\n  BaseEditor.prototype._fireCallbacks = function(result) {\n    if(this._closeCallback){\n      this._closeCallback(result);\n      this._closeCallback = null;\n    }\n\n  }\n\n  BaseEditor.prototype.init = function(){};\n\n  BaseEditor.prototype.getValue = function(){\n    throw Error('Editor getValue() method unimplemented');\n  };\n\n  BaseEditor.prototype.setValue = function(newValue){\n    throw Error('Editor setValue() method unimplemented');\n  };\n\n  BaseEditor.prototype.open = function(){\n    throw Error('Editor open() method unimplemented');\n  };\n\n  BaseEditor.prototype.close = function(){\n    throw Error('Editor close() method unimplemented');\n  };\n\n  BaseEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties){\n    this.TD = td;\n    this.row = row;\n    this.col = col;\n    this.prop = prop;\n    this.originalValue = originalValue;\n    this.cellProperties = cellProperties;\n\n    this.state = Handsontable.EditorState.VIRGIN;\n  };\n\n  BaseEditor.prototype.extend = function(){\n    var baseClass = this.constructor;\n    function Editor(){\n      baseClass.apply(this, arguments);\n    }\n\n    function inherit(Child, Parent){\n      function Bridge() {\n      }\n\n      Bridge.prototype = Parent.prototype;\n      Child.prototype = new Bridge();\n      Child.prototype.constructor = Child;\n      return Child;\n    }\n\n    return inherit(Editor, baseClass);\n  };\n\n  BaseEditor.prototype.saveValue = function (val, ctrlDown) {\n    if (ctrlDown) { //if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)\n      var sel = this.instance.getSelected()\n        , tmp;\n\n      if(sel[0] > sel[2]) {\n        tmp = sel[0];\n        sel[0] = sel[2];\n        sel[2] = tmp;\n      }\n      if(sel[1] > sel[3]) {\n        tmp = sel[1];\n        sel[1] = sel[3];\n        sel[3] = tmp;\n      }\n\n      this.instance.populateFromArray(sel[0], sel[1], val, sel[2], sel[3], 'edit');\n    }\n    else {\n      this.instance.populateFromArray(this.row, this.col, val, null, null, 'edit');\n    }\n  };\n\n  BaseEditor.prototype.beginEditing = function(initialValue){\n    if (this.state != Handsontable.EditorState.VIRGIN) {\n      return;\n    }\n\n    this.instance.view.scrollViewport(new WalkontableCellCoords(this.row, this.col));\n    this.instance.view.render();\n\n    this.state = Handsontable.EditorState.EDITING;\n\n    initialValue = typeof initialValue == 'string' ? initialValue : this.originalValue;\n\n    this.setValue(Handsontable.helper.stringify(initialValue));\n\n    this.open();\n    this._opened = true;\n    this.focus();\n\n    this.instance.view.render(); //only rerender the selections (FillHandle should disappear when beginediting is triggered)\n  };\n\n  BaseEditor.prototype.finishEditing = function (restoreOriginalValue, ctrlDown, callback) {\n\n    if (callback) {\n      var previousCloseCallback = this._closeCallback;\n      this._closeCallback = function (result) {\n        if(previousCloseCallback){\n          previousCloseCallback(result);\n        }\n\n        callback(result);\n      };\n    }\n\n    if (this.isWaiting()) {\n      return;\n    }\n\n    if (this.state == Handsontable.EditorState.VIRGIN) {\n      var that = this;\n      this.instance._registerTimeout(setTimeout(function () {\n        that._fireCallbacks(true);\n      }, 0));\n      return;\n    }\n\n    if (this.state == Handsontable.EditorState.EDITING) {\n\n      if (restoreOriginalValue) {\n\n        this.cancelChanges();\n        this.instance.view.render();\n        return;\n\n      }\n\n\n      var val = [\n        [String.prototype.trim.call(this.getValue())] //String.prototype.trim is defined in Walkontable polyfill.js\n      ];\n\n      this.state = Handsontable.EditorState.WAITING;\n\n      this.saveValue(val, ctrlDown);\n\n      if(this.instance.getCellValidator(this.cellProperties)){\n        var that = this;\n        this.instance.addHookOnce('afterValidate', function (result) {\n          that.state = Handsontable.EditorState.FINISHED;\n          that.discardEditor(result);\n        });\n      } else {\n        this.state = Handsontable.EditorState.FINISHED;\n        this.discardEditor(true);\n      }\n\n    }\n  };\n\n  BaseEditor.prototype.cancelChanges = function () {\n    this.state = Handsontable.EditorState.FINISHED;\n    this.discardEditor();\n  };\n\n  BaseEditor.prototype.discardEditor = function (result) {\n    if (this.state !== Handsontable.EditorState.FINISHED) {\n      return;\n    }\n\n    if (result === false && this.cellProperties.allowInvalid !== true) { //validator was defined and failed\n\n      this.instance.selectCell(this.row, this.col);\n      this.focus();\n\n      this.state = Handsontable.EditorState.EDITING;\n\n      this._fireCallbacks(false);\n    }\n    else {\n      this.close();\n      this._opened = false;\n\n      this.state = Handsontable.EditorState.VIRGIN;\n\n      this._fireCallbacks(true);\n    }\n\n  };\n\n  BaseEditor.prototype.isOpened = function(){\n    return this._opened;\n  };\n\n  BaseEditor.prototype.isWaiting = function () {\n    return this.state === Handsontable.EditorState.WAITING;\n  };\n\n  Handsontable.editors.BaseEditor = BaseEditor;\n\n})(Handsontable);\n\n(function(Handsontable){\n  var TextEditor = Handsontable.editors.BaseEditor.prototype.extend();\n\n  TextEditor.prototype.init = function(){\n    var that = this;\n    this.createElements();\n    this.eventManager = new Handsontable.eventManager(this);\n    this.bindEvents();\n    this.autoResize = autoResize();\n\n    this.instance.addHook('afterDestroy', function () {\n      that.destroy();\n    });\n  };\n\n  TextEditor.prototype.getValue = function(){\n    return this.TEXTAREA.value\n  };\n\n  TextEditor.prototype.setValue = function(newValue){\n    this.TEXTAREA.value = newValue;\n  };\n\n  var onBeforeKeyDown =  function onBeforeKeyDown(event){\n\n    var instance = this;\n    var that = instance.getActiveEditor();\n\n    var keyCodes = Handsontable.helper.keyCode;\n    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n\n    Handsontable.Dom.enableImmediatePropagation(event);\n\n    //Process only events that have been fired in the editor\n    if (event.target !== that.TEXTAREA || event.isImmediatePropagationStopped()){\n      return;\n    }\n\n    if (event.keyCode === 17 || event.keyCode === 224 || event.keyCode === 91 || event.keyCode === 93) {\n      //when CTRL or its equivalent is pressed and cell is edited, don't prepare selectable text in textarea\n      event.stopImmediatePropagation();\n      return;\n    }\n\n    switch (event.keyCode) {\n      case keyCodes.ARROW_RIGHT:\n        if (Handsontable.Dom.getCaretPosition(that.TEXTAREA) !== that.TEXTAREA.value.length) {\n          event.stopImmediatePropagation();\n        }\n        break;\n\n      case keyCodes.ARROW_LEFT: /* arrow left */\n        if (Handsontable.Dom.getCaretPosition(that.TEXTAREA) !== 0) {\n          event.stopImmediatePropagation();\n        }\n        break;\n\n      case keyCodes.ENTER:\n        var selected = that.instance.getSelected();\n        var isMultipleSelection = !(selected[0] === selected[2] && selected[1] === selected[3]);\n        if ((ctrlDown && !isMultipleSelection) || event.altKey) { //if ctrl+enter or alt+enter, add new line\n          if(that.isOpened()){\n            that.setValue(that.getValue() + '\\n');\n            that.focus();\n          } else {\n            that.beginEditing(that.originalValue + '\\n')\n          }\n          event.stopImmediatePropagation();\n        }\n        event.preventDefault(); //don't add newline to field\n        break;\n\n      case keyCodes.A:\n      case keyCodes.X:\n      case keyCodes.C:\n      case keyCodes.V:\n        if(ctrlDown){\n          event.stopImmediatePropagation(); //CTRL+A, CTRL+C, CTRL+V, CTRL+X should only work locally when cell is edited (not in table context)\n        }\n        break;\n\n      case keyCodes.BACKSPACE:\n      case keyCodes.DELETE:\n      case keyCodes.HOME:\n      case keyCodes.END:\n        event.stopImmediatePropagation(); //backspace, delete, home, end should only work locally when cell is edited (not in table context)\n        break;\n    }\n\n    that.autoResize.resize(String.fromCharCode(event.keyCode));\n  };\n\n\n\n  TextEditor.prototype.open = function(){\n    this.refreshDimensions(); //need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348\n\n    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);\n  };\n\n  TextEditor.prototype.close = function(){\n    this.textareaParentStyle.display = 'none';\n\n    this.autoResize.unObserve();\n\n    if (document.activeElement === this.TEXTAREA) {\n      this.instance.listen(); //don't refocus the table if user focused some cell outside of HT on purpose\n    }\n\n    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);\n  };\n\n  TextEditor.prototype.focus = function(){\n    this.TEXTAREA.focus();\n    Handsontable.Dom.setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  };\n\n  TextEditor.prototype.createElements = function () {\n//    this.$body = $(document.body);\n\n    this.TEXTAREA = document.createElement('TEXTAREA');\n\n    Handsontable.Dom.addClass(this.TEXTAREA, 'handsontableInput');\n\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n\n    this.TEXTAREA_PARENT = document.createElement('DIV');\n    Handsontable.Dom.addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');\n\n    this.textareaParentStyle = this.TEXTAREA_PARENT.style;\n    this.textareaParentStyle.top = 0;\n    this.textareaParentStyle.left = 0;\n    this.textareaParentStyle.display = 'none';\n\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n\n    this.instance.rootElement.appendChild(this.TEXTAREA_PARENT);\n\n    var that = this;\n    this.instance._registerTimeout(setTimeout(function () {\n      that.refreshDimensions();\n    }, 0));\n  };\n\n  TextEditor.prototype.checkEditorSection = function () {\n    if(this.row < this.instance.getSettings().fixedRowsTop) {\n      if(this.col < this.instance.getSettings().fixedColumnsLeft) {\n        return 'corner';\n      } else {\n        return 'top';\n      }\n    } else {\n      if(this.col < this.instance.getSettings().fixedColumnsLeft) {\n        return 'left';\n      }\n    }\n  };\n\n  TextEditor.prototype.getEditedCell = function () {\n    var editorSection = this.checkEditorSection()\n      , editedCell;\n\n    switch (editorSection) {\n      case 'top':\n        editedCell = this.instance.view.wt.wtScrollbars.vertical.clone.wtTable.getCell({row: this.row, col: this.col});\n        this.textareaParentStyle.zIndex = 101;\n        break;\n      case 'corner':\n        editedCell = this.instance.view.wt.wtScrollbars.corner.clone.wtTable.getCell({row: this.row, col: this.col});\n        this.textareaParentStyle.zIndex = 103;\n        break;\n      case 'left':\n        editedCell = this.instance.view.wt.wtScrollbars.horizontal.clone.wtTable.getCell({row: this.row, col: this.col});\n        this.textareaParentStyle.zIndex = 102;\n        break;\n      default :\n        editedCell = this.instance.getCell(this.row, this.col);\n        this.textareaParentStyle.zIndex = \"\";\n        break;\n    }\n\n    return editedCell != -1 && editedCell != -2 ? editedCell : void 0;\n  };\n\n\n  TextEditor.prototype.refreshDimensions = function () {\n    if (this.state !== Handsontable.EditorState.EDITING) {\n      return;\n    }\n\n    ///start prepare textarea position\n//    this.TD = this.instance.getCell(this.row, this.col);\n    this.TD = this.getEditedCell();\n\n    if (!this.TD) {\n      //TD is outside of the viewport. Otherwise throws exception when scrolling the table while a cell is edited\n      return;\n    }\n    //var $td = $(this.TD); //because old td may have been scrolled out with scrollViewport\n\n    var currentOffset = Handsontable.Dom.offset(this.TD);\n    var containerOffset = Handsontable.Dom.offset(this.instance.rootElement);\n    var editTop = currentOffset.top - containerOffset.top - 1;\n    var editLeft = currentOffset.left - containerOffset.left - 1;\n\n    var settings = this.instance.getSettings();\n    var rowHeadersCount = settings.rowHeaders === false ? 0 : 1;\n    var colHeadersCount = settings.colHeaders === false ? 0 : 1;\n    var editorSection = this.checkEditorSection();\n    var cssTransformOffset;\n\n    // TODO: Refactor this to the new instance.getCell method (from #ply-59), after 0.12.1 is released\n    switch(editorSection) {\n      case 'top':\n        cssTransformOffset = Handsontable.Dom.getCssTransform(this.instance.view.wt.wtScrollbars.vertical.clone.wtTable.holder.parentNode);\n        break;\n      case 'left':\n        cssTransformOffset = Handsontable.Dom.getCssTransform(this.instance.view.wt.wtScrollbars.horizontal.clone.wtTable.holder.parentNode);\n        break;\n      case 'corner':\n        cssTransformOffset = Handsontable.Dom.getCssTransform(this.instance.view.wt.wtScrollbars.corner.clone.wtTable.holder.parentNode);\n        break;\n    }\n\n    if (editTop < 0) {\n      editTop = 0;\n    }\n    if (editLeft < 0) {\n      editLeft = 0;\n    }\n    if (rowHeadersCount > 0 && parseInt(this.TD.style.borderTopWidth, 10) > 0) {\n      editTop += 1;\n    }\n    if (colHeadersCount > 0 && parseInt(this.TD.style.borderLeftWidth, 10) > 0) {\n      editLeft += 1;\n    }\n\n\n    if(cssTransformOffset && cssTransformOffset != -1) {\n      this.textareaParentStyle[cssTransformOffset[0]] = cssTransformOffset[1];\n    } else {\n      Handsontable.Dom.resetCssTransform(this.textareaParentStyle);\n    }\n\n    this.textareaParentStyle.top = editTop + 'px';\n    this.textareaParentStyle.left = editLeft + 'px';\n\n    ///end prepare textarea position\n\n\n    var cellTopOffset = this.TD.offsetTop - this.instance.view.wt.wtScrollbars.vertical.getScrollPosition(),\n        cellLeftOffset = this.TD.offsetLeft - this.instance.view.wt.wtScrollbars.horizontal.getScrollPosition();\n\n    var width = Handsontable.Dom.innerWidth(this.TD) - 8  //$td.width()\n      , maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 10 //10 is TEXTAREAs border and padding\n      , height = Handsontable.Dom.outerHeight(this.TD) - 4  //$td.outerHeight() - 4\n      , maxHeight = this.instance.view.maximumVisibleElementHeight(cellTopOffset) - 2; //10 is TEXTAREAs border and padding\n\n    if (parseInt(this.TD.style.borderTopWidth, 10) > 0) {\n      height -= 1;\n    }\n    if (parseInt(this.TD.style.borderLeftWidth, 10) > 0) {\n      if (rowHeadersCount > 0) {\n        width -= 1;\n      }\n    }\n\n    this.TEXTAREA.style.fontSize = Handsontable.Dom.getComputedStyle(this.TD).fontSize;\n    this.TEXTAREA.style.fontFamily = Handsontable.Dom.getComputedStyle(this.TD).fontFamily;\n\n    this.autoResize.init(this.TEXTAREA, {\n      minHeight: Math.min(height, maxHeight),\n      maxHeight: maxHeight, //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n      minWidth: Math.min(width, maxWidth),\n      maxWidth: maxWidth //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n    }, true);\n\n    this.textareaParentStyle.display = 'block';\n  };\n\n  TextEditor.prototype.bindEvents = function () {\n    var editor = this;\n\n    this.eventManager.addEventListener(this.TEXTAREA, 'cut',function (event){\n      Handsontable.helper.stopPropagation(event);\n      //event.stopPropagation();\n    });\n\n    this.eventManager.addEventListener(this.TEXTAREA, 'paste', function (event){\n      Handsontable.helper.stopPropagation(event);\n      //event.stopPropagation();\n    });\n\n    this.instance.addHook('afterScrollVertically', function () {\n      editor.refreshDimensions();\n    });\n\n    this.instance.addHook('afterDestroy', function () {\n      editor.eventManager.clear();\n    });\n  };\n\n  TextEditor.prototype.destroy = function () {\n    this.eventManager.clear();\n  };\n\n\n  Handsontable.editors.TextEditor = TextEditor;\n  Handsontable.editors.registerEditor('text', Handsontable.editors.TextEditor);\n\n})(Handsontable);\n\n(function (Handsontable) {\n\n  var MobileTextEditor = Handsontable.editors.BaseEditor.prototype.extend();\n\n  var domDimensionsCache = {};\n\n  var createControls = function () {\n    this.controls = {};\n\n    this.controls.leftButton = document.createElement('DIV');\n    this.controls.leftButton.className = 'leftButton';\n    this.controls.rightButton = document.createElement('DIV');\n    this.controls.rightButton.className = 'rightButton';\n    this.controls.upButton = document.createElement('DIV');\n    this.controls.upButton.className = 'upButton';\n    this.controls.downButton = document.createElement('DIV');\n    this.controls.downButton.className = 'downButton';\n\n    for(var button in this.controls) {\n      this.positionControls.appendChild(this.controls[button]);\n    }\n  };\n\n  MobileTextEditor.prototype.valueChanged = function () {\n    return this.initValue != this.getValue();\n  };\n\n  MobileTextEditor.prototype.init = function () {\n    var that = this;\n    this.eventManager = new Handsontable.eventManager(this.instance);\n\n    this.createElements();\n    this.bindEvents();\n\n    this.instance.addHook('afterDestroy', function () {\n      that.destroy();\n    });\n\n  };\n\n  MobileTextEditor.prototype.getValue = function () {\n    return this.TEXTAREA.value\n  };\n\n  MobileTextEditor.prototype.setValue = function (newValue) {\n    this.initValue = newValue;\n\n    this.TEXTAREA.value = newValue;\n  };\n\n  MobileTextEditor.prototype.createElements = function () {\n    this.editorContainer = document.createElement('DIV');\n    this.editorContainer.className = \"htMobileEditorContainer\";\n\n    this.cellPointer = document.createElement('DIV');\n    this.cellPointer.className = \"cellPointer\";\n\n    this.moveHandle = document.createElement('DIV');\n    this.moveHandle.className = \"moveHandle\";\n\n    this.inputPane = document.createElement('DIV');\n    this.inputPane.className = \"inputs\";\n\n    this.positionControls = document.createElement('DIV');\n    this.positionControls.className = \"positionControls\";\n\n    this.TEXTAREA = document.createElement('TEXTAREA');\n    Handsontable.Dom.addClass(this.TEXTAREA, 'handsontableInput');\n\n    this.inputPane.appendChild(this.TEXTAREA);\n\n    this.editorContainer.appendChild(this.cellPointer);\n    this.editorContainer.appendChild(this.moveHandle);\n    this.editorContainer.appendChild(this.inputPane);\n    this.editorContainer.appendChild(this.positionControls);\n\n    createControls.call(this);\n\n    document.body.appendChild(this.editorContainer);\n  };\n\n  MobileTextEditor.prototype.onBeforeKeyDown = function (event) {\n    var instance = this;\n    var that = instance.getActiveEditor();\n\n    Handsontable.Dom.enableImmediatePropagation(event);\n\n    if (event.target !== that.TEXTAREA || event.isImmediatePropagationStopped()){\n      return;\n    }\n\n    var keyCodes = Handsontable.helper.keyCode;\n\n    switch(event.keyCode) {\n      case keyCodes.ENTER:\n        that.close();\n        event.preventDefault(); //don't add newline to field\n        break;\n      case keyCodes.BACKSPACE:\n        event.stopImmediatePropagation(); //backspace, delete, home, end should only work locally when cell is edited (not in table context)\n        break;\n    }\n  };\n\n  MobileTextEditor.prototype.open = function () {\n    this.instance.addHook('beforeKeyDown', this.onBeforeKeyDown);\n\n    Handsontable.Dom.addClass(this.editorContainer, 'active');\n    //this.updateEditorDimensions();\n    //this.scrollToView();\n    Handsontable.Dom.removeClass(this.cellPointer, 'hidden');\n\n    this.updateEditorPosition();\n  };\n\n  MobileTextEditor.prototype.focus = function(){\n    this.TEXTAREA.focus();\n    Handsontable.Dom.setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  };\n\n  MobileTextEditor.prototype.close = function () {\n    this.TEXTAREA.blur();\n    this.instance.removeHook('beforeKeyDown', this.onBeforeKeyDown);\n\n    Handsontable.Dom.removeClass(this.editorContainer, 'active');\n  };\n\n  MobileTextEditor.prototype.scrollToView = function () {\n    var coords = this.instance.getSelectedRange().highlight;\n    this.instance.view.scrollViewport(coords);\n  };\n\n  MobileTextEditor.prototype.hideCellPointer = function () {\n    if(!Handsontable.Dom.hasClass(this.cellPointer, 'hidden')) {\n      Handsontable.Dom.addClass(this.cellPointer, 'hidden');\n    }\n  };\n\n  MobileTextEditor.prototype.updateEditorPosition = function (x, y) {\n    if(x && y) {\n      x = parseInt(x, 10);\n      y = parseInt(y, 10);\n\n      this.editorContainer.style.top = y + \"px\";\n      this.editorContainer.style.left = x + \"px\";\n\n    } else {\n      var selection = this.instance.getSelected()\n        , selectedCell = this.instance.getCell(selection[0],selection[1]);\n\n      //cache sizes\n      if(!domDimensionsCache.cellPointer) {\n        domDimensionsCache.cellPointer = {\n          height: Handsontable.Dom.outerHeight(this.cellPointer),\n          width: Handsontable.Dom.outerWidth(this.cellPointer)\n        }\n      }\n      if(!domDimensionsCache.editorContainer) {\n        domDimensionsCache.editorContainer = {\n          width: Handsontable.Dom.outerWidth(this.editorContainer)\n        }\n      }\n\n      if(selectedCell != undefined) {\n        var scrollLeft = this.instance.view.wt.wtScrollbars.horizontal.scrollHandler == window ? 0 : Handsontable.Dom.getScrollLeft(this.instance.view.wt.wtScrollbars.horizontal.scrollHandler);\n        var scrollTop = this.instance.view.wt.wtScrollbars.vertical.scrollHandler == window ? 0 : Handsontable.Dom.getScrollTop(this.instance.view.wt.wtScrollbars.vertical.scrollHandler);\n\n        var selectedCellOffset = Handsontable.Dom.offset(selectedCell)\n          , selectedCellWidth = Handsontable.Dom.outerWidth(selectedCell)\n          , currentScrollPosition = {\n            x: scrollLeft,\n            y: scrollTop\n          };\n\n        this.editorContainer.style.top = parseInt(selectedCellOffset.top + Handsontable.Dom.outerHeight(selectedCell) - currentScrollPosition.y + domDimensionsCache.cellPointer.height, 10) + \"px\";\n        this.editorContainer.style.left = parseInt((window.innerWidth / 2) - (domDimensionsCache.editorContainer.width / 2) ,10) + \"px\";\n\n        if(selectedCellOffset.left + selectedCellWidth / 2 > parseInt(this.editorContainer.style.left,10) + domDimensionsCache.editorContainer.width) {\n          this.editorContainer.style.left = window.innerWidth - domDimensionsCache.editorContainer.width + \"px\";\n        } else if(selectedCellOffset.left + selectedCellWidth / 2 < parseInt(this.editorContainer.style.left,10) + 20) {\n          this.editorContainer.style.left = 0 + \"px\";\n        }\n\n        this.cellPointer.style.left = parseInt(selectedCellOffset.left - (domDimensionsCache.cellPointer.width / 2) - Handsontable.Dom.offset(this.editorContainer).left + (selectedCellWidth / 2) - currentScrollPosition.x ,10) + \"px\";\n\n      }\n    }\n  };\n\n\n  // For the optional dont-affect-editor-by-zooming feature:\n\n  //MobileTextEditor.prototype.updateEditorDimensions = function () {\n  //  if(!this.beginningWindowWidth) {\n  //    this.beginningWindowWidth = window.innerWidth;\n  //    this.beginningEditorWidth = Handsontable.Dom.outerWidth(this.editorContainer);\n  //    this.scaleRatio = this.beginningEditorWidth / this.beginningWindowWidth;\n  //\n  //    this.editorContainer.style.width = this.beginningEditorWidth + \"px\";\n  //    return;\n  //  }\n  //\n  //  var currentScaleRatio = this.beginningEditorWidth / window.innerWidth;\n  //  //if(currentScaleRatio > this.scaleRatio + 0.2 || currentScaleRatio < this.scaleRatio - 0.2) {\n  //  if(currentScaleRatio != this.scaleRatio) {\n  //    this.editorContainer.style[\"zoom\"] = (1 - ((currentScaleRatio * this.scaleRatio) - this.scaleRatio)) * 100 + \"%\";\n  //  }\n  //\n  //};\n\n  MobileTextEditor.prototype.updateEditorData = function () {\n    var selected = this.instance.getSelected()\n      , selectedValue = this.instance.getDataAtCell(selected[0], selected[1]);\n\n    this.row = selected[0];\n    this.col = selected[1];\n    this.setValue(selectedValue);\n    this.updateEditorPosition();\n  };\n\n  MobileTextEditor.prototype.prepareAndSave = function () {\n\n    if(!this.valueChanged()) {\n      return true;\n    }\n\n    var val = [\n      [String.prototype.trim.call(this.getValue())]\n    ];\n\n    this.saveValue(val);\n  };\n\n  MobileTextEditor.prototype.bindEvents = function () {\n    var that = this;\n\n    this.eventManager.addEventListener(this.controls.leftButton, \"touchend\", function (event) {\n      that.prepareAndSave();\n      that.instance.selection.transformStart(0, -1, null, true);\n      that.updateEditorData();\n      event.preventDefault();\n    });\n    this.eventManager.addEventListener(this.controls.rightButton, \"touchend\", function (event) {\n      that.prepareAndSave();\n      that.instance.selection.transformStart(0, 1, null, true);\n      that.updateEditorData();\n      event.preventDefault();\n    });\n    this.eventManager.addEventListener(this.controls.upButton, \"touchend\", function (event) {\n      that.prepareAndSave();\n      that.instance.selection.transformStart(-1, 0, null, true);\n      that.updateEditorData();\n      event.preventDefault();\n    });\n    this.eventManager.addEventListener(this.controls.downButton, \"touchend\", function (event) {\n      that.prepareAndSave();\n      that.instance.selection.transformStart(1, 0, null, true);\n      that.updateEditorData();\n      event.preventDefault();\n    });\n\n    this.eventManager.addEventListener(this.moveHandle, \"touchstart\", function (event) {\n      if (event.touches.length == 1) {\n        var touch = event.touches[0]\n          , onTouchPosition = {\n          x: that.editorContainer.offsetLeft,\n          y: that.editorContainer.offsetTop\n        }\n          , onTouchOffset = {\n          x: touch.pageX - onTouchPosition.x,\n          y: touch.pageY - onTouchPosition.y\n        };\n\n        that.eventManager.addEventListener(this, \"touchmove\", function (event) {\n          var touch = event.touches[0];\n          that.updateEditorPosition(touch.pageX - onTouchOffset.x, touch.pageY - onTouchOffset.y);\n          that.hideCellPointer();\n          event.preventDefault();\n        });\n\n      }\n    });\n\n    this.eventManager.addEventListener(document.body, \"touchend\", function (event) {\n      if(!Handsontable.Dom.isChildOf(event.target, that.editorContainer) && !Handsontable.Dom.isChildOf(event.target, that.instance.rootElement)) {\n        that.close();\n      }\n    });\n\n    this.eventManager.addEventListener(this.instance.view.wt.wtScrollbars.horizontal.scrollHandler, \"scroll\", function (event) {\n      if(that.instance.view.wt.wtScrollbars.horizontal.scrollHandler != window) {\n        that.hideCellPointer();\n      }\n    });\n\n    this.eventManager.addEventListener(this.instance.view.wt.wtScrollbars.vertical.scrollHandler, \"scroll\", function (event) {\n      if(that.instance.view.wt.wtScrollbars.vertical.scrollHandler != window) {\n        that.hideCellPointer();\n      }\n    });\n\n  };\n\n  MobileTextEditor.prototype.destroy = function () {\n    this.eventManager.clear();\n\n    this.editorContainer.parentNode.removeChild(this.editorContainer);\n  };\n\n  Handsontable.editors.MobileTextEditor = MobileTextEditor;\n  Handsontable.editors.registerEditor('mobile', Handsontable.editors.MobileTextEditor);\n\n\n\n})(Handsontable);\n\n(function(Handsontable){\n\n  //Blank editor, because all the work is done by renderer\n  var CheckboxEditor = Handsontable.editors.BaseEditor.prototype.extend();\n\n  CheckboxEditor.prototype.beginEditing = function () {\n    var checkbox = this.TD.querySelector('input[type=\"checkbox\"]');\n\n    if (checkbox) {\n      checkbox.click();\n    }\n\n  };\n\n  CheckboxEditor.prototype.finishEditing = function () {};\n\n  CheckboxEditor.prototype.init = function () {};\n  CheckboxEditor.prototype.open = function () {};\n  CheckboxEditor.prototype.close = function () {};\n  CheckboxEditor.prototype.getValue = function () {};\n  CheckboxEditor.prototype.setValue = function () {};\n  CheckboxEditor.prototype.focus = function () {};\n\n  Handsontable.editors.CheckboxEditor = CheckboxEditor;\n  Handsontable.editors.registerEditor('checkbox', CheckboxEditor);\n\n})(Handsontable);\n\n\n(function (Handsontable) {\n  var DateEditor = Handsontable.editors.TextEditor.prototype.extend();\n\n  var $;\n\n  DateEditor.prototype.init = function () {\n    if (typeof jQuery != 'undefined') {\n      $ = jQuery;\n    } else {\n      throw new Error(\"You need to include jQuery to your project in order to use the jQuery UI Datepicker.\");\n    }\n\n    if (!$.datepicker) {\n      throw new Error(\"jQuery UI Datepicker dependency not found. Did you forget to include jquery-ui.custom.js or its substitute?\");\n    }\n\n    Handsontable.editors.TextEditor.prototype.init.apply(this, arguments);\n\n    this.isCellEdited = false;\n    var that = this;\n\n    this.instance.addHook('afterDestroy', function () {\n      that.destroyElements();\n    })\n\n  };\n\n  DateEditor.prototype.createElements = function () {\n    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);\n\n    this.datePicker = document.createElement('DIV');\n    Handsontable.Dom.addClass(this.datePicker, 'htDatepickerHolder');\n    this.datePickerStyle = this.datePicker.style;\n    this.datePickerStyle.position = 'absolute';\n    this.datePickerStyle.top = 0;\n    this.datePickerStyle.left = 0;\n    this.datePickerStyle.zIndex = 99;\n    document.body.appendChild(this.datePicker);\n    this.$datePicker = $(this.datePicker);\n\n    var that = this;\n    var defaultOptions = {\n      dateFormat: \"yy-mm-dd\",\n      showButtonPanel: true,\n      changeMonth: true,\n      changeYear: true,\n      onSelect: function (dateStr) {\n        that.setValue(dateStr);\n        that.finishEditing(false);\n      }\n    };\n    this.$datePicker.datepicker(defaultOptions);\n\n    var eventManager = Handsontable.eventManager(this);\n\n    /**\n     * Prevent recognizing clicking on jQuery Datepicker as clicking outside of table\n     */\n    eventManager.addEventListener(this.datePicker, 'mousedown', function (event) {\n      Handsontable.helper.stopPropagation(event);\n      //event.stopPropagation();\n    });\n\n    this.hideDatepicker();\n  };\n\n  DateEditor.prototype.destroyElements = function () {\n    this.$datePicker.datepicker('destroy');\n    this.$datePicker.remove();\n    //var eventManager = Handsontable.eventManager(this);\n    //eventManager.removeEventListener(this.datePicker, 'mousedown');\n  };\n\n  DateEditor.prototype.open = function () {\n    Handsontable.editors.TextEditor.prototype.open.call(this);\n    this.showDatepicker();\n  };\n\n  DateEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {\n    this.hideDatepicker();\n    Handsontable.editors.TextEditor.prototype.finishEditing.apply(this, arguments);\n  };\n\n  DateEditor.prototype.showDatepicker = function () {\n    var offset = this.TD.getBoundingClientRect(),\n      DatepickerSettings,\n      datepickerSettings;\n\n    this.datePickerStyle.top = (window.pageYOffset + offset.top + Handsontable.Dom.outerHeight(this.TD)) + 'px';\n    this.datePickerStyle.left = (window.pageXOffset + offset.left) + 'px';\n\n    DatepickerSettings = function () {};\n    DatepickerSettings.prototype = this.cellProperties;\n    datepickerSettings = new DatepickerSettings();\n    datepickerSettings.defaultDate = this.originalValue || void 0;\n    this.$datePicker.datepicker('option', datepickerSettings);\n\n    if (this.originalValue) {\n      this.$datePicker.datepicker('setDate', this.originalValue);\n    }\n    this.datePickerStyle.display = 'block';\n  };\n\n  DateEditor.prototype.hideDatepicker = function () {\n    this.datePickerStyle.display = 'none';\n  };\n\n\n  Handsontable.editors.DateEditor = DateEditor;\n  Handsontable.editors.registerEditor('date', DateEditor);\n})(Handsontable);\n\n/**\n * This is inception. Using Handsontable as Handsontable editor\n */\n(function (Handsontable) {\n  \"use strict\";\n\n  var HandsontableEditor = Handsontable.editors.TextEditor.prototype.extend();\n\n  HandsontableEditor.prototype.createElements = function () {\n    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);\n\n    var DIV = document.createElement('DIV');\n    DIV.className = 'handsontableEditor';\n    this.TEXTAREA_PARENT.appendChild(DIV);\n\n    this.htContainer = DIV;\n    this.htEditor = new Handsontable(DIV);\n\n    this.assignHooks();\n  };\n\n  HandsontableEditor.prototype.prepare = function (td, row, col, prop, value, cellProperties) {\n\n    Handsontable.editors.TextEditor.prototype.prepare.apply(this, arguments);\n\n    var parent = this;\n\n    var options = {\n      startRows: 0,\n      startCols: 0,\n      minRows: 0,\n      minCols: 0,\n      className: 'listbox',\n      copyPaste: false,\n      cells: function () {\n        return {\n          readOnly: true\n        }\n      },\n      fillHandle: false,\n      afterOnCellMouseDown: function () {\n        var value = this.getValue();\n        if (value !== void 0) { //if the value is undefined then it means we don't want to set the value\n          parent.setValue(value);\n        }\n        parent.instance.destroyEditor();\n      }\n    };\n\n    if (this.cellProperties.handsontable) {\n      Handsontable.helper.extend(options, cellProperties.handsontable);\n    }\n    if (this.htEditor) {\n      this.htEditor.destroy();\n    }\n\n    this.htEditor = new Handsontable(this.htContainer, options);\n\n    //this.$htContainer.handsontable('destroy');\n    //this.$htContainer.handsontable(options);\n  };\n\n  var onBeforeKeyDown = function (event) {\n\n    if (event != null && event.isImmediatePropagationEnabled == null) {\n      event.stopImmediatePropagation = function () {\n        this.isImmediatePropagationEnabled = false;\n        this.cancelBubble = true;\n      };\n      event.isImmediatePropagationEnabled = true;\n      event.isImmediatePropagationStopped = function () {\n        return !this.isImmediatePropagationEnabled;\n      };\n    }\n\n    if (event.isImmediatePropagationStopped()) {\n      return;\n    }\n\n    var editor = this.getActiveEditor();\n\n    var innerHOT = editor.htEditor.getInstance(); //Handsontable.tmpHandsontable(editor.htContainer, 'getInstance');\n\n    var rowToSelect;\n\n    if (event.keyCode == Handsontable.helper.keyCode.ARROW_DOWN) {\n      if (!innerHOT.getSelected()) {\n        rowToSelect = 0;\n      }\n      else {\n        var selectedRow = innerHOT.getSelected()[0];\n        var lastRow = innerHOT.countRows() - 1;\n        rowToSelect = Math.min(lastRow, selectedRow + 1);\n      }\n    }\n    else if (event.keyCode == Handsontable.helper.keyCode.ARROW_UP) {\n      if (innerHOT.getSelected()) {\n        var selectedRow = innerHOT.getSelected()[0];\n        rowToSelect = selectedRow - 1;\n      }\n    }\n\n    if (rowToSelect !== void 0) {\n      if (rowToSelect < 0) {\n        innerHOT.deselectCell();\n      }\n      else {\n        innerHOT.selectCell(rowToSelect, 0);\n      }\n\n      event.preventDefault();\n      event.stopImmediatePropagation();\n\n      editor.instance.listen();\n      editor.TEXTAREA.focus();\n    }\n  };\n\n  HandsontableEditor.prototype.open = function () {\n\n    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);\n\n    Handsontable.editors.TextEditor.prototype.open.apply(this, arguments);\n\n    //this.$htContainer.handsontable('render');\n\n    //Handsontable.tmpHandsontable(this.htContainer, 'render');\n    this.htEditor.render();\n\n    if (this.cellProperties.strict) {\n      this.htEditor.selectCell(0,0);\n      this.TEXTAREA.style.visibility = 'hidden';\n    } else {\n      this.htEditor.deselectCell();\n      this.TEXTAREA.style.visibility = 'visible';\n    }\n\n    Handsontable.Dom.setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);\n\n  };\n\n  HandsontableEditor.prototype.close = function () {\n\n    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);\n    this.instance.listen();\n\n    Handsontable.editors.TextEditor.prototype.close.apply(this, arguments);\n  };\n\n  HandsontableEditor.prototype.focus = function () {\n\n    this.instance.listen();\n\n    Handsontable.editors.TextEditor.prototype.focus.apply(this, arguments);\n  };\n\n  HandsontableEditor.prototype.beginEditing = function (initialValue) {\n    var onBeginEditing = this.instance.getSettings().onBeginEditing;\n    if (onBeginEditing && onBeginEditing() === false) {\n      return;\n    }\n\n    Handsontable.editors.TextEditor.prototype.beginEditing.apply(this, arguments);\n\n  };\n\n  HandsontableEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {\n    if (this.htEditor.isListening()) { //if focus is still in the HOT editor\n\n      //if (Handsontable.tmpHandsontable(this.htContainer,'isListening')) { //if focus is still in the HOT editor\n    //if (this.$htContainer.handsontable('isListening')) { //if focus is still in the HOT editor\n      this.instance.listen(); //return the focus to the parent HOT instance\n    }\n\n    if(this.htEditor.getSelected()){\n    //if (Handsontable.tmpHandsontable(this.htContainer,'getSelected')) {\n    //if (this.$htContainer.handsontable('getSelected')) {\n    //  var value = this.$htContainer.handsontable('getInstance').getValue();\n      var value = this.htEditor.getInstance().getValue();\n      //var value = Handsontable.tmpHandsontable(this.htContainer,'getInstance').getValue();\n      if (value !== void 0) { //if the value is undefined then it means we don't want to set the value\n        this.setValue(value);\n      }\n    }\n\n    return Handsontable.editors.TextEditor.prototype.finishEditing.apply(this, arguments);\n  };\n\n  HandsontableEditor.prototype.assignHooks = function () {\n  var that = this;\n    this.instance.addHook('afterDestroy', function () {\n      if (that.htEditor) {\n        that.htEditor.destroy();\n      }\n    });\n\n  };\n\n  Handsontable.editors.HandsontableEditor = HandsontableEditor;\n  Handsontable.editors.registerEditor('handsontable', HandsontableEditor);\n\n\n\n})(Handsontable);\n\n\n\n\n\n\n(function (Handsontable) {\n  var AutocompleteEditor = Handsontable.editors.HandsontableEditor.prototype.extend();\n\n  AutocompleteEditor.prototype.init = function () {\n    Handsontable.editors.HandsontableEditor.prototype.init.apply(this, arguments);\n\n    // set choices list initial height, so Walkontable can assign it's scroll handler\n    var choicesListHot = this.htEditor.getInstance();\n    choicesListHot.updateSettings({\n      height: 1\n    });\n\n    this.query = null;\n    this.choices = [];\n  };\n\n  AutocompleteEditor.prototype.createElements = function(){\n    Handsontable.editors.HandsontableEditor.prototype.createElements.apply(this, arguments);\n\n    var getSystemSpecificPaddingClass = function () {\n      if(window.navigator.platform.indexOf('Mac') != -1) {\n        return \"htMacScroll\";\n      } else {\n        return \"\";\n      }\n    };\n\n    Handsontable.Dom.addClass(this.htContainer, 'autocompleteEditor');\n    Handsontable.Dom.addClass(this.htContainer, getSystemSpecificPaddingClass());\n    //this.$htContainer.addClass('autocompleteEditor');\n    //this.$htContainer.addClass(getSystemSpecificPaddingClass());\n\n  };\n\n  var skipOne = false;\n  var onBeforeKeyDown = function (event) {\n    skipOne = false;\n    var editor = this.getActiveEditor();\n    var keyCodes = Handsontable.helper.keyCode;\n\n    if (Handsontable.helper.isPrintableChar(event.keyCode) || event.keyCode === keyCodes.BACKSPACE || event.keyCode === keyCodes.DELETE  || event.keyCode === keyCodes.INSERT) {\n      var timeOffset = 0;\n\n      // on ctl+c / cmd+c don't update suggestion list\n      if(event.keyCode === keyCodes.C && (event.ctrlKey || event.metaKey)) {\n        return;\n      }\n\n      if(!editor.isOpened()) {\n        timeOffset += 10;\n      }\n\n      editor.instance._registerTimeout(setTimeout(function () {\n        editor.queryChoices(editor.TEXTAREA.value);\n        skipOne = true;\n      }, timeOffset));\n    }\n  };\n\n  AutocompleteEditor.prototype.prepare = function () {\n    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);\n    Handsontable.editors.HandsontableEditor.prototype.prepare.apply(this, arguments);\n  };\n\n  AutocompleteEditor.prototype.open = function () {\n    Handsontable.editors.HandsontableEditor.prototype.open.apply(this, arguments);\n\n    this.TEXTAREA.style.visibility = 'visible';\n    this.focus();\n\n\n    var choicesListHot = this.htEditor.getInstance();\n    var that = this;\n\n    choicesListHot.updateSettings({\n      'colWidths': [Handsontable.Dom.outerWidth(this.TEXTAREA) - 2],\n      afterRenderer: function (TD, row, col, prop, value) {\n        var caseSensitive = this.getCellMeta(row, col).filteringCaseSensitive === true;\n\n        if(value){\n          var indexOfMatch =  caseSensitive ? value.indexOf(this.query) : value.toLowerCase().indexOf(that.query.toLowerCase());\n\n          if(indexOfMatch != -1){\n            var match = value.substr(indexOfMatch, that.query.length);\n            TD.innerHTML = value.replace(match, '<strong>' + match + '</strong>');\n          }\n        }\n      }\n    });\n\n    if(skipOne) {\n      skipOne = false;\n    }\n    that.instance._registerTimeout(setTimeout(function () {\n      that.queryChoices(that.TEXTAREA.value);\n    }, 0));\n\n  };\n\n  AutocompleteEditor.prototype.close = function () {\n    Handsontable.editors.HandsontableEditor.prototype.close.apply(this, arguments);\n  };\n\n  AutocompleteEditor.prototype.queryChoices = function(query){\n    this.query = query;\n\n    if (typeof this.cellProperties.source == 'function'){\n      var that = this;\n\n      this.cellProperties.source(query, function(choices){\n        that.updateChoicesList(choices);\n      });\n\n    } else if (Array.isArray(this.cellProperties.source)) {\n\n      var choices;\n\n      if(!query || this.cellProperties.filter === false){\n        choices = this.cellProperties.source;\n      } else {\n\n        var filteringCaseSensitive = this.cellProperties.filteringCaseSensitive === true;\n        var lowerCaseQuery = query.toLowerCase();\n\n        choices = this.cellProperties.source.filter(function(choice){\n\n          if (filteringCaseSensitive) {\n            return choice.indexOf(query) != -1;\n          } else {\n            return choice.toLowerCase().indexOf(lowerCaseQuery) != -1;\n          }\n\n        });\n      }\n\n      this.updateChoicesList(choices);\n\n    } else {\n      this.updateChoicesList([]);\n    }\n\n  };\n\n  AutocompleteEditor.prototype.updateChoicesList = function (choices) {\n    var pos = Handsontable.Dom.getCaretPosition(this.TEXTAREA),\n        endPos = Handsontable.Dom.getSelectionEndPosition(this.TEXTAREA);\n\n    var orderByRelevance = AutocompleteEditor.sortByRelevance(this.getValue(), choices, this.cellProperties.filteringCaseSensitive);\n    var highlightIndex;\n\n    if (this.cellProperties.filter != false) {\n      var sorted = [];\n      for(var i = 0, choicesCount = orderByRelevance.length; i < choicesCount; i++) {\n        sorted.push(choices[orderByRelevance[i]]);\n      }\n      highlightIndex = 0;\n      choices = sorted;\n    }\n    else {\n      highlightIndex = orderByRelevance[0];\n    }\n\n    this.choices = choices;\n\n    this.htEditor.loadData(Handsontable.helper.pivot([choices]));\n    this.htEditor.updateSettings({height: this.getDropdownHeight()});\n    //Handsontable.tmpHandsontable(this.htContainer,'loadData', Handsontable.helper.pivot([choices]));\n    //Handsontable.tmpHandsontable(this.htContainer,'updateSettings', {height: this.getDropdownHeight()});\n\n    if (this.cellProperties.strict === true) {\n      this.highlightBestMatchingChoice(highlightIndex);\n    }\n\n    this.instance.listen();\n    this.TEXTAREA.focus();\n    Handsontable.Dom.setCaretPosition(this.TEXTAREA, pos, (pos != endPos ? endPos : void 0));\n  };\n\n  AutocompleteEditor.prototype.finishEditing = function (restoreOriginalValue) {\n    if (!restoreOriginalValue) {\n      this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);\n    }\n    Handsontable.editors.HandsontableEditor.prototype.finishEditing.apply(this, arguments);\n  };\n\n  AutocompleteEditor.prototype.highlightBestMatchingChoice = function (index) {\n    if (typeof index === \"number\") {\n       this.htEditor.selectCell(index, 0);\n    } else {\n      this.htEditor.deselectCell();\n    }\n  };\n\n  /**\n   * Filters and sorts by relevance\n   * @param value\n   * @param choices\n   * @param caseSensitive\n   * @returns {Array} array of indexes in original choices array\n   */\n  AutocompleteEditor.sortByRelevance = function(value, choices, caseSensitive) {\n\n    var choicesRelevance = []\n      , currentItem\n      , valueLength = value.length\n      , valueIndex\n      , charsLeft\n      , result = []\n      , i\n      , choicesCount;\n\n    if(valueLength === 0) {\n      for(i = 0, choicesCount = choices.length; i < choicesCount; i++) {\n        result.push(i);\n      }\n      return result;\n    }\n\n    for(i = 0, choicesCount = choices.length; i < choicesCount; i++) {\n      currentItem = choices[i];\n\n      if(caseSensitive) {\n        valueIndex = currentItem.indexOf(value);\n      } else {\n        valueIndex = currentItem.toLowerCase().indexOf(value.toLowerCase());\n      }\n\n\n      if(valueIndex == -1) { continue; }\n      charsLeft =  currentItem.length - valueIndex - valueLength;\n\n      choicesRelevance.push({\n        baseIndex: i,\n        index: valueIndex,\n        charsLeft: charsLeft,\n        value: currentItem\n      });\n    }\n\n    choicesRelevance.sort(function(a, b) {\n\n      if(b.index === -1) return -1;\n      if(a.index === -1) return 1;\n\n      if(a.index < b.index) {\n        return -1;\n      } else if(b.index < a.index) {\n        return 1;\n      } else if(a.index === b.index) {\n        if(a.charsLeft < b.charsLeft) {\n          return -1;\n        } else if(a.charsLeft > b.charsLeft) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    });\n\n    for(i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {\n      result.push(choicesRelevance[i].baseIndex);\n    }\n\n    return result;\n  };\n\n  AutocompleteEditor.prototype.getDropdownHeight = function(){\n    //var firstRowHeight = this.$htContainer.handsontable('getInstance').getRowHeight(0) || 23;\n    var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;\n    //var firstRowHeight = Handsontable.tmpHandsontable(this.htContainer,'getInstance').getRowHeight(0) || 23;\n    return this.choices.length >= 10 ? 10 * firstRowHeight : this.choices.length * firstRowHeight + 8;\n    //return 10 * this.$htContainer.handsontable('getInstance').getRowHeight(0);\n    //sorry, we can't measure row height before it was rendered. Let's use fixed height for now\n    return 230;\n  };\n\n\n  Handsontable.editors.AutocompleteEditor = AutocompleteEditor;\n  Handsontable.editors.registerEditor('autocomplete', AutocompleteEditor);\n\n})(Handsontable);\n\n(function(Handsontable){\n\n  var PasswordEditor = Handsontable.editors.TextEditor.prototype.extend();\n\n  PasswordEditor.prototype.createElements = function () {\n    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);\n\n    this.TEXTAREA = document.createElement('input');\n    this.TEXTAREA.setAttribute('type', 'password');\n    this.TEXTAREA.className = 'handsontableInput';\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n\n    Handsontable.Dom.empty(this.TEXTAREA_PARENT);\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n\n  };\n\n  Handsontable.editors.PasswordEditor = PasswordEditor;\n  Handsontable.editors.registerEditor('password', PasswordEditor);\n\n})(Handsontable);\n\n(function (Handsontable) {\n\n  var SelectEditor = Handsontable.editors.BaseEditor.prototype.extend();\n\n  SelectEditor.prototype.init = function(){\n    this.select = document.createElement('SELECT');\n    Handsontable.Dom.addClass(this.select, 'htSelectEditor');\n    this.select.style.display = 'none';\n    this.instance.rootElement.appendChild(this.select);\n  };\n\n  SelectEditor.prototype.prepare = function(){\n    Handsontable.editors.BaseEditor.prototype.prepare.apply(this, arguments);\n\n\n    var selectOptions = this.cellProperties.selectOptions;\n    var options;\n\n    if (typeof selectOptions == 'function'){\n      options =  this.prepareOptions(selectOptions(this.row, this.col, this.prop))\n    } else {\n      options =  this.prepareOptions(selectOptions);\n    }\n\n    Handsontable.Dom.empty(this.select);\n\n    for (var option in options){\n      if (options.hasOwnProperty(option)){\n        var optionElement = document.createElement('OPTION');\n        optionElement.value = option;\n        Handsontable.Dom.fastInnerHTML(optionElement, options[option]);\n        this.select.appendChild(optionElement);\n      }\n    }\n  };\n\n  SelectEditor.prototype.prepareOptions = function(optionsToPrepare){\n\n    var preparedOptions = {};\n\n    if (Array.isArray(optionsToPrepare)){\n      for(var i = 0, len = optionsToPrepare.length; i < len; i++){\n        preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];\n      }\n    }\n    else if (typeof optionsToPrepare == 'object') {\n      preparedOptions = optionsToPrepare;\n    }\n\n    return preparedOptions;\n\n  };\n\n  SelectEditor.prototype.getValue = function () {\n    return this.select.value;\n  };\n\n  SelectEditor.prototype.setValue = function (value) {\n    this.select.value = value;\n  };\n\n  var onBeforeKeyDown = function (event) {\n    var instance = this;\n    var editor = instance.getActiveEditor();\n\n    switch (event.keyCode){\n      case Handsontable.helper.keyCode.ARROW_UP:\n\n        var previousOption = editor.select.find('option:selected').prev();\n\n        if (previousOption.length == 1){\n          previousOption.prop('selected', true);\n        }\n\n        event.stopImmediatePropagation();\n        event.preventDefault();\n        break;\n\n      case Handsontable.helper.keyCode.ARROW_DOWN:\n\n        var nextOption = editor.select.find('option:selected').next();\n\n        if (nextOption.length == 1){\n          nextOption.prop('selected', true);\n        }\n\n        event.stopImmediatePropagation();\n        event.preventDefault();\n        break;\n    }\n  };\n\n  // TODO: Refactor this with the use of new getCell() after 0.12.1\n  SelectEditor.prototype.checkEditorSection = function () {\n    if(this.row < this.instance.getSettings().fixedRowsTop) {\n      if(this.col < this.instance.getSettings().fixedColumnsLeft) {\n        return 'corner';\n      } else {\n        return 'top';\n      }\n    } else {\n      if(this.col < this.instance.getSettings().fixedColumnsLeft) {\n        return 'left';\n      }\n    }\n  };\n\n  SelectEditor.prototype.open = function () {\n    var width = Handsontable.Dom.outerWidth(this.TD); //important - group layout reads together for better performance\n    var height = Handsontable.Dom.outerHeight(this.TD);\n    var rootOffset = Handsontable.Dom.offset(this.instance.rootElement);\n    var tdOffset = Handsontable.Dom.offset(this.TD);\n    var editorSection = this.checkEditorSection();\n    var cssTransformOffset;\n\n    switch(editorSection) {\n      case 'top':\n        cssTransformOffset = Handsontable.Dom.getCssTransform(this.instance.view.wt.wtScrollbars.vertical.clone.wtTable.holder.parentNode);\n        break;\n      case 'left':\n        cssTransformOffset = Handsontable.Dom.getCssTransform(this.instance.view.wt.wtScrollbars.horizontal.clone.wtTable.holder.parentNode);\n        break;\n      case 'corner':\n        cssTransformOffset = Handsontable.Dom.getCssTransform(this.instance.view.wt.wtScrollbars.corner.clone.wtTable.holder.parentNode);\n        break;\n    }\n\n    var selectStyle = this.select.style;\n\n    if(cssTransformOffset && cssTransformOffset != -1) {\n      selectStyle[cssTransformOffset[0]] = cssTransformOffset[1];\n    } else {\n      Handsontable.Dom.resetCssTransform(this.select);\n    }\n\n    selectStyle.height = height + 'px';\n    selectStyle.minWidth = width + 'px';\n    selectStyle.top = tdOffset.top - rootOffset.top + 'px';\n    selectStyle.left = tdOffset.left - rootOffset.left + 'px';\n    selectStyle.margin = '0px';\n    selectStyle.display = '';\n\n    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);\n  };\n\n  SelectEditor.prototype.close = function () {\n    this.select.style.display = 'none';\n    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);\n  };\n\n  SelectEditor.prototype.focus = function () {\n    this.select.focus();\n  };\n\n  Handsontable.editors.SelectEditor = SelectEditor;\n  Handsontable.editors.registerEditor('select', SelectEditor);\n\n})(Handsontable);\n\n(function (Handsontable) {\n\n  var DropdownEditor = Handsontable.editors.AutocompleteEditor.prototype.extend();\n\n  DropdownEditor.prototype.prepare = function () {\n    Handsontable.editors.AutocompleteEditor.prototype.prepare.apply(this, arguments);\n\n    this.cellProperties.filter = false;\n    this.cellProperties.strict = true;\n\n  };\n\n\n  Handsontable.editors.DropdownEditor = DropdownEditor;\n  Handsontable.editors.registerEditor('dropdown', DropdownEditor);\n\n\n})(Handsontable);\n(function (Handsontable) {\n\n  'use strict';\n\n  var NumericEditor = Handsontable.editors.TextEditor.prototype.extend();\n\n  NumericEditor.prototype.beginEditing = function (initialValue) {\n\n    var BaseEditor = Handsontable.editors.TextEditor.prototype;\n\n    if (typeof (initialValue) === 'undefined' && this.originalValue) {\n\n      var value = '' + this.originalValue;\n\n      if (typeof this.cellProperties.language !== 'undefined') {\n        numeral.language(this.cellProperties.language)\n      }\n\n      var decimalDelimiter = numeral.languageData().delimiters.decimal;\n      value = value.replace('.', decimalDelimiter);\n\n      BaseEditor.beginEditing.apply(this, [value]);\n    } else {\n      BaseEditor.beginEditing.apply(this, arguments);\n    }\n\n  };\n\n  Handsontable.editors.NumericEditor = NumericEditor;\n  Handsontable.editors.registerEditor('numeric', NumericEditor);\n\n})(Handsontable);\n\n/**\n * Numeric cell validator\n * @param {*} value - Value of edited cell\n * @param {*} callback - Callback called with validation result\n */\nHandsontable.NumericValidator = function (value, callback) {\n  if (value === null) {\n    value = '';\n  }\n  callback(/^-?\\d*(\\.|\\,)?\\d*$/.test(value));\n};\n/**\n * Function responsible for validation of autocomplete value\n * @param {*} value - Value of edited cell\n * @param {*} calback - Callback called with validation result\n */\nvar process = function (value, callback) {\n\n  var originalVal  = value;\n  var lowercaseVal = typeof originalVal === 'string' ? originalVal.toLowerCase() : null;\n\n  return function (source) {\n    var found = false;\n    for (var s = 0, slen = source.length; s < slen; s++) {\n      if (originalVal === source[s]) {\n        found = true; //perfect match\n        break;\n      }\n      else if (lowercaseVal === source[s].toLowerCase()) {\n        // changes[i][3] = source[s]; //good match, fix the case << TODO?\n        found = true;\n        break;\n      }\n    }\n\n    callback(found);\n  }\n};\n\n/**\n * Autocomplete cell validator\n * @param {*} value - Value of edited cell\n * @param {*} calback - Callback called with validation result\n */\nHandsontable.AutocompleteValidator = function (value, callback) {\n  if (this.strict && this.source) {\n    typeof this.source === 'function' ? this.source(value, process(value, callback)) : process(value, callback)(this.source);\n  } else {\n    callback(true);\n  }\n};\n\n/**\n * Cell type is just a shortcut for setting bunch of cellProperties (used in getCellMeta)\n */\n\nHandsontable.mobileBrowser = Handsontable.helper.isMobileBrowser();  // check if viewed on a mobile device\n\nHandsontable.AutocompleteCell = {\n  editor: Handsontable.editors.AutocompleteEditor,\n  renderer: Handsontable.renderers.AutocompleteRenderer,\n  validator: Handsontable.AutocompleteValidator\n};\n\nHandsontable.CheckboxCell = {\n  editor: Handsontable.editors.CheckboxEditor,\n  renderer: Handsontable.renderers.CheckboxRenderer\n};\n\nHandsontable.TextCell = {\n  editor: Handsontable.mobileBrowser ? Handsontable.editors.MobileTextEditor : Handsontable.editors.TextEditor,\n  renderer: Handsontable.renderers.TextRenderer\n};\n\nHandsontable.NumericCell = {\n  editor: Handsontable.editors.NumericEditor,\n  renderer: Handsontable.renderers.NumericRenderer,\n  validator: Handsontable.NumericValidator,\n  dataType: 'number'\n};\n\nHandsontable.DateCell = {\n  editor: Handsontable.editors.DateEditor,\n  renderer: Handsontable.renderers.AutocompleteRenderer //displays small gray arrow on right side of the cell\n};\n\nHandsontable.HandsontableCell = {\n  editor: Handsontable.editors.HandsontableEditor,\n  renderer: Handsontable.renderers.AutocompleteRenderer //displays small gray arrow on right side of the cell\n};\n\nHandsontable.PasswordCell = {\n  editor: Handsontable.editors.PasswordEditor,\n  renderer: Handsontable.renderers.PasswordRenderer,\n  copyable: false\n};\n\nHandsontable.DropdownCell = {\n  editor: Handsontable.editors.DropdownEditor,\n  renderer: Handsontable.renderers.AutocompleteRenderer, //displays small gray arrow on right side of the cell\n  validator: Handsontable.AutocompleteValidator\n};\n\n//here setup the friendly aliases that are used by cellProperties.type\nHandsontable.cellTypes = {\n  text: Handsontable.TextCell,\n  date: Handsontable.DateCell,\n  numeric: Handsontable.NumericCell,\n  checkbox: Handsontable.CheckboxCell,\n  autocomplete: Handsontable.AutocompleteCell,\n  handsontable: Handsontable.HandsontableCell,\n  password: Handsontable.PasswordCell,\n  dropdown: Handsontable.DropdownCell\n};\n\n//here setup the friendly aliases that are used by cellProperties.renderer and cellProperties.editor\nHandsontable.cellLookup = {\n  validator: {\n    numeric: Handsontable.NumericValidator,\n    autocomplete: Handsontable.AutocompleteValidator\n  }\n};\n\n/**\n * autoResize - resizes a DOM element to the width and height of another DOM element\n *\n * Copyright 2014, Marcin Warpechowski\n * Licensed under the MIT license\n */\nvar autoResize = function () {\n  var defaults = {\n      minHeight: 200,\n      maxHeight: 300,\n      minWidth: 100,\n      maxWidth: 300\n    },\n    el,\n    body = document.body,\n    text = document.createTextNode(''),\n    span = document.createElement('SPAN'),\n    observe = function (element, event, handler) {\n      if (window.attachEvent) {\n        element.attachEvent('on' + event, handler);\n      } else {\n        element.addEventListener(event, handler, false);\n      }\n    },\n    unObserve = function (element, event, handler) {\n      if (window.removeEventListener) {\n        element.removeEventListener(event, handler, false);\n      } else {\n        element.detachEvent('on' + event, handler);\n      }\n    },\n    resize = function (newChar) {\n      if(!newChar) {\n        newChar = \"\";\n      } else if (!/^[a-zA-Z \\.,\\\\\\/\\|0-9]$/.test(newChar)) {\n        newChar = \".\";\n      }\n\n      if (text.textContent !== void 0) {\n        text.textContent = el.value + newChar;\n      }\n      else {\n        text.data = el.value + newChar; //IE8\n      }\n      span.style.fontSize = Handsontable.Dom.getComputedStyle(el).fontSize;\n      span.style.fontFamily = Handsontable.Dom.getComputedStyle(el).fontFamily;\n      span.style['white-space'] = \"pre\";\n\n      body.appendChild(span);\n      var width = span.clientWidth + 2;\n      body.removeChild(span);\n\n      el.style.height = defaults.minHeight + 'px';\n\n      if (defaults.minWidth > width) {\n        el.style.width = defaults.minWidth + 'px';\n      } else if (width > defaults.maxWidth) {\n        el.style.width = defaults.maxWidth + 'px';\n      } else {\n        el.style.width = width + 'px';\n      }\n\n      var scrollHeight = el.scrollHeight;\n      if (defaults.minHeight > scrollHeight) {\n        el.style.height = defaults.minHeight + 'px';\n      } else if (defaults.maxHeight < scrollHeight) {\n        el.style.height = defaults.maxHeight + 'px';\n        el.style.overflowY = 'visible';\n      } else {\n        el.style.height = scrollHeight + 'px';\n      }\n\n    },\n    delayedResize = function () {\n      window.setTimeout(resize, 0);\n    },\n    extendDefaults = function (config) {\n\n      if (config && config.minHeight) {\n        if (config.minHeight == 'inherit') {\n          defaults.minHeight = el.clientHeight;\n        } else {\n          var minHeight = parseInt(config.minHeight);\n          if (!isNaN(minHeight)) {\n            defaults.minHeight = minHeight\n          }\n        }\n      }\n\n      if (config && config.maxHeight) {\n        if (config.maxHeight == 'inherit') {\n          defaults.maxHeight = el.clientHeight;\n        } else {\n          var maxHeight = parseInt(config.maxHeight);\n          if (!isNaN(maxHeight)) {\n            defaults.maxHeight = maxHeight\n          }\n        }\n      }\n\n      if (config && config.minWidth) {\n        if (config.minWidth == 'inherit') {\n          defaults.minWidth = el.clientWidth;\n        } else {\n          var minWidth = parseInt(config.minWidth);\n          if (!isNaN(minWidth)) {\n            defaults.minWidth = minWidth\n          }\n        }\n      }\n\n      if (config && config.maxWidth) {\n        if (config.maxWidth == 'inherit') {\n          defaults.maxWidth = el.clientWidth;\n        } else {\n          var maxWidth = parseInt(config.maxWidth);\n          if (!isNaN(maxWidth)) {\n            defaults.maxWidth = maxWidth\n          }\n        }\n      }\n\n      if(!span.firstChild) {\n        span.className = \"autoResize\";\n        span.style.display = 'inline-block';\n        span.appendChild(text);\n      }\n    },\n    init = function (el_, config, doObserve) {\n      el = el_;\n      extendDefaults(config);\n\n      if (el.nodeName == 'TEXTAREA') {\n\n        el.style.resize = 'none';\n        el.style.overflowY = '';\n        el.style.height = defaults.minHeight + 'px';\n        el.style.minWidth = defaults.minWidth + 'px';\n        el.style.maxWidth = defaults.maxWidth + 'px';\n        el.style.overflowY = 'hidden';\n      }\n\n      if(doObserve) {\n        observe(el, 'change', resize);\n        observe(el, 'cut', delayedResize);\n        observe(el, 'paste', delayedResize);\n        observe(el, 'drop', delayedResize);\n        observe(el, 'keydown', delayedResize);\n      }\n\n      resize();\n    };\n\n  return {\n    init: function (el_, config, doObserve) {\n      init(el_, config, doObserve);\n    },\n    unObserve: function () {\n      unObserve(el, 'change', resize);\n      unObserve(el, 'cut', delayedResize);\n      unObserve(el, 'paste', delayedResize);\n      unObserve(el, 'drop', delayedResize);\n      unObserve(el, 'keydown', delayedResize);\n    },\n    resize: resize\n  }\n\n};\n\n/**\n * SheetClip - Spreadsheet Clipboard Parser\n * version 0.2\n *\n * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,\n * Google Docs and Microsoft Excel.\n *\n * Copyright 2012, Marcin Warpechowski\n * Licensed under the MIT license.\n * http://github.com/warpech/sheetclip/\n */\n/*jslint white: true*/\n(function (global) {\n  \"use strict\";\n\n  function countQuotes(str) {\n    return str.split('\"').length - 1;\n  }\n\n  global.SheetClip = {\n    parse: function (str) {\n      var r, rlen, rows, arr = [], a = 0, c, clen, multiline, last;\n      rows = str.split('\\n');\n      if (rows.length > 1 && rows[rows.length - 1] === '') {\n        rows.pop();\n      }\n      for (r = 0, rlen = rows.length; r < rlen; r += 1) {\n        rows[r] = rows[r].split('\\t');\n        for (c = 0, clen = rows[r].length; c < clen; c += 1) {\n          if (!arr[a]) {\n            arr[a] = [];\n          }\n          if (multiline && c === 0) {\n            last = arr[a].length - 1;\n            arr[a][last] = arr[a][last] + '\\n' + rows[r][0];\n            if (multiline && (countQuotes(rows[r][0]) & 1)) { //& 1 is a bitwise way of performing mod 2\n              multiline = false;\n              arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/\"\"/g, '\"');\n            }\n          }\n          else {\n            if (c === clen - 1 && rows[r][c].indexOf('\"') === 0) {\n              arr[a].push(rows[r][c].substring(1).replace(/\"\"/g, '\"'));\n              multiline = true;\n            }\n            else {\n              arr[a].push(rows[r][c].replace(/\"\"/g, '\"'));\n              multiline = false;\n            }\n          }\n        }\n        if (!multiline) {\n          a += 1;\n        }\n      }\n      return arr;\n    },\n\n    stringify: function (arr) {\n      var r, rlen, c, clen, str = '', val;\n      for (r = 0, rlen = arr.length; r < rlen; r += 1) {\n        for (c = 0, clen = arr[r].length; c < clen; c += 1) {\n          if (c > 0) {\n            str += '\\t';\n          }\n          val = arr[r][c];\n          if (typeof val === 'string') {\n            if (val.indexOf('\\n') > -1) {\n              str += '\"' + val.replace(/\"/g, '\"\"') + '\"';\n            }\n            else {\n              str += val;\n            }\n          }\n          else if (val === null || val === void 0) { //void 0 resolves to undefined\n            str += '';\n          }\n          else {\n            str += val;\n          }\n        }\n        if (r < rlen - 1) {\n          str += '\\n';\n        }\n      }\n      return str;\n    }\n  };\n}(window));\n/**\n * CopyPaste.js\n * Creates a textarea that stays hidden on the page and gets focused when user presses CTRL while not having a form input focused\n * In future we may implement a better driver when better APIs are available\n * @constructor\n */\nvar CopyPaste = (function () {\n  var instance;\n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = new CopyPasteClass();\n      } else if (instance.hasBeenDestroyed()){\n        instance.init();\n      }\n\n      instance.refCounter++;\n\n      return instance;\n    }\n  };\n})();\n\nfunction CopyPasteClass() {\n  this.refCounter = 0;\n  this.init();\n}\n\nCopyPasteClass.prototype.init = function () {\n  var that = this\n    , style\n    , parent;\n\n  this.copyCallbacks = [];\n  this.cutCallbacks = [];\n  this.pasteCallbacks = [];\n  this._eventManager = Handsontable.eventManager(this);\n\n//  this.listenerElement = document.documentElement;\n  parent = document.body;\n\n  if (document.getElementById('CopyPasteDiv')) {\n    this.elDiv = document.getElementById('CopyPasteDiv');\n    this.elTextarea = this.elDiv.firstChild;\n  }\n  else {\n    this.elDiv = document.createElement('DIV');\n    this.elDiv.id = 'CopyPasteDiv';\n    style = this.elDiv.style;\n    style.position = 'fixed';\n    style.top = '-10000px';\n    style.left = '-10000px';\n    parent.appendChild(this.elDiv);\n\n    this.elTextarea = document.createElement('TEXTAREA');\n    this.elTextarea.className = 'copyPaste';\n    this.elTextarea.onpaste = function (event) {\n      if('WebkitAppearance' in document.documentElement.style) { // chrome and safari\n        this.value = event.clipboardData.getData(\"Text\");\n        return false;\n      }\n    };\n    style = this.elTextarea.style;\n    style.width = '10000px';\n    style.height = '10000px';\n    style.overflow = 'hidden';\n    this.elDiv.appendChild(this.elTextarea);\n\n    if (typeof style.opacity !== 'undefined') {\n      style.opacity = 0;\n    }\n    else {\n      /*@cc_on @if (@_jscript)\n       if(typeof style.filter === 'string') {\n       style.filter = 'alpha(opacity=0)';\n       }\n       @end @*/\n    }\n  }\n\n  this.keydownListener = function (event) {\n    var isCtrlDown = false;\n    if (event.metaKey) { //mac\n      isCtrlDown = true;\n    }\n    else if (event.ctrlKey && navigator.userAgent.indexOf('Mac') === -1) { //pc\n      isCtrlDown = true;\n    }\n\n    if (isCtrlDown) {\n      if (document.activeElement !== that.elTextarea && (that.getSelectionText() != '' || ['INPUT', 'SELECT', 'TEXTAREA'].indexOf(document.activeElement.nodeName) != -1)) {\n        return; //this is needed by fragmentSelection in Handsontable. Ignore copypaste.js behavior if fragment of cell text is selected\n      }\n\n      that.selectNodeText(that.elTextarea);\n      setTimeout(function () {\n        that.selectNodeText(that.elTextarea);\n      }, 0);\n    }\n\n    /* 67 = c\n     * 86 = v\n     * 88 = x\n     */\n    if (isCtrlDown && (event.keyCode === 67 || event.keyCode === 86 || event.keyCode === 88)) {\n      // that.selectNodeText(that.elTextarea);\n\n      if (event.keyCode === 88) { //works in all browsers, incl. Opera < 12.12\n        setTimeout(function () {\n          that.triggerCut(event);\n        }, 0);\n      }\n      else if (event.keyCode === 86) {\n        setTimeout(function () {\n          that.triggerPaste(event);\n        }, 0);\n      }\n    }\n  };\n\n  this._eventManager.addEventListener(document.documentElement,'keydown',this.keydownListener, false);\n\n//  this._bindEvent(this.listenerElement, 'keydown', this.keydownListener);\n};\n\n//http://jsperf.com/textara-selection\n//http://stackoverflow.com/questions/1502385/how-can-i-make-this-code-work-in-ie\nCopyPasteClass.prototype.selectNodeText = function (el) {\n  if (el) {\n    el.select();\n  }\n};\n\n//http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\nCopyPasteClass.prototype.getSelectionText = function () {\n  var text = \"\";\n  if (window.getSelection) {\n    text = window.getSelection().toString();\n  } else if (document.selection && document.selection.type != \"Control\") {\n    text = document.selection.createRange().text;\n  }\n  return text;\n};\n\nCopyPasteClass.prototype.copyable = function (str) {\n  if (typeof str !== 'string' && str.toString === void 0) {\n    throw new Error('copyable requires string parameter');\n  }\n  this.elTextarea.value = str;\n};\n\n/*CopyPasteClass.prototype.onCopy = function (fn) {\n  this.copyCallbacks.push(fn);\n};*/\n\nCopyPasteClass.prototype.onCut = function (fn) {\n  this.cutCallbacks.push(fn);\n};\n\nCopyPasteClass.prototype.onPaste = function (fn) {\n  this.pasteCallbacks.push(fn);\n};\n\nCopyPasteClass.prototype.removeCallback = function (fn) {\n  var i, ilen;\n  for (i = 0, ilen = this.copyCallbacks.length; i < ilen; i++) {\n    if (this.copyCallbacks[i] === fn) {\n      this.copyCallbacks.splice(i, 1);\n      return true;\n    }\n  }\n  for (i = 0, ilen = this.cutCallbacks.length; i < ilen; i++) {\n    if (this.cutCallbacks[i] === fn) {\n      this.cutCallbacks.splice(i, 1);\n      return true;\n    }\n  }\n  for (i = 0, ilen = this.pasteCallbacks.length; i < ilen; i++) {\n    if (this.pasteCallbacks[i] === fn) {\n      this.pasteCallbacks.splice(i, 1);\n      return true;\n    }\n  }\n  return false;\n};\n\nCopyPasteClass.prototype.triggerCut = function (event) {\n  var that = this;\n  if (that.cutCallbacks) {\n    setTimeout(function () {\n      for (var i = 0, ilen = that.cutCallbacks.length; i < ilen; i++) {\n        that.cutCallbacks[i](event);\n      }\n    }, 50);\n  }\n};\n\nCopyPasteClass.prototype.triggerPaste = function (event, str) {\n  var that = this;\n  if (that.pasteCallbacks) {\n    setTimeout(function () {\n      var val = (str || that.elTextarea.value).replace(/\\n$/, ''); //remove trailing newline\n      for (var i = 0, ilen = that.pasteCallbacks.length; i < ilen; i++) {\n        that.pasteCallbacks[i](val, event);\n      }\n    }, 50);\n  }\n};\n\nCopyPasteClass.prototype.destroy = function () {\n\n  if(!this.hasBeenDestroyed() && --this.refCounter == 0){\n    if (this.elDiv && this.elDiv.parentNode) {\n      this.elDiv.parentNode.removeChild(this.elDiv);\n      this.elDiv = null;\n      this.elTextarea = null;\n    }\n\n    this._eventManager.removeEventListener(document.documentElement, 'keydown', this.keydownListener, false);\n//    this._unbindEvent(this.listenerElement, 'keydown', this.keydownListener);\n\n  }\n\n};\n\nCopyPasteClass.prototype.hasBeenDestroyed = function () {\n  return !this.refCounter;\n};\n\n\n\n// json-patch-duplex.js 0.3.6\n// (c) 2013 Joachim Wester\n// MIT license\nvar jsonpatch;\n(function (jsonpatch) {\n    var objOps = {\n        add: function (obj, key) {\n            obj[key] = this.value;\n            return true;\n        },\n        remove: function (obj, key) {\n            delete obj[key];\n            return true;\n        },\n        replace: function (obj, key) {\n            obj[key] = this.value;\n            return true;\n        },\n        move: function (obj, key, tree) {\n            var temp = { op: \"_get\", path: this.from };\n            apply(tree, [temp]);\n            apply(tree, [\n                { op: \"remove\", path: this.from }\n            ]);\n            apply(tree, [\n                { op: \"add\", path: this.path, value: temp.value }\n            ]);\n            return true;\n        },\n        copy: function (obj, key, tree) {\n            var temp = { op: \"_get\", path: this.from };\n            apply(tree, [temp]);\n            apply(tree, [\n                { op: \"add\", path: this.path, value: temp.value }\n            ]);\n            return true;\n        },\n        test: function (obj, key) {\n            return (JSON.stringify(obj[key]) === JSON.stringify(this.value));\n        },\n        _get: function (obj, key) {\n            this.value = obj[key];\n        }\n    };\n\n    var arrOps = {\n        add: function (arr, i) {\n            arr.splice(i, 0, this.value);\n            return true;\n        },\n        remove: function (arr, i) {\n            arr.splice(i, 1);\n            return true;\n        },\n        replace: function (arr, i) {\n            arr[i] = this.value;\n            return true;\n        },\n        move: objOps.move,\n        copy: objOps.copy,\n        test: objOps.test,\n        _get: objOps._get\n    };\n\n    var observeOps = {\n        add: function (patches, path) {\n            var patch = {\n                op: \"add\",\n                path: path + escapePathComponent(this.name),\n                value: this.object[this.name]\n            };\n            patches.push(patch);\n        },\n        'delete': function (patches, path) {\n            var patch = {\n                op: \"remove\",\n                path: path + escapePathComponent(this.name)\n            };\n            patches.push(patch);\n        },\n        update: function (patches, path) {\n            var patch = {\n                op: \"replace\",\n                path: path + escapePathComponent(this.name),\n                value: this.object[this.name]\n            };\n            patches.push(patch);\n        }\n    };\n\n    function escapePathComponent(str) {\n        if (str.indexOf('/') === -1 && str.indexOf('~') === -1)\n            return str;\n        return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    function _getPathRecursive(root, obj) {\n        var found;\n        for (var key in root) {\n            if (root.hasOwnProperty(key)) {\n                if (root[key] === obj) {\n                    return escapePathComponent(key) + '/';\n                } else if (typeof root[key] === 'object') {\n                    found = _getPathRecursive(root[key], obj);\n                    if (found != '') {\n                        return escapePathComponent(key) + '/' + found;\n                    }\n                }\n            }\n        }\n        return '';\n    }\n\n    function getPath(root, obj) {\n        if (root === obj) {\n            return '/';\n        }\n        var path = _getPathRecursive(root, obj);\n        if (path === '') {\n            throw new Error(\"Object not found in root\");\n        }\n        return '/' + path;\n    }\n\n    var beforeDict = [];\n\n    jsonpatch.intervals;\n\n    var Mirror = (function () {\n        function Mirror(obj) {\n            this.observers = [];\n            this.obj = obj;\n        }\n        return Mirror;\n    })();\n\n    var ObserverInfo = (function () {\n        function ObserverInfo(callback, observer) {\n            this.callback = callback;\n            this.observer = observer;\n        }\n        return ObserverInfo;\n    })();\n\n    function getMirror(obj) {\n        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {\n            if (beforeDict[i].obj === obj) {\n                return beforeDict[i];\n            }\n        }\n    }\n\n    function getObserverFromMirror(mirror, callback) {\n        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {\n            if (mirror.observers[j].callback === callback) {\n                return mirror.observers[j].observer;\n            }\n        }\n    }\n\n    function removeObserverFromMirror(mirror, observer) {\n        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {\n            if (mirror.observers[j].observer === observer) {\n                mirror.observers.splice(j, 1);\n                return;\n            }\n        }\n    }\n\n    function unobserve(root, observer) {\n        generate(observer);\n        if (Object.observe) {\n            _unobserve(observer, root);\n        } else {\n            clearTimeout(observer.next);\n        }\n\n        var mirror = getMirror(root);\n        removeObserverFromMirror(mirror, observer);\n    }\n    jsonpatch.unobserve = unobserve;\n\n    function observe(obj, callback) {\n        var patches = [];\n        var root = obj;\n        var observer;\n        var mirror = getMirror(obj);\n\n        if (!mirror) {\n            mirror = new Mirror(obj);\n            beforeDict.push(mirror);\n        } else {\n            observer = getObserverFromMirror(mirror, callback);\n        }\n\n        if (observer) {\n            return observer;\n        }\n\n        if (Object.observe) {\n            observer = function (arr) {\n                //This \"refresh\" is needed to begin observing new object properties\n                _unobserve(observer, obj);\n                _observe(observer, obj);\n\n                var a = 0, alen = arr.length;\n                while (a < alen) {\n                    if (!(arr[a].name === 'length' && _isArray(arr[a].object)) && !(arr[a].name === '__Jasmine_been_here_before__')) {\n                        var type = arr[a].type;\n\n                        switch (type) {\n                            case 'new':\n                                type = 'add';\n                                break;\n\n                            case 'deleted':\n                                type = 'delete';\n                                break;\n\n                            case 'updated':\n                                type = 'update';\n                                break;\n                        }\n\n                        observeOps[type].call(arr[a], patches, getPath(root, arr[a].object));\n                    }\n                    a++;\n                }\n\n                if (patches) {\n                    if (callback) {\n                        callback(patches);\n                    }\n                }\n                observer.patches = patches;\n                patches = [];\n            };\n        } else {\n            observer = {};\n\n            mirror.value = JSON.parse(JSON.stringify(obj));\n\n            if (callback) {\n                //callbacks.push(callback); this has no purpose\n                observer.callback = callback;\n                observer.next = null;\n                var intervals = this.intervals || [100, 1000, 10000, 60000];\n                var currentInterval = 0;\n\n                var dirtyCheck = function () {\n                    generate(observer);\n                };\n                var fastCheck = function () {\n                    clearTimeout(observer.next);\n                    observer.next = setTimeout(function () {\n                        dirtyCheck();\n                        currentInterval = 0;\n                        observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n                    }, 0);\n                };\n                var slowCheck = function () {\n                    dirtyCheck();\n                    if (currentInterval == intervals.length)\n                        currentInterval = intervals.length - 1;\n                    observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n                };\n                if (typeof window !== 'undefined') {\n                    if (window.addEventListener) {\n                        window.addEventListener('mousedown', fastCheck);\n                        window.addEventListener('mouseup', fastCheck);\n                        window.addEventListener('keydown', fastCheck);\n                    } else {\n                        window.attachEvent('onmousedown', fastCheck);\n                        window.attachEvent('onmouseup', fastCheck);\n                        window.attachEvent('onkeydown', fastCheck);\n                    }\n                }\n                observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n            }\n        }\n        observer.patches = patches;\n        observer.object = obj;\n\n        mirror.observers.push(new ObserverInfo(callback, observer));\n\n        return _observe(observer, obj);\n    }\n    jsonpatch.observe = observe;\n\n    /// Listen to changes on an object tree, accumulate patches\n    function _observe(observer, obj) {\n        if (Object.observe) {\n            Object.observe(obj, observer);\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    var v = obj[key];\n                    if (v && typeof (v) === \"object\") {\n                        _observe(observer, v);\n                    }\n                }\n            }\n        }\n        return observer;\n    }\n\n    function _unobserve(observer, obj) {\n        if (Object.observe) {\n            Object.unobserve(obj, observer);\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    var v = obj[key];\n                    if (v && typeof (v) === \"object\") {\n                        _unobserve(observer, v);\n                    }\n                }\n            }\n        }\n        return observer;\n    }\n\n    function generate(observer) {\n        if (Object.observe) {\n            Object.deliverChangeRecords(observer);\n        } else {\n            var mirror;\n            for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {\n                if (beforeDict[i].obj === observer.object) {\n                    mirror = beforeDict[i];\n                    break;\n                }\n            }\n            _generate(mirror.value, observer.object, observer.patches, \"\");\n        }\n        var temp = observer.patches;\n        if (temp.length > 0) {\n            observer.patches = [];\n            if (observer.callback) {\n                observer.callback(temp);\n            }\n        }\n        return temp;\n    }\n    jsonpatch.generate = generate;\n\n    var _objectKeys;\n    if (Object.keys) {\n        _objectKeys = Object.keys;\n    } else {\n        _objectKeys = function (obj) {\n            var keys = [];\n            for (var o in obj) {\n                if (obj.hasOwnProperty(o)) {\n                    keys.push(o);\n                }\n            }\n            return keys;\n        };\n    }\n\n    // Dirty check if obj is different from mirror, generate patches and update mirror\n    function _generate(mirror, obj, patches, path) {\n        var newKeys = _objectKeys(obj);\n        var oldKeys = _objectKeys(mirror);\n        var changed = false;\n        var deleted = false;\n\n        for (var t = oldKeys.length - 1; t >= 0; t--) {\n            var key = oldKeys[t];\n            var oldVal = mirror[key];\n            if (obj.hasOwnProperty(key)) {\n                var newVal = obj[key];\n                if (oldVal instanceof Object) {\n                    _generate(oldVal, newVal, patches, path + \"/\" + escapePathComponent(key));\n                } else {\n                    if (oldVal != newVal) {\n                        changed = true;\n                        patches.push({ op: \"replace\", path: path + \"/\" + escapePathComponent(key), value: newVal });\n                        mirror[key] = newVal;\n                    }\n                }\n            } else {\n                patches.push({ op: \"remove\", path: path + \"/\" + escapePathComponent(key) });\n                delete mirror[key];\n                deleted = true;\n            }\n        }\n\n        if (!deleted && newKeys.length == oldKeys.length) {\n            return;\n        }\n\n        for (var t = 0; t < newKeys.length; t++) {\n            var key = newKeys[t];\n            if (!mirror.hasOwnProperty(key)) {\n                patches.push({ op: \"add\", path: path + \"/\" + escapePathComponent(key), value: obj[key] });\n                mirror[key] = JSON.parse(JSON.stringify(obj[key]));\n            }\n        }\n    }\n\n    var _isArray;\n    if (Array.isArray) {\n        _isArray = Array.isArray;\n    } else {\n        _isArray = function (obj) {\n            return obj.push && typeof obj.length === 'number';\n        };\n    }\n\n    /// Apply a json-patch operation on an object tree\n    function apply(tree, patches) {\n        var result = false, p = 0, plen = patches.length, patch;\n        while (p < plen) {\n            patch = patches[p];\n\n            // Find the object\n            var keys = patch.path.split('/');\n            var obj = tree;\n            var t = 1;\n            var len = keys.length;\n            while (true) {\n                if (_isArray(obj)) {\n                    var index = parseInt(keys[t], 10);\n                    t++;\n                    if (t >= len) {\n                        result = arrOps[patch.op].call(patch, obj, index, tree);\n                        break;\n                    }\n                    obj = obj[index];\n                } else {\n                    var key = keys[t];\n                    if (key.indexOf('~') != -1)\n                        key = key.replace(/~1/g, '/').replace(/~0/g, '~');\n                    t++;\n                    if (t >= len) {\n                        result = objOps[patch.op].call(patch, obj, key, tree);\n                        break;\n                    }\n                    obj = obj[key];\n                }\n            }\n            p++;\n        }\n        return result;\n    }\n    jsonpatch.apply = apply;\n})(jsonpatch || (jsonpatch = {}));\n\nif (typeof exports !== \"undefined\") {\n    exports.apply = jsonpatch.apply;\n    exports.observe = jsonpatch.observe;\n    exports.unobserve = jsonpatch.unobserve;\n    exports.generate = jsonpatch.generate;\n}\n\nHandsontable.PluginHookClass = (function () {\n\n  var Hooks = function () {\n    return {\n      // Hooks\n      beforeInitWalkontable: [],\n      beforeInit: [],\n      beforeRender: [],\n      beforeSetRangeEnd: [],\n      beforeDrawBorders: [],\n      beforeChange: [],\n      beforeChangeRender: [],\n      beforeRemoveCol: [],\n      beforeRemoveRow: [],\n      beforeValidate: [],\n      beforeGetCellMeta: [],\n      beforeAutofill: [],\n      beforeKeyDown: [],\n      beforeOnCellMouseDown: [],\n      beforeTouchScroll: [],\n      afterInit : [],\n      afterLoadData : [],\n      afterUpdateSettings: [],\n      afterRender : [],\n      afterRenderer : [],\n      afterChange : [],\n      afterValidate: [],\n      afterGetCellMeta: [],\n      afterSetCellMeta: [],\n      afterGetColHeader: [],\n      afterGetRowHeader: [],\n      afterDestroy: [],\n      afterRemoveRow: [],\n      afterCreateRow: [],\n      afterRemoveCol: [],\n      afterCreateCol: [],\n      afterDeselect: [],\n      afterSelection: [],\n      afterSelectionByProp: [],\n      afterSelectionEnd: [],\n      afterSelectionEndByProp: [],\n      afterOnCellMouseDown: [],\n      afterOnCellMouseOver: [],\n      afterOnCellCornerMouseDown: [],\n      afterScrollVertically: [],\n      afterScrollHorizontally: [],\n      afterCellMetaReset: [],\n      afterIsMultipleSelectionCheck: [],\n      afterDocumentKeyDown: [],\n      afterMomentumScroll: [],\n\n      // Modifiers\n      modifyColWidth: [],\n      modifyRowHeight: [],\n      modifyRow: [],\n      modifyCol: []\n    }\n  };\n\n  var legacy = {\n    onBeforeChange: \"beforeChange\",\n    onChange: \"afterChange\",\n    onCreateRow: \"afterCreateRow\",\n    onCreateCol: \"afterCreateCol\",\n    onSelection: \"afterSelection\",\n    onCopyLimit: \"afterCopyLimit\",\n    onSelectionEnd: \"afterSelectionEnd\",\n    onSelectionByProp: \"afterSelectionByProp\",\n    onSelectionEndByProp: \"afterSelectionEndByProp\"\n  };\n\n  function PluginHookClass() {\n\n    this.hooks = Hooks();\n    this.globalBucket = {};\n    this.legacy = legacy;\n\n  }\n\n  PluginHookClass.prototype.getBucket = function (instance) {\n    if(instance) {\n      if(!instance.pluginHookBucket) {\n        instance.pluginHookBucket = {};\n      }\n      return instance.pluginHookBucket;\n    }\n    return this.globalBucket;\n  };\n\n  PluginHookClass.prototype.add = function (key, fn, instance) {\n    //if fn is array, run this for all the array items\n    if (Array.isArray(fn)) {\n      for (var i = 0, len = fn.length; i < len; i++) {\n        this.add(key, fn[i]);\n      }\n    }\n    else {\n      // provide support for old versions of HOT\n      if (key in legacy) {\n        key = legacy[key];\n      }\n\n      var bucket = this.getBucket(instance);\n\n      if (typeof bucket[key] === \"undefined\") {\n        bucket[key] = [];\n      }\n\n      fn.skip = false;\n\n      if (bucket[key].indexOf(fn) == -1) {\n        bucket[key].push(fn); //only add a hook if it has not already been added (adding the same hook twice is now silently ignored)\n      }\n    }\n    return this;\n  };\n\n  PluginHookClass.prototype.once = function(key, fn, instance){\n\n    if(Array.isArray(fn)){\n\n      for(var i = 0, len = fn.length; i < len; i++){\n        fn[i].runOnce = true;\n        this.add(key, fn[i], instance);\n      }\n\n    } else {\n      fn.runOnce = true;\n      this.add(key, fn, instance);\n\n    }\n\n  };\n\n  PluginHookClass.prototype.remove = function (key, fn, instance) {\n    var status = false;\n\n    // provide support for old versions of HOT\n    if (key in legacy) {\n      key = legacy[key];\n    }\n\n    var bucket = this.getBucket(instance);\n\n    if (typeof bucket[key] !== 'undefined') {\n\n      for (var i = 0, leni = bucket[key].length; i < leni; i++) {\n\n        if (bucket[key][i] == fn) {\n          bucket[key][i].skip = true;\n          status = true;\n          break;\n        }\n\n      }\n\n    }\n\n    return status;\n  };\n\n  PluginHookClass.prototype.run = function (instance, key, p1, p2, p3, p4, p5, p6) {\n    // provide support for old versions of HOT\n    if (key in legacy) {\n      key = legacy[key];\n    }\n\n    this._runBucket(this.globalBucket, instance, key, p1, p2, p3, p4, p5, p6);\n    this._runBucket(this.getBucket(instance), instance, key, p1, p2, p3, p4, p5, p6);\n  };\n\n  PluginHookClass.prototype._runBucket = function (bucket, instance, key, p1, p2, p3, p4, p5, p6) {\n    var handlers = bucket[key];\n    if (handlers) {\n      for (var i = 0, leni = handlers.length; i < leni; i++) {\n        if (!handlers[i].skip) {\n          handlers[i].call(instance, p1, p2, p3, p4, p5, p6);\n\n          if (handlers[i].runOnce) {\n            this.remove(key, handlers[i], bucket === this.globalBucket ? null : instance);\n          }\n        }\n      }\n    }\n  };\n\n  PluginHookClass.prototype.destroy = function (instance) {\n    var bucket = this.getBucket(instance);\n    for (var key in bucket) {\n      if (bucket.hasOwnProperty(key)) {\n        for (var i = 0, leni = bucket[key].length; i < leni; i++) {\n          this.remove(key, bucket[key], instance);\n        }\n      }\n    }\n  };\n\n  PluginHookClass.prototype.execute = function (instance, key, p1, p2, p3, p4, p5, p6) {\n    // provide support for old versions of HOT\n    if (key in legacy) {\n      key = legacy[key];\n    }\n\n    p1 = this._executeBucket(this.globalBucket, instance, key, p1, p2, p3, p4, p5, p6);\n    p1 = this._executeBucket(this.getBucket(instance), instance, key, p1, p2, p3, p4, p5, p6);\n    return p1;\n  };\n\n  PluginHookClass.prototype._executeBucket = function (bucket, instance, key, p1, p2, p3, p4, p5, p6) {\n    var res,\n      handlers = bucket[key];\n\n    //performance considerations - http://jsperf.com/call-vs-apply-for-a-plugin-architecture\n    if (handlers) {\n      for (var i = 0, leni = handlers.length; i < leni; i++) {\n        if (!handlers[i].skip) {\n          res = handlers[i].call(instance, p1, p2, p3, p4, p5, p6);\n          if (res !== void 0) {\n            p1 = res;\n          }\n\n          if (handlers[i].runOnce) {\n            this.remove(key, handlers[i], bucket === this.globalBucket ? null : instance);\n          }\n\n          if (res === false) { //if any handler returned false\n            return false; //event has been cancelled and further execution of handler queue is being aborted\n          }\n        }\n      }\n    }\n\n    return p1;\n  };\n\n  /**\n   * Registers a hook name (adds it to the list of the known hook names). Used by plugins. It is not neccessary to call,\n   * register, but if you use it, your plugin hook will be used returned by getRegistered\n   * (which itself is used in the demo http://handsontable.com/demo/callbacks.html)\n   * @param key {String}\n   */\n  PluginHookClass.prototype.register = function (key) {\n    if (!this.isRegistered(key)) {\n      this.hooks[key] = [];\n    }\n  };\n\n  /**\n   * Deregisters a hook name (removes it from the list of known hook names)\n   * @param key {String}\n   */\n  PluginHookClass.prototype.deregister = function (key) {\n    delete this.hooks[key];\n  };\n\n  /**\n   * Returns boolean information if a hook by such name has been registered\n   * @param key {String}\n   */\n  PluginHookClass.prototype.isRegistered = function (key) {\n    return (typeof this.hooks[key] !== \"undefined\");\n  };\n\n  /**\n   * Returns an array of registered hooks\n   * @returns {Array}\n   */\n  PluginHookClass.prototype.getRegistered = function () {\n    return Object.keys(this.hooks);\n  };\n\n  return PluginHookClass;\n\n})();\n\nHandsontable.hooks = new Handsontable.PluginHookClass();\nHandsontable.PluginHooks = Handsontable.hooks; //in future move this line to legacy.js\n\n(function (Handsontable) {\n\n  function HandsontableAutoColumnSize() {\n    var plugin = this\n      , sampleCount = 5; //number of samples to take of each value length\n\n    this.beforeInit = function () {\n      var instance = this;\n      instance.autoColumnWidths = [];\n\n      if (instance.getSettings().autoColumnSize !== false) {\n        if (!instance.autoColumnSizeTmp) {\n          instance.autoColumnSizeTmp = {\n            table: null,\n            tableStyle: null,\n            theadTh: null,\n            tbody: null,\n            container: null,\n            containerStyle: null,\n            determineBeforeNextRender: true\n          };\n\n          instance.addHook('beforeRender', htAutoColumnSize.determineIfChanged);\n          instance.addHook('modifyColWidth', htAutoColumnSize.modifyColWidth);\n          instance.addHook('afterDestroy', htAutoColumnSize.afterDestroy);\n\n          instance.determineColumnWidth = plugin.determineColumnWidth;\n        }\n      } else {\n        if (instance.autoColumnSizeTmp) {\n          instance.removeHook('beforeRender', htAutoColumnSize.determineIfChanged);\n          instance.removeHook('modifyColWidth', htAutoColumnSize.modifyColWidth);\n          instance.removeHook('afterDestroy', htAutoColumnSize.afterDestroy);\n\n          delete instance.determineColumnWidth;\n\n          plugin.afterDestroy.call(instance);\n        }\n      }\n    };\n\n    this.determineIfChanged = function (force) {\n      if (force) {\n        htAutoColumnSize.determineColumnsWidth.apply(this, arguments);\n      }\n    };\n\n    this.determineColumnWidth = function (col) {\n      var instance = this\n        , tmp = instance.autoColumnSizeTmp;\n\n      if (!tmp.container) {\n        createTmpContainer.call(tmp, instance);\n      }\n\n      tmp.container.className = instance.rootElement.className + ' htAutoColumnSize';\n      tmp.table.className = instance.table.className;\n\n      var rows = instance.countRows();\n      var samples = {};\n      var maxLen = 0;\n      for (var r = 0; r < rows; r++) {\n        var value = Handsontable.helper.stringify(instance.getDataAtCell(r, col));\n        var len = value.length;\n        if (len > maxLen) {\n          maxLen = len;\n        }\n        if (!samples[len]) {\n          samples[len] = {\n            needed: sampleCount,\n            strings: []\n          };\n        }\n        if (samples[len].needed) {\n          samples[len].strings.push({value: value, row: r});\n          samples[len].needed--;\n        }\n      }\n\n      var settings = instance.getSettings();\n      if (settings.colHeaders) {\n        instance.view.appendColHeader(col, tmp.theadTh); //TH innerHTML\n      }\n\n      Handsontable.Dom.empty(tmp.tbody);\n\n      for (var i in samples) {\n        if (samples.hasOwnProperty(i)) {\n          for (var j = 0, jlen = samples[i].strings.length; j < jlen; j++) {\n            var row = samples[i].strings[j].row;\n\n            var cellProperties = instance.getCellMeta(row, col);\n            cellProperties.col = col;\n            cellProperties.row = row;\n\n            var renderer = instance.getCellRenderer(cellProperties);\n\n            var tr = document.createElement('tr');\n            var td = document.createElement('td');\n\n            renderer(instance, td, row, col, instance.colToProp(col), samples[i].strings[j].value, cellProperties);\n            r++;\n            tr.appendChild(td);\n            tmp.tbody.appendChild(tr);\n          }\n        }\n      }\n\n      var parent = instance.rootElement.parentNode;\n      parent.appendChild(tmp.container);\n      var width = Handsontable.Dom.outerWidth(tmp.table);\n      parent.removeChild(tmp.container);\n\n      return width;\n    };\n\n    this.determineColumnsWidth = function () {\n      var instance = this;\n      var settings = this.getSettings();\n      if (settings.autoColumnSize || !settings.colWidths) {\n        var cols = this.countCols();\n        for (var c = 0; c < cols; c++) {\n          if (!instance._getColWidthFromSettings(c)) {\n            this.autoColumnWidths[c] = plugin.determineColumnWidth.call(instance, c);\n          }\n        }\n      }\n    };\n\n    this.modifyColWidth = function (width, col) {\n      if (this.autoColumnWidths[col] && this.autoColumnWidths[col] > width) {\n        return this.autoColumnWidths[col];\n      }\n      return width;\n    };\n\n    this.afterDestroy = function () {\n      var instance = this;\n      if (instance.autoColumnSizeTmp && instance.autoColumnSizeTmp.container && instance.autoColumnSizeTmp.container.parentNode) {\n        instance.autoColumnSizeTmp.container.parentNode.removeChild(instance.autoColumnSizeTmp.container);\n      }\n      instance.autoColumnSizeTmp = null;\n    };\n\n    function createTmpContainer(instance) {\n      var d = document\n        , tmp = this;\n\n      tmp.table = d.createElement('table');\n      tmp.theadTh = d.createElement('th');\n      tmp.table.appendChild(d.createElement('thead')).appendChild(d.createElement('tr')).appendChild(tmp.theadTh);\n\n      tmp.tableStyle = tmp.table.style;\n      tmp.tableStyle.tableLayout = 'auto';\n      tmp.tableStyle.width = 'auto';\n\n      tmp.tbody = d.createElement('tbody');\n      tmp.table.appendChild(tmp.tbody);\n\n      tmp.container = d.createElement('div');\n      tmp.container.className = instance.rootElement.className + ' hidden';\n//      tmp.container.className = instance.rootElement[0].className + ' hidden';\n      tmp.containerStyle = tmp.container.style;\n\n      tmp.container.appendChild(tmp.table);\n    }\n  }\n\n  var htAutoColumnSize = new HandsontableAutoColumnSize();\n\n  Handsontable.hooks.add('beforeInit', htAutoColumnSize.beforeInit);\n  Handsontable.hooks.add('afterUpdateSettings', htAutoColumnSize.beforeInit);\n\n})(Handsontable);\n\n/**\n * This plugin sorts the view by a column (but does not sort the data source!)\n * @constructor\n */\nfunction HandsontableColumnSorting() {\n  var plugin = this;\n\n  this.init = function (source) {\n    var instance = this;\n    var sortingSettings = instance.getSettings().columnSorting;\n    var sortingColumn, sortingOrder;\n\n    instance.sortingEnabled = !!(sortingSettings);\n\n    if (instance.sortingEnabled) {\n      instance.sortIndex = [];\n\n      var loadedSortingState = loadSortingState.call(instance);\n\n      if (typeof loadedSortingState != 'undefined') {\n        sortingColumn = loadedSortingState.sortColumn;\n        sortingOrder = loadedSortingState.sortOrder;\n      } else {\n        sortingColumn = sortingSettings.column;\n        sortingOrder = sortingSettings.sortOrder;\n      }\n      plugin.sortByColumn.call(instance, sortingColumn, sortingOrder);\n\n      instance.sort = function(){\n        var args = Array.prototype.slice.call(arguments);\n\n        return plugin.sortByColumn.apply(instance, args)\n      };\n\n      if (typeof instance.getSettings().observeChanges == 'undefined'){\n        enableObserveChangesPlugin.call(instance);\n      }\n\n      if (source == 'afterInit') {\n        bindColumnSortingAfterClick.call(instance);\n\n        instance.addHook('afterCreateRow', plugin.afterCreateRow);\n        instance.addHook('afterRemoveRow', plugin.afterRemoveRow);\n        instance.addHook('afterLoadData', plugin.init);\n      }\n    } else {\n      delete instance.sort;\n\n      instance.removeHook('afterCreateRow', plugin.afterCreateRow);\n      instance.removeHook('afterRemoveRow', plugin.afterRemoveRow);\n      instance.removeHook('afterLoadData', plugin.init);\n    }\n  };\n\n  this.setSortingColumn = function (col, order) {\n    var instance = this;\n\n    if (typeof col == 'undefined') {\n      delete instance.sortColumn;\n      delete instance.sortOrder;\n\n      return;\n    } else if (instance.sortColumn === col && typeof order == 'undefined') {\n      instance.sortOrder = !instance.sortOrder;\n    } else {\n      instance.sortOrder = typeof order != 'undefined' ? order : true;\n    }\n\n    instance.sortColumn = col;\n\n  };\n\n  this.sortByColumn = function (col, order) {\n    var instance = this;\n\n    plugin.setSortingColumn.call(instance, col, order);\n\n    if(typeof instance.sortColumn == 'undefined'){\n      return;\n    }\n\n    Handsontable.hooks.run(instance, 'beforeColumnSort', instance.sortColumn, instance.sortOrder);\n\n    plugin.sort.call(instance);\n    instance.render();\n\n    saveSortingState.call(instance);\n\n    Handsontable.hooks.run(instance, 'afterColumnSort', instance.sortColumn, instance.sortOrder);\n  };\n\n  var saveSortingState = function () {\n    var instance = this;\n\n    var sortingState = {};\n\n    if (typeof instance.sortColumn != 'undefined') {\n      sortingState.sortColumn = instance.sortColumn;\n    }\n\n    if (typeof instance.sortOrder != 'undefined') {\n      sortingState.sortOrder = instance.sortOrder;\n    }\n\n    if (sortingState.hasOwnProperty('sortColumn') || sortingState.hasOwnProperty('sortOrder')) {\n      Handsontable.hooks.run(instance, 'persistentStateSave', 'columnSorting', sortingState);\n    }\n\n  };\n\n  var loadSortingState = function () {\n    var instance = this;\n    var storedState = {};\n    Handsontable.hooks.run(instance, 'persistentStateLoad', 'columnSorting', storedState);\n\n    return storedState.value;\n  };\n\n  var bindColumnSortingAfterClick = function () {\n    var instance = this;\n\n    var eventManager = Handsontable.eventManager(instance);\n    eventManager.addEventListener(instance.rootElement, 'click', function (e){\n      if(Handsontable.Dom.hasClass(e.target, 'columnSorting')) {\n        var col = getColumn(e.target);\n        plugin.sortByColumn.call(instance, col);\n      }\n    });\n\n    function countRowHeaders() {\n      var THs = instance.view.TBODY.querySelector('tr').querySelectorAll('th');\n      return THs.length;\n    }\n\n    function getColumn(target) {\n      var TH = Handsontable.Dom.closest(target, 'TH');\n      return Handsontable.Dom.index(TH) - countRowHeaders();\n    }\n  };\n\n  function enableObserveChangesPlugin () {\n    var instance = this;\n    instance._registerTimeout(setTimeout(function(){\n      instance.updateSettings({\n        observeChanges: true\n      });\n    }, 0));\n  }\n\n  function defaultSort(sortOrder) {\n    return function (a, b) {\n      if(typeof a[1] == \"string\") a[1] = a[1].toLowerCase();\n      if(typeof b[1] == \"string\") b[1] = b[1].toLowerCase();\n\n      if (a[1] === b[1]) {\n        return 0;\n      }\n      if (a[1] === null || a[1] === \"\") {\n        return 1;\n      }\n      if (b[1] === null || b[1] === \"\") {\n        return -1;\n      }\n      if (a[1] < b[1]) return sortOrder ? -1 : 1;\n      if (a[1] > b[1]) return sortOrder ? 1 : -1;\n      return 0;\n    }\n  }\n\n  function dateSort(sortOrder) {\n    return function (a, b) {\n      if (a[1] === b[1]) {\n        return 0;\n      }\n      if (a[1] === null) {\n        return 1;\n      }\n      if (b[1] === null) {\n        return -1;\n      }\n\n      var aDate = new Date(a[1]);\n      var bDate = new Date(b[1]);\n\n      if (aDate < bDate) return sortOrder ? -1 : 1;\n      if (aDate > bDate) return sortOrder ? 1 : -1;\n\n      return 0;\n    }\n  }\n\n  this.sort = function () {\n    var instance = this;\n\n    if (typeof instance.sortOrder == 'undefined') {\n      return;\n    }\n\n    instance.sortingEnabled = false; //this is required by translateRow plugin hook\n    instance.sortIndex.length = 0;\n\n    var colOffset = this.colOffset();\n    for (var i = 0, ilen = this.countRows() - instance.getSettings()['minSpareRows']; i < ilen; i++) {\n      this.sortIndex.push([i, instance.getDataAtCell(i, this.sortColumn + colOffset)]);\n    }\n\n    var colMeta = instance.getCellMeta(0, instance.sortColumn);\n    var sortFunction;\n    switch (colMeta.type) {\n      case 'date':\n        sortFunction = dateSort;\n        break;\n      default:\n        sortFunction = defaultSort;\n    }\n\n    this.sortIndex.sort(sortFunction(instance.sortOrder));\n\n    //Append spareRows\n    for(var i = this.sortIndex.length; i < instance.countRows(); i++){\n      this.sortIndex.push([i, instance.getDataAtCell(i, this.sortColumn + colOffset)]);\n    }\n\n    instance.sortingEnabled = true; //this is required by translateRow plugin hook\n  };\n\n  this.translateRow = function (row) {\n    var instance = this;\n\n    if (instance.sortingEnabled && instance.sortIndex && instance.sortIndex.length && instance.sortIndex[row]) {\n      return instance.sortIndex[row][0];\n    }\n\n    return row;\n  };\n\n  this.untranslateRow = function (row) {\n    var instance = this;\n    if (instance.sortingEnabled && instance.sortIndex && instance.sortIndex.length) {\n      for (var i = 0; i < instance.sortIndex.length; i++) {\n        if (instance.sortIndex[i][0] == row) {\n          return i;\n        }\n      }\n    }\n  };\n\n  this.getColHeader = function (col, TH) {\n    if (this.getSettings().columnSorting && col >= 0) {\n      Handsontable.Dom.addClass(TH.querySelector('.colHeader'), 'columnSorting');\n    }\n  };\n\n  function isSorted(instance){\n    return typeof instance.sortColumn != 'undefined';\n  }\n\n  this.afterCreateRow = function(index, amount){\n    var instance = this;\n\n    if(!isSorted(instance)){\n      return;\n    }\n\n\n    for(var i = 0; i < instance.sortIndex.length; i++){\n      if (instance.sortIndex[i][0] >= index){\n        instance.sortIndex[i][0] += amount;\n      }\n    }\n\n    for(var i=0; i < amount; i++){\n      instance.sortIndex.splice(index+i, 0, [index+i, instance.getData()[index+i][instance.sortColumn + instance.colOffset()]]);\n    }\n\n\n\n    saveSortingState.call(instance);\n\n  };\n\n  this.afterRemoveRow = function(index, amount){\n    var instance = this;\n\n    if(!isSorted(instance)){\n      return;\n    }\n\n    var physicalRemovedIndex = plugin.translateRow.call(instance, index);\n\n    instance.sortIndex.splice(index, amount);\n\n    for(var i = 0; i < instance.sortIndex.length; i++){\n\n      if (instance.sortIndex[i][0] > physicalRemovedIndex){\n        instance.sortIndex[i][0] -= amount;\n      }\n    }\n\n    saveSortingState.call(instance);\n\n  };\n\n  this.afterChangeSort = function (changes/*, source*/) {\n    var instance = this;\n    var sortColumnChanged = false;\n    var selection = {};\n    if (!changes) {\n      return;\n    }\n\n    for (var i = 0; i < changes.length; i++) {\n      if (changes[i][1] == instance.sortColumn) {\n        sortColumnChanged = true;\n        selection.row = plugin.translateRow.call(instance, changes[i][0]);\n        selection.col = changes[i][1];\n        break;\n      }\n    }\n\n    if (sortColumnChanged) {\n      instance._registerTimeout(setTimeout(function () {\n        plugin.sort.call(instance);\n        instance.render();\n        instance.selectCell(plugin.untranslateRow.call(instance, selection.row), selection.col);\n      }, 0));\n    }\n  };\n}\nvar htSortColumn = new HandsontableColumnSorting();\n\nHandsontable.hooks.add('afterInit', function () {\n  htSortColumn.init.call(this, 'afterInit')\n});\nHandsontable.hooks.add('afterUpdateSettings', function () {\n  htSortColumn.init.call(this, 'afterUpdateSettings')\n});\nHandsontable.hooks.add('modifyRow', htSortColumn.translateRow);\nHandsontable.hooks.add('afterGetColHeader', htSortColumn.getColHeader);\n\nHandsontable.hooks.register('beforeColumnSort');\nHandsontable.hooks.register('afterColumnSort');\n\n\n(function (Handsontable) {\n  'use strict';\n\n  function prepareVerticalAlignClass(className, alignment) {\n    if (className.indexOf(alignment) != -1) {\n      return className;\n    }\n\n    className = className\n      .replace('htTop', '')\n      .replace('htMiddle', '')\n      .replace('htBottom', '')\n      .replace('  ', '');\n\n    className += \" \" + alignment;\n    return className;\n  }\n\n  function prepareHorizontalAlignClass(className, alignment) {\n    if (className.indexOf(alignment) != -1) {\n      return className;\n    }\n\n    className = className\n      .replace('htLeft', '')\n      .replace('htCenter', '')\n      .replace('htRight', '')\n      .replace('htJustify', '')\n      .replace('  ', '');\n\n    className += \" \" + alignment;\n    return className;\n  }\n\n  function doAlign(row, col, type, alignment) {\n    var cellMeta = this.getCellMeta(row, col),\n      className = alignment;\n\n    if (cellMeta.className) {\n      if (type === 'vertical') {\n        className = prepareVerticalAlignClass(cellMeta.className, alignment);\n      } else {\n        className = prepareHorizontalAlignClass(cellMeta.className, alignment);\n      }\n    }\n\n    this.setCellMeta(row, col, 'className', className);\n    this.render();\n  }\n\n  function align(range, type, alignment) {\n    if (range.from.row == range.to.row && range.from.col == range.to.col) {\n      doAlign.call(this, range.from.row, range.from.col, type, alignment);\n    } else {\n      for (var row = range.from.row; row <= range.to.row; row++) {\n        for (var col = range.from.col; col <= range.to.col; col++) {\n          doAlign.call(this, row, col, type, alignment);\n        }\n      }\n    }\n  }\n\n  function ContextMenu(instance, customOptions) {\n    this.instance = instance;\n    var contextMenu = this;\n    contextMenu.menus = [];\n    contextMenu.htMenus = {};\n    contextMenu.triggerRows = [];\n\n    contextMenu.eventManager = Handsontable.eventManager(contextMenu);\n\n\n    this.enabled = true;\n\n    this.instance.addHook('afterDestroy', function () {\n      contextMenu.destroy();\n    });\n\n    this.defaultOptions = {\n      items: [\n        {\n          key: 'row_above',\n          name: 'Insert row above',\n          callback: function (key, selection) {\n            this.alter(\"insert_row\", selection.start.row);\n          },\n          disabled: function () {\n            var selected = this.getSelected(),\n              entireColumnSelection = [0, selected[1], this.countRows() - 1, selected[1]],\n              columnSelected = entireColumnSelection.join(',') == selected.join(',');\n\n            return selected[0] < 0 || this.countRows() >= this.getSettings().maxRows || columnSelected;\n          }\n        },\n        {\n          key: 'row_below',\n          name: 'Insert row below',\n          callback: function (key, selection) {\n            this.alter(\"insert_row\", selection.end.row + 1);\n          },\n          disabled: function () {\n            var selected = this.getSelected(),\n              entireColumnSelection = [0, selected[1], this.countRows() - 1, selected[1]],\n              columnSelected = entireColumnSelection.join(',') == selected.join(',');\n\n            return this.getSelected()[0] < 0 || this.countRows() >= this.getSettings().maxRows || columnSelected;\n          }\n        },\n        ContextMenu.SEPARATOR,\n        {\n          key: 'col_left',\n          name: 'Insert column on the left',\n          callback: function (key, selection) {\n            this.alter(\"insert_col\", selection.start.col);\n          },\n          disabled: function () {\n            var selected = this.getSelected(),\n              entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1],\n              rowSelected = entireRowSelection.join(',') == selected.join(',');\n\n            return this.getSelected()[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;\n          }\n        },\n        {\n          key: 'col_right',\n          name: 'Insert column on the right',\n          callback: function (key, selection) {\n            this.alter(\"insert_col\", selection.end.col + 1);\n          },\n          disabled: function () {\n            var selected = this.getSelected(),\n              entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1],\n              rowSelected = entireRowSelection.join(',') == selected.join(',');\n\n            return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;\n          }\n        },\n        ContextMenu.SEPARATOR,\n        {\n          key: 'remove_row',\n          name: 'Remove row',\n          callback: function (key, selection) {\n            var amount = selection.end.row - selection.start.row + 1;\n            this.alter(\"remove_row\", selection.start.row, amount);\n          },\n          disabled: function () {\n            var selected = this.getSelected(),\n              entireColumnSelection = [0, selected[1], this.countRows() - 1, selected[1]],\n              columnSelected = entireColumnSelection.join(',') == selected.join(',');\n            return (selected[0] < 0 || columnSelected);\n          }\n        },\n        {\n          key: 'remove_col',\n          name: 'Remove column',\n          callback: function (key, selection) {\n            var amount = selection.end.col - selection.start.col + 1;\n            this.alter(\"remove_col\", selection.start.col, amount);\n          },\n          disabled: function () {\n            var selected = this.getSelected(),\n              entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1],\n              rowSelected = entireRowSelection.join(',') == selected.join(',');\n            return (selected[1] < 0 || rowSelected);\n          }\n        },\n        ContextMenu.SEPARATOR,\n        {\n          key: 'undo',\n          name: 'Undo',\n          callback: function () {\n            this.undo();\n          },\n          disabled: function () {\n            return this.undoRedo && !this.undoRedo.isUndoAvailable();\n          }\n        },\n        {\n          key: 'redo',\n          name: 'Redo',\n          callback: function () {\n            this.redo();\n          },\n          disabled: function () {\n            return this.undoRedo && !this.undoRedo.isRedoAvailable();\n          }\n        },\n        ContextMenu.SEPARATOR,\n        {\n          key: 'make_read_only',\n          name: function () {\n            var label = \"Read only\";\n            var atLeastOneReadOnly = contextMenu.checkSelectionReadOnlyConsistency(this);\n            if (atLeastOneReadOnly) {\n              label = contextMenu.markSelected(label);\n            }\n            return label;\n          },\n          callback: function () {\n            var atLeastOneReadOnly = contextMenu.checkSelectionReadOnlyConsistency(this);\n\n            var that = this;\n            this.getSelectedRange().forAll(function (r, c) {\n              that.getCellMeta(r, c).readOnly = atLeastOneReadOnly ? false : true;\n            });\n\n            this.render();\n          }\n        },\n        ContextMenu.SEPARATOR,\n        {\n          key: 'alignment',\n          name: 'Alignment',\n          submenu: {\n            items: [\n              {\n                name: function () {\n                  var label = \"Left\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htLeft');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'horizontal', 'htLeft');\n                },\n                disabled: false\n              },\n              {\n                name: function () {\n                  var label = \"Center\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htCenter');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'horizontal', 'htCenter');\n                },\n                disabled: false\n              },\n              {\n                name: function () {\n                  var label = \"Right\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htRight');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'horizontal', 'htRight');\n                },\n                disabled: false\n              },\n              {\n                name: function () {\n                  var label = \"Justify\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htJustify');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'horizontal', 'htJustify');\n                },\n                disabled: false\n              },\n              ContextMenu.SEPARATOR,\n              {\n                name: function () {\n                  var label = \"Top\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htTop');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'vertical', 'htTop');\n                },\n                disabled: false\n              },\n              {\n                name: function () {\n                  var label = \"Middle\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htMiddle');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'vertical', 'htMiddle');\n                },\n                disabled: false\n              },\n              {\n                name: function () {\n                  var label = \"Bottom\";\n                  var hasClass = contextMenu.checkSelectionAlignment(this, 'htBottom');\n\n                  if (hasClass) {\n                    label = contextMenu.markSelected(label);\n                  }\n                  return label;\n                },\n                callback: function () {\n                  align.call(this, this.getSelectedRange(), 'vertical', 'htBottom');\n                },\n                disabled: false\n              }\n            ]\n          }\n        }\n      ]\n    };\n\n    contextMenu.options = {};\n\n    Handsontable.helper.extend(contextMenu.options, this.options);\n\n    this.bindMouseEvents();\n\n    this.markSelected = function (label) {\n      return \"<span class='selected'>\" + String.fromCharCode(10003) + \"</span>\" + label; // workaround for https://github.com/handsontable/handsontable/issues/1946\n    };\n\n    this.checkSelectionAlignment = function (hot, className) {\n      var hasAlignment = false;\n\n      hot.getSelectedRange().forAll(function (r, c) {\n        var metaClassName = hot.getCellMeta(r, c).className;\n        if (metaClassName && metaClassName.indexOf(className) != -1) {\n          hasAlignment = true;\n          return false;\n        }\n      });\n\n      return hasAlignment;\n    };\n\n    if(!this.instance.getSettings().allowInsertRow) {\n      var rowAboveIndex = findIndexByKey(this.defaultOptions.items, 'row_above');\n      this.defaultOptions.items.splice(rowAboveIndex,1);\n      var rowBelowIndex = findIndexByKey(this.defaultOptions.items, 'row_above');\n      this.defaultOptions.items.splice(rowBelowIndex,1);\n      this.defaultOptions.items.splice(rowBelowIndex,1); // FOR SEPARATOR\n\n    }\n\n    if(!this.instance.getSettings().allowInsertColumn) {\n      var colLeftIndex = findIndexByKey(this.defaultOptions.items, 'col_left');\n      this.defaultOptions.items.splice(colLeftIndex,1);\n      var colRightIndex = findIndexByKey(this.defaultOptions.items, 'col_right');\n      this.defaultOptions.items.splice(colRightIndex,1);\n      this.defaultOptions.items.splice(colRightIndex,1); // FOR SEPARATOR\n\n    }\n\n    var removeRow = false;\n    var removeCol = false;\n    var removeRowIndex, removeColumnIndex;\n\n    if(!this.instance.getSettings().allowRemoveRow) {\n      removeRowIndex = findIndexByKey(this.defaultOptions.items, 'remove_row');\n      this.defaultOptions.items.splice(removeRowIndex,1);\n      removeRow = true;\n    }\n\n    if(!this.instance.getSettings().allowRemoveColumn) {\n      removeColumnIndex = findIndexByKey(this.defaultOptions.items, 'remove_col');\n      this.defaultOptions.items.splice(removeColumnIndex,1);\n      removeCol = true;\n    }\n\n    if (removeRow && removeCol) {\n      this.defaultOptions.items.splice(removeColumnIndex,1); // SEPARATOR\n    }\n\n    this.checkSelectionReadOnlyConsistency = function (hot) {\n      var atLeastOneReadOnly = false;\n\n      hot.getSelectedRange().forAll(function (r, c) {\n        if (hot.getCellMeta(r, c).readOnly) {\n          atLeastOneReadOnly = true;\n          return false; //breaks forAll\n        }\n      });\n\n      return atLeastOneReadOnly;\n    };\n\n    Handsontable.hooks.run(instance, 'afterContextMenuDefaultOptions', this.defaultOptions);\n\n  }\n\n  /***\n   * Create DOM instance of contextMenu\n   * @param menuName\n   * @param row\n   * @return {*}\n   */\n  ContextMenu.prototype.createMenu = function (menuName, row) {\n    if (menuName) {\n      menuName = menuName.replace(/ /g, '_'); // replace all spaces in name\n      menuName = 'htContextSubMenu_' + menuName;\n    }\n\n    var menu;\n    if (menuName) {\n      menu = document.querySelector('.htContextMenu.' + menuName);\n    } else {\n      menu = document.querySelector('.htContextMenu');\n    }\n\n\n    if (!menu) {\n      menu = document.createElement('DIV');\n      Handsontable.Dom.addClass(menu, 'htContextMenu');\n      if (menuName) {\n        Handsontable.Dom.addClass(menu, menuName);\n      }\n      document.getElementsByTagName('body')[0].appendChild(menu);\n    }\n\n    if (this.menus.indexOf(menu) < 0) {\n      this.menus.push(menu);\n      row = row || 0;\n      this.triggerRows.push(row);\n    }\n\n    return menu;\n  };\n\n  ContextMenu.prototype.bindMouseEvents = function () {\n\n    function contextMenuOpenListener(event) {\n      var settings = this.instance.getSettings();\n\n      this.closeAll();\n\n      event.preventDefault();\n      Handsontable.helper.stopPropagation(event);\n\n      var showRowHeaders = this.instance.getSettings().rowHeaders,\n        showColHeaders = this.instance.getSettings().colHeaders;\n\n      if (!(showRowHeaders || showColHeaders)) {\n        if (event.target.nodeName != 'TD' && !(Handsontable.Dom.hasClass(event.target, 'current') && Handsontable.Dom.hasClass(event.target, 'wtBorder'))) {\n          return;\n        }\n      }\n      var menu = this.createMenu();\n      var items = this.getItems(settings.contextMenu);\n\n      this.show(menu, items);\n\n      this.setMenuPosition(event, menu);\n\n      this.eventManager.addEventListener(document.documentElement, 'mousedown', Handsontable.helper.proxy(ContextMenu.prototype.closeAll, this));\n    }\n    var eventManager = Handsontable.eventManager(this.instance);\n\n    eventManager.addEventListener(this.instance.rootElement, 'contextmenu', Handsontable.helper.proxy(contextMenuOpenListener, this));\n  };\n\n  ContextMenu.prototype.bindTableEvents = function () {\n    this._afterScrollCallback = function () {};\n    this.instance.addHook('afterScrollVertically', this._afterScrollCallback);\n    this.instance.addHook('afterScrollHorizontally', this._afterScrollCallback);\n  };\n\n  ContextMenu.prototype.unbindTableEvents = function () {\n    if (this._afterScrollCallback) {\n      this.instance.removeHook('afterScrollVertically', this._afterScrollCallback);\n      this.instance.removeHook('afterScrollHorizontally', this._afterScrollCallback);\n      this._afterScrollCallback = null;\n    }\n  };\n\n  ContextMenu.prototype.performAction = function (event, hot) {\n    var contextMenu = this;\n\n    var selectedItemIndex = hot.getSelected()[0];\n    var selectedItem = hot.getData()[selectedItemIndex];\n\n    if (selectedItem.disabled === true || (typeof selectedItem.disabled == 'function' && selectedItem.disabled.call(this.instance) === true)) {\n      return;\n    }\n\n    if (!selectedItem.hasOwnProperty('submenu')) {\n      if (typeof selectedItem.callback != 'function') {\n        return;\n      }\n      var selRange = this.instance.getSelectedRange();\n      var normalizedSelection = ContextMenu.utils.normalizeSelection(selRange);\n\n      selectedItem.callback.call(this.instance, selectedItem.key, normalizedSelection, event);\n      contextMenu.closeAll();\n    }\n  };\n\n  ContextMenu.prototype.unbindMouseEvents = function () {\n    this.eventManager.clear();\n    var eventManager = Handsontable.eventManager(this.instance);\n    eventManager.removeEventListener(this.instance.rootElement, 'contextmenu');\n  };\n\n  ContextMenu.prototype.show = function (menu, items) {\n    var that = this;\n\n    menu.removeAttribute('style');\n    menu.style.display = 'block';\n\n    var settings = {\n      data: items,\n      colHeaders: false,\n      colWidths: [200],\n      readOnly: true,\n      copyPaste: false,\n      columns: [\n        {\n          data: 'name',\n          renderer: Handsontable.helper.proxy(this.renderer, this)\n        }\n      ],\n      renderAllRows: true,\n      beforeKeyDown: function (event) {\n        that.onBeforeKeyDown(event, htContextMenu);\n      },\n      afterOnCellMouseOver: function (event, coords, TD) {\n        that.onCellMouseOver(event, coords, TD, htContextMenu);\n      }\n    };\n\n    var htContextMenu = new Handsontable(menu, settings);\n\n\n    this.eventManager.removeEventListener(menu, 'mousedown');\n    this.eventManager.addEventListener(menu,'mousedown', function (event) {\n      that.performAction(event, htContextMenu)\n    });\n\n    this.bindTableEvents();\n    htContextMenu.listen();\n\n    this.htMenus[htContextMenu.guid] = htContextMenu;\n  };\n\n  ContextMenu.prototype.close = function (menu) {\n    this.hide(menu);\n    this.eventManager.clear();\n    this.unbindTableEvents();\n    this.instance.listen();\n  };\n\n  ContextMenu.prototype.closeAll = function () {\n    while (this.menus.length > 0) {\n      var menu = this.menus.pop();\n      if (menu) {\n        this.close(menu);\n      }\n\n    }\n    this.triggerRows = [];\n  };\n\n  ContextMenu.prototype.closeLastOpenedSubMenu = function () {\n    var menu = this.menus.pop();\n    if (menu) {\n      this.hide(menu);\n    }\n\n  };\n\n  ContextMenu.prototype.hide = function (menu) {\n    menu.style.display = 'none';\n    var instance =this.htMenus[menu.id];\n\n    instance.destroy();\n    delete this.htMenus[menu.id];\n  };\n\n  ContextMenu.prototype.renderer = function (instance, TD, row, col, prop, value) {\n    var contextMenu = this;\n    var item = instance.getData()[row];\n    var wrapper = document.createElement('DIV');\n\n    if (typeof value === 'function') {\n      value = value.call(this.instance);\n    }\n\n    Handsontable.Dom.empty(TD);\n    TD.appendChild(wrapper);\n\n    if (itemIsSeparator(item)) {\n      Handsontable.Dom.addClass(TD, 'htSeparator');\n    } else {\n      Handsontable.Dom.fastInnerHTML(wrapper, value);\n    }\n\n    if (itemIsDisabled(item)) {\n      Handsontable.Dom.addClass(TD, 'htDisabled');\n\n      this.eventManager.addEventListener(wrapper, 'mouseenter', function () {\n        instance.deselectCell();\n      });\n\n    } else {\n      if (isSubMenu(item)) {\n        Handsontable.Dom.addClass(TD, 'htSubmenu');\n\n\n        this.eventManager.addEventListener(wrapper, 'mouseenter', function () {\n          instance.selectCell(row, col);\n        });\n\n      } else {\n        Handsontable.Dom.removeClass(TD, 'htSubmenu');\n        Handsontable.Dom.removeClass(TD, 'htDisabled');\n\n        this.eventManager.addEventListener(wrapper, 'mouseenter', function () {\n          instance.selectCell(row, col);\n        });\n      }\n    }\n\n\n    function isSubMenu(item) {\n      return item.hasOwnProperty('submenu');\n    }\n\n    function itemIsSeparator(item) {\n      return new RegExp(ContextMenu.SEPARATOR.name, 'i').test(item.name);\n    }\n\n    function itemIsDisabled(item) {\n      return item.disabled === true || (typeof item.disabled == 'function' && item.disabled.call(contextMenu.instance) === true);\n    }\n\n\n  };\n\n  ContextMenu.prototype.onCellMouseOver = function (event, coords, TD, hot) {\n    var menusLength = this.menus.length;\n\n    if (menusLength > 0) {\n      var lastMenu = this.menus[menusLength - 1];\n      if (lastMenu.id != hot.guid) {\n        this.closeLastOpenedSubMenu();\n      }\n    } else {\n      this.closeLastOpenedSubMenu();\n    }\n\n    if (TD.className.indexOf('htSubmenu') != -1) {\n      var selectedItem = hot.getData()[coords.row];\n      var items = this.getItems(selectedItem.submenu);\n\n      var subMenu = this.createMenu(selectedItem.name, coords.row);\n      var tdCoords = TD.getBoundingClientRect();\n\n      this.show(subMenu, items);\n      this.setSubMenuPosition(tdCoords, subMenu);\n\n    }\n  };\n\n  ContextMenu.prototype.onBeforeKeyDown = function (event, instance) {\n\n    Handsontable.Dom.enableImmediatePropagation(event);\n    var contextMenu = this;\n\n    var selection = instance.getSelected();\n\n    switch (event.keyCode) {\n\n      case Handsontable.helper.keyCode.ESCAPE:\n        contextMenu.closeAll();\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        break;\n\n      case Handsontable.helper.keyCode.ENTER:\n        if (selection) {\n          contextMenu.performAction(event, instance);\n        }\n        break;\n\n      case Handsontable.helper.keyCode.ARROW_DOWN:\n\n        if (!selection) {\n\n          selectFirstCell(instance, contextMenu);\n\n        } else {\n\n          selectNextCell(selection[0], selection[1], instance, contextMenu);\n\n        }\n\n        event.preventDefault();\n        event.stopImmediatePropagation();\n\n        break;\n\n      case Handsontable.helper.keyCode.ARROW_UP:\n        if (!selection) {\n\n          selectLastCell(instance, contextMenu);\n\n        } else {\n\n          selectPrevCell(selection[0], selection[1], instance, contextMenu);\n\n        }\n\n        event.preventDefault();\n        event.stopImmediatePropagation();\n\n        break;\n      case Handsontable.helper.keyCode.ARROW_RIGHT:\n        if (selection) {\n          var row = selection[0];\n          var cell = instance.getCell(selection[0], 0);\n\n          if (ContextMenu.utils.hasSubMenu(cell)) {\n            openSubMenu(instance, contextMenu, cell, row);\n          }\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n\n        break;\n\n      case Handsontable.helper.keyCode.ARROW_LEFT:\n        if (selection) {\n\n          if (instance.rootElement.className.indexOf('htContextSubMenu_') != -1) {\n            contextMenu.closeLastOpenedSubMenu();\n            var index = contextMenu.menus.length;\n\n            if (index > 0) {\n              var menu = contextMenu.menus[index - 1];\n\n              var triggerRow = contextMenu.triggerRows.pop();\n              instance = this.htMenus[menu.id];\n              instance.selectCell(triggerRow, 0);\n            }\n          }\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n        break;\n    }\n\n    function selectFirstCell(instance) {\n\n      var firstCell = instance.getCell(0, 0);\n\n      if (ContextMenu.utils.isSeparator(firstCell) || ContextMenu.utils.isDisabled(firstCell)) {\n        selectNextCell(0, 0, instance);\n      } else {\n        instance.selectCell(0, 0);\n      }\n\n    }\n\n\n    function selectLastCell(instance) {\n\n      var lastRow = instance.countRows() - 1;\n      var lastCell = instance.getCell(lastRow, 0);\n\n      if (ContextMenu.utils.isSeparator(lastCell) || ContextMenu.utils.isDisabled(lastCell)) {\n        selectPrevCell(lastRow, 0, instance);\n      } else {\n        instance.selectCell(lastRow, 0);\n      }\n\n    }\n\n    function selectNextCell(row, col, instance) {\n      var nextRow = row + 1;\n      var nextCell = nextRow < instance.countRows() ? instance.getCell(nextRow, col) : null;\n\n      if (!nextCell) {\n        return;\n      }\n\n      if (ContextMenu.utils.isSeparator(nextCell) || ContextMenu.utils.isDisabled(nextCell)) {\n        selectNextCell(nextRow, col, instance);\n      } else {\n        instance.selectCell(nextRow, col);\n      }\n    }\n\n    function selectPrevCell(row, col, instance) {\n\n      var prevRow = row - 1;\n      var prevCell = prevRow >= 0 ? instance.getCell(prevRow, col) : null;\n\n      if (!prevCell) {\n        return;\n      }\n\n      if (ContextMenu.utils.isSeparator(prevCell) || ContextMenu.utils.isDisabled(prevCell)) {\n        selectPrevCell(prevRow, col, instance);\n      } else {\n        instance.selectCell(prevRow, col);\n      }\n\n    }\n\n    function openSubMenu(instance, contextMenu, cell, row) {\n      var selectedItem = instance.getData()[row];\n      var items = contextMenu.getItems(selectedItem.submenu);\n      var subMenu = contextMenu.createMenu(selectedItem.name, row);\n      var coords = cell.getBoundingClientRect();\n      var subMenuInstance = contextMenu.show(subMenu, items);\n\n      contextMenu.setSubMenuPosition(coords, subMenu);\n      subMenuInstance.selectCell(0, 0);\n    }\n  };\n\n  function findByKey(items, key) {\n    for (var i = 0, ilen = items.length; i < ilen; i++) {\n      if (items[i].key === key) {\n        return items[i];\n      }\n    }\n  }\n\n  function findIndexByKey(items, key) {\n    for (var i = 0, ilen = items.length; i < ilen; i++) {\n      if (items[i].key === key) {\n        return i;\n      }\n    }\n  }\n\n  ContextMenu.prototype.getItems = function (items) {\n    var menu, item;\n\n    function ContextMenuItem(rawItem) {\n      if (typeof rawItem == 'string') {\n        this.name = rawItem;\n      } else {\n        Handsontable.helper.extend(this, rawItem);\n      }\n    }\n\n    ContextMenuItem.prototype = items;\n\n    if (items && items.items) {\n      items = items.items;\n    }\n\n    if (items === true) {\n      items = this.defaultOptions.items;\n    }\n\n    if (1 == 1) {\n      menu = [];\n      for (var key in items) {\n        if (items.hasOwnProperty(key)) {\n          if (typeof items[key] === 'string') {\n            item = findByKey(this.defaultOptions.items, items[key]);\n          }\n          else {\n            item = findByKey(this.defaultOptions.items, key);\n          }\n          if (!item) {\n            item = items[key];\n          }\n          item = new ContextMenuItem(item);\n          if (typeof items[key] === 'object') {\n            Handsontable.helper.extend(item, items[key]);\n          }\n          if (!item.key) {\n            item.key = key;\n          }\n          menu.push(item);\n        }\n      }\n    }\n\n    return menu;\n  };\n\n  ContextMenu.prototype.setSubMenuPosition = function (coords, menu) {\n    var scrollTop = Handsontable.Dom.getWindowScrollTop();\n    var scrollLeft = Handsontable.Dom.getWindowScrollLeft();\n\n    var cursor = {\n      top: scrollTop + coords.top,\n      topRelative: coords.top,\n      left: coords.left,\n      leftRelative: coords.left - scrollLeft,\n      scrollTop: scrollTop,\n      scrollLeft: scrollLeft,\n      cellHeight: coords.height,\n      cellWidth: coords.width\n    };\n\n    if (this.menuFitsBelowCursor(cursor, menu, document.body.clientWidth)) {\n      this.positionMenuBelowCursor(cursor, menu, true);\n    } else {\n      if (this.menuFitsAboveCursor(cursor, menu)) {\n        this.positionMenuAboveCursor(cursor, menu, true);\n      } else {\n        this.positionMenuBelowCursor(cursor, menu, true);\n      }\n    }\n\n    if (this.menuFitsOnRightOfCursor(cursor, menu, document.body.clientWidth)) {\n      this.positionMenuOnRightOfCursor(cursor, menu, true);\n    } else {\n      this.positionMenuOnLeftOfCursor(cursor, menu, true);\n    }\n  };\n\n  ContextMenu.prototype.setMenuPosition = function (event, menu) {\n    // for ie8\n    // http://msdn.microsoft.com/en-us/library/ie/ff974655(v=vs.85).aspx\n    var scrollTop = Handsontable.Dom.getWindowScrollTop();\n    var scrollLeft = Handsontable.Dom.getWindowScrollLeft();\n    var cursorY = event.pageY || (event.clientY + scrollTop);\n    var cursorX = event.pageX || (event.clientX + scrollLeft);\n\n    var cursor = {\n      top: cursorY,\n      topRelative: cursorY - scrollTop,\n      left: cursorX,\n      leftRelative: cursorX - scrollLeft,\n      scrollTop: scrollTop,\n      scrollLeft: scrollLeft,\n      cellHeight: event.target.clientHeight,\n      cellWidth: event.target.clientWidth\n    };\n\n    if (this.menuFitsBelowCursor(cursor, menu, document.body.clientHeight)) {\n      this.positionMenuBelowCursor(cursor, menu);\n    } else {\n      if (this.menuFitsAboveCursor(cursor, menu)) {\n        this.positionMenuAboveCursor(cursor, menu);\n      } else {\n        this.positionMenuBelowCursor(cursor, menu);\n      }\n    }\n\n    if (this.menuFitsOnRightOfCursor(cursor, menu, document.body.clientWidth)) {\n      this.positionMenuOnRightOfCursor(cursor, menu);\n    } else {\n      this.positionMenuOnLeftOfCursor(cursor, menu);\n    }\n\n  };\n\n  ContextMenu.prototype.menuFitsAboveCursor = function (cursor, menu) {\n    return cursor.topRelative >= menu.offsetHeight;\n  };\n\n  ContextMenu.prototype.menuFitsBelowCursor = function (cursor, menu, viewportHeight) {\n    return cursor.topRelative + menu.offsetHeight <= viewportHeight;\n  };\n\n  ContextMenu.prototype.menuFitsOnRightOfCursor = function (cursor, menu, viewportHeight) {\n    return cursor.leftRelative + menu.offsetWidth <= viewportHeight;\n  };\n\n  ContextMenu.prototype.positionMenuBelowCursor = function (cursor, menu) {\n\n    menu.style.top = cursor.top + 'px';\n  };\n\n  ContextMenu.prototype.positionMenuAboveCursor = function (cursor, menu, subMenu) {\n    if (subMenu) {\n      menu.style.top = (cursor.top + cursor.cellHeight - menu.offsetHeight) + 'px';\n    } else {\n      menu.style.top = (cursor.top - menu.offsetHeight) + 'px';\n    }\n  };\n\n  ContextMenu.prototype.positionMenuOnRightOfCursor = function (cursor, menu, subMenu) {\n    if (subMenu) {\n      menu.style.left = 1 + cursor.left + cursor.cellWidth + 'px';\n    } else {\n      menu.style.left = 1 + cursor.left + 'px';\n    }\n  };\n\n  ContextMenu.prototype.positionMenuOnLeftOfCursor = function (cursor, menu, subMenu) {\n    if (subMenu) {\n      menu.style.left = (cursor.left - menu.offsetWidth) + 'px';\n    } else {\n      menu.style.left = (cursor.left - menu.offsetWidth) + 'px';\n    }\n  };\n\n  ContextMenu.utils = {};\n\n  ContextMenu.utils.normalizeSelection = function (selRange) {\n    return {\n      start: selRange.getTopLeftCorner(),\n      end: selRange.getBottomRightCorner()\n    }\n  };\n\n  ContextMenu.utils.isSeparator = function (cell) {\n    return Handsontable.Dom.hasClass(cell, 'htSeparator');\n  };\n\n  ContextMenu.utils.hasSubMenu = function (cell) {\n    return Handsontable.Dom.hasClass(cell, 'htSubmenu');\n  };\n\n  ContextMenu.utils.isDisabled = function (cell) {\n    return Handsontable.Dom.hasClass(cell, 'htDisabled');\n  };\n\n  ContextMenu.prototype.enable = function () {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.bindMouseEvents();\n    }\n  };\n\n  ContextMenu.prototype.disable = function () {\n    if (this.enabled) {\n      this.enabled = false;\n      this.closeAll();\n      this.unbindMouseEvents();\n      this.unbindTableEvents();\n    }\n  };\n\n  ContextMenu.prototype.destroy = function () {\n    this.closeAll();\n    while (this.menus.length > 0) {\n      var menu = this.menus.pop();\n      this.triggerRows.pop();\n      if (menu) {\n        this.close(menu);\n        if (!this.isMenuEnabledByOtherHotInstance()) {\n          this.removeMenu(menu);\n        }\n      }\n    }\n\n    this.unbindMouseEvents();\n    this.unbindTableEvents();\n\n  };\n\n  ContextMenu.prototype.isMenuEnabledByOtherHotInstance = function () {\n    var hotContainers = document.querySelectorAll('.handsontable');\n    var menuEnabled = false;\n\n    for (var i = 0, len = hotContainers.length; i < len; i++) {\n      var instance = this.htMenus[hotContainers[i].id];\n      if (instance && instance.getSettings().contextMenu) {\n        menuEnabled = true;\n        break;\n      }\n    }\n\n    return menuEnabled;\n  };\n\n  ContextMenu.prototype.removeMenu = function (menu) {\n    if (menu.parentNode) {\n      this.menu.parentNode.removeChild(menu);\n    }\n  };\n\n  ContextMenu.SEPARATOR = {name: \"---------\"};\n\n  function updateHeight() {\n\n    if (this.rootElement.className.indexOf('htContextMenu')) {\n      return;\n    }\n\n    var realSeparatorHeight = 0,\n      realEntrySize = 0,\n      dataSize = this.getSettings().data.length;\n\n    for (var i = 0; i < dataSize; i++) {\n      if (this.getSettings().data[i].name == ContextMenu.SEPARATOR.name) {\n        realSeparatorHeight += 2;\n      } else {\n        realEntrySize += 26;\n      }\n    }\n\n    this.view.wt.wtScrollbars.vertical.fixedContainer.style.height = realEntrySize + realSeparatorHeight + \"px\";\n  }\n\n  function init() {\n    var instance = this;\n    var contextMenuSetting = instance.getSettings().contextMenu;\n    var customOptions = Handsontable.helper.isObject(contextMenuSetting) ? contextMenuSetting : {};\n\n    if (contextMenuSetting) {\n      if (!instance.contextMenu) {\n        instance.contextMenu = new ContextMenu(instance, customOptions);\n      }\n      instance.contextMenu.enable();\n    } else if (instance.contextMenu) {\n      instance.contextMenu.destroy();\n      delete instance.contextMenu;\n    }\n  }\n\n  Handsontable.hooks.add('afterInit', init);\n  Handsontable.hooks.add('afterUpdateSettings', init);\n  Handsontable.hooks.add('afterInit', updateHeight);\n\n  Handsontable.PluginHooks.register('afterContextMenuDefaultOptions');\n\n  Handsontable.ContextMenu = ContextMenu;\n\n})(Handsontable);\n\nfunction Comments(instance) {\n\n  var eventManager = Handsontable.eventManager(instance),\n    doSaveComment = function (row, col, comment, instance) {\n      instance.setCellMeta(row, col, 'comment', comment);\n      instance.render();\n    },\n    saveComment = function (range, comment, instance) {\n     //LIKE IN EXCEL (TOP LEFT CELL)\n      doSaveComment(range.from.row, range.from.col, comment, instance);\n    },\n    hideCommentTextArea = function () {\n      var commentBox = createCommentBox();\n      commentBox.style.display = 'none';\n      commentBox.value = '';\n    },\n    bindMouseEvent = function (range) {\n\n      function commentsListener(event) {\n        eventManager.removeEventListener(document, 'mouseover');\n        if (!(event.target.className == 'htCommentTextArea' || event.target.innerHTML.indexOf('Comment') != -1)) {\n          var value = document.querySelector('.htCommentTextArea').value;\n          if (value.trim().length > 1) {\n            saveComment(range, value, instance);\n          }\n          unBindMouseEvent();\n          hideCommentTextArea();\n        }\n      }\n\n      eventManager.addEventListener(document, 'mousedown',Handsontable.helper.proxy(commentsListener));\n    },\n    unBindMouseEvent = function () {\n      eventManager.removeEventListener(document, 'mousedown');\n      eventManager.addEventListener(document, 'mousedown', Handsontable.helper.proxy(commentsMouseOverListener));\n    },\n    placeCommentBox = function (range, commentBox) {\n      var TD = instance.view.wt.wtTable.getCell(range.from),\n        offset = Handsontable.Dom.offset(TD),\n        lastColWidth = instance.getColWidth(range.from.col);\n\n      commentBox.style.position = 'absolute';\n      commentBox.style.left = offset.left + lastColWidth + 'px';\n      commentBox.style.top = offset.top + 'px';\n      commentBox.style.zIndex = 2;\n      bindMouseEvent(range, commentBox);\n    },\n    createCommentBox = function (value) {\n      var comments = document.querySelector('.htComments');\n\n      if (!comments) {\n        comments = document.createElement('DIV');\n\n        var textArea = document.createElement('TEXTAREA');\n        Handsontable.Dom.addClass(textArea, 'htCommentTextArea');\n        comments.appendChild(textArea);\n\n        Handsontable.Dom.addClass(comments, 'htComments');\n        document.getElementsByTagName('body')[0].appendChild(comments);\n      }\n\n      value = value ||'';\n\n      document.querySelector('.htCommentTextArea').value = value;\n\n      //var tA = document.getElementsByClassName('htCommentTextArea')[0];\n      //tA.focus();\n      return comments;\n    },\n    commentsMouseOverListener = function (event) {\n        if(event.target.className.indexOf('htCommentCell') != -1) {\n            unBindMouseEvent();\n            var coords = instance.view.wt.wtTable.getCoords(event.target);\n            var range = {\n                from: new WalkontableCellCoords(coords.row, coords.col)\n            };\n\n            Handsontable.Comments.showComment(range);\n        }\n        else if(event.target.className !='htCommentTextArea'){\n            hideCommentTextArea();\n        }\n    };\n\n  return {\n    init: function () {\n      eventManager.addEventListener(document, 'mouseover', Handsontable.helper.proxy(commentsMouseOverListener));\n    },\n    showComment: function (range) {\n      var meta = instance.getCellMeta(range.from.row, range.from.col),\n        value = '';\n\n      if (meta.comment) {\n        value = meta.comment;\n      }\n      var commentBox = createCommentBox(value);\n      commentBox.style.display = 'block';\n      placeCommentBox(range, commentBox);\n    },\n    removeComment: function (row, col) {\n      instance.removeCellMeta(row, col, 'comment');\n      instance.render();\n    },\n    checkSelectionCommentsConsistency : function () {\n      var hasComment = false;\n      // IN EXCEL THERE IS COMMENT ONLY FOR TOP LEFT CELL IN SELECTION\n      var cell = instance.getSelectedRange().from;\n\n      if(instance.getCellMeta(cell.row,cell.col).comment) {\n        hasComment = true;\n      }\n      return hasComment;\n    }\n\n\n  };\n}\n\n\nvar init = function () {\n    var instance = this;\n    var commentsSetting = instance.getSettings().comments;\n\n    if (commentsSetting) {\n      Handsontable.Comments = new Comments(instance);\n        Handsontable.Comments.init();\n    }\n  },\n  afterRenderer = function (TD, row, col, prop, value, cellProperties) {\n    if(cellProperties.comment) {\n      Handsontable.Dom.addClass(TD, cellProperties.commentedCellClassName);\n    }\n  },\n  addCommentsActionsToContextMenu = function (defaultOptions) {\n    var instance = this;\n    if (!instance.getSettings().comments) {\n      return;\n    }\n\n    defaultOptions.items.push(Handsontable.ContextMenu.SEPARATOR);\n\n    defaultOptions.items.push({\n      key: 'commentsAddEdit',\n      name: function () {\n        var hasComment = Handsontable.Comments.checkSelectionCommentsConsistency();\n        return hasComment ? \"Edit Comment\" : \"Add Comment\";\n\n      },\n      callback: function (key, selection, event) {\n          Handsontable.Comments.showComment(this.getSelectedRange());\n      },\n      disabled: function () {\n        return false;\n      }\n    });\n\n    defaultOptions.items.push({\n      key: 'commentsRemove',\n      name: function () {\n        return \"Delete Comment\"\n      },\n      callback: function (key, selection, event) {\n        Handsontable.Comments.removeComment(selection.start.row, selection.start.col);\n      },\n      disabled: function () {\n        var hasComment = Handsontable.Comments.checkSelectionCommentsConsistency();\n        return !hasComment;\n      }\n    });\n  };\n\nHandsontable.hooks.add('beforeInit', init);\nHandsontable.hooks.add('afterContextMenuDefaultOptions', addCommentsActionsToContextMenu);\nHandsontable.hooks.add('afterRenderer', afterRenderer);\n\n\n/**\n * HandsontableManualColumnMove\n *\n * Has 2 UI components:\n * - handle - the draggable element that sets the desired position of the column\n * - guide - the helper guide that shows the desired position as a vertical guide\n *\n * Warning! Whenever you make a change in this file, make an analogous change in manualRowMove.js\n * @constructor\n */\n(function (Handsontable) {\nfunction HandsontableManualColumnMove() {\n  var startCol\n    , endCol\n    , startX\n    , startOffset\n    , currentCol\n    , instance\n    , currentTH\n    , handle = document.createElement('DIV')\n    , guide = document.createElement('DIV')\n    , eventManager = Handsontable.eventManager(this);\n\n  handle.className = 'manualColumnMover';\n  guide.className = 'manualColumnMoverGuide';\n\n  var saveManualColumnPositions = function () {\n    var instance = this;\n    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnPositions', instance.manualColumnPositions);\n  };\n\n  var loadManualColumnPositions = function () {\n    var instance = this;\n    var storedState = {};\n    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnPositions', storedState);\n    return storedState.value;\n  };\n\n  function setupHandlePosition(TH) {\n    instance = this;\n    currentTH = TH;\n\n    var col = this.view.wt.wtTable.getCoords(TH).col; //getCoords returns WalkontableCellCoords\n    if (col >= 0) { //if not row header\n      currentCol = col;\n      var box = currentTH.getBoundingClientRect();\n      startOffset = box.left;\n      handle.style.top = box.top + 'px';\n      handle.style.left = startOffset + 'px';\n      instance.rootElement.appendChild(handle);\n    }\n  }\n\n  function refreshHandlePosition(TH, delta) {\n    var box = TH.getBoundingClientRect();\n    var handleWidth = 6;\n    if (delta > 0) {\n      handle.style.left = (box.left + box.width - handleWidth) + 'px';\n    }\n    else {\n      handle.style.left = box.left + 'px';\n    }\n  }\n\n  function setupGuidePosition() {\n    var instance = this;\n    Handsontable.Dom.addClass(handle, 'active');\n    Handsontable.Dom.addClass(guide, 'active');\n    var box = currentTH.getBoundingClientRect();\n    guide.style.width = box.width + 'px';\n    guide.style.height = instance.view.maximumVisibleElementHeight(0) + 'px';\n    guide.style.top = handle.style.top;\n    guide.style.left = startOffset + 'px';\n    instance.rootElement.appendChild(guide);\n  }\n\n  function refreshGuidePosition(diff) {\n    guide.style.left = startOffset + diff + 'px';\n  }\n\n  function hideHandleAndGuide() {\n    Handsontable.Dom.removeClass(handle, 'active');\n    Handsontable.Dom.removeClass(guide, 'active');\n  }\n\n  var checkColumnHeader = function (element) {\n    if (element.tagName != 'BODY') {\n      if (element.parentNode.tagName == 'THEAD') {\n        return true;\n      } else {\n        element = element.parentNode;\n        return checkColumnHeader(element);\n      }\n    }\n    return false;\n  };\n\n  var getTHFromTargetElement = function (element) {\n    if (element.tagName != 'TABLE') {\n      if (element.tagName == 'TH') {\n        return element;\n      } else {\n        return getTHFromTargetElement(element.parentNode);\n      }\n    }\n    return null;\n  };\n\n  var bindEvents = function () {\n\n    var instance = this;\n    var pressed;\n\n    eventManager.addEventListener(instance.rootElement,'mouseover',function (e) {\n        if (checkColumnHeader(e.target)){\n          var th = getTHFromTargetElement(e.target);\n          if (th) {\n            if (pressed) {\n              var col = instance.view.wt.wtTable.getCoords(th).col;\n            if(col >= 0) { //not TH above row header\n                endCol = col;\n                refreshHandlePosition(e.target, endCol - startCol);\n            }\n            }\n            else {\n              setupHandlePosition.call(instance, th);\n            }\n          }\n        }\n    });\n\n    eventManager.addEventListener(instance.rootElement,'mousedown', function (e) {\n      if (Handsontable.Dom.hasClass(e.target, 'manualColumnMover')){\n        startX = Handsontable.helper.pageX(e);\n        setupGuidePosition.call(instance);\n        pressed = instance;\n\n        startCol = currentCol;\n        endCol = currentCol;\n      }\n    });\n\n    eventManager.addEventListener(window,'mousemove',function (e) {\n      if (pressed) {\n        refreshGuidePosition(Handsontable.helper.pageX(e) - startX);\n      }\n    });\n\n\n    eventManager.addEventListener(window,'mouseup',function (e) {\n      if (pressed) {\n        hideHandleAndGuide();\n        pressed = false;\n\n        createPositionData(instance.manualColumnPositions, instance.countCols());\n        instance.manualColumnPositions.splice(endCol, 0, instance.manualColumnPositions.splice(startCol, 1)[0]);\n\n        instance.forceFullRender = true;\n        instance.view.render(); //updates all\n\n        saveManualColumnPositions.call(instance);\n\n        Handsontable.hooks.run(instance, 'afterColumnMove', startCol, endCol);\n\n        setupHandlePosition.call(instance, currentTH);\n      }\n    });\n\n    instance.addHook('afterDestroy', unbindEvents);\n  };\n\n  var unbindEvents = function(){\n    eventManager.clear();\n  };\n\n  var createPositionData = function (positionArr, len) {\n    if (positionArr.length < len) {\n      for (var i = positionArr.length; i < len; i++) {\n        positionArr[i] = i;\n      }\n    }\n  };\n\n  this.beforeInit = function () {\n    this.manualColumnPositions = [];\n  };\n\n  this.init = function (source) {\n    var instance = this;\n\n    var manualColMoveEnabled = !!(this.getSettings().manualColumnMove);\n\n    if (manualColMoveEnabled) {\n      var initialManualColumnPositions = this.getSettings().manualColumnMove;\n\n      var loadedManualColumnPositions = loadManualColumnPositions.call(instance);\n\n      if (typeof loadedManualColumnPositions != 'undefined') {\n        this.manualColumnPositions = loadedManualColumnPositions;\n      } else if (Array.isArray(initialManualColumnPositions)) {\n        this.manualColumnPositions = initialManualColumnPositions;\n      } else {\n        this.manualColumnPositions = [];\n      }\n\n      if (source == 'afterInit') {\n        bindEvents.call(this);\n        if (this.manualColumnPositions.length > 0) {\n          this.forceFullRender = true;\n          this.render();\n        }\n      }\n\n    } else {\n      unbindEvents.call(this);\n      this.manualColumnPositions = [];\n    }\n  };\n\n  this.modifyCol = function (col) {\n    //TODO test performance: http://jsperf.com/object-wrapper-vs-primitive/2\n    if (this.getSettings().manualColumnMove) {\n      if (typeof this.manualColumnPositions[col] === 'undefined') {\n        createPositionData(this.manualColumnPositions, col + 1);\n      }\n      return this.manualColumnPositions[col];\n    }\n    return col;\n  };\n\n  // need to reconstruct manualcolpositions after removing columns\n  this.afterRemoveCol = function (index, amount) {\n    if (!this.getSettings().manualColumnMove) return;\n\n    var rmindx,\n        colpos = this.manualColumnPositions;\n\n      // We have removed columns, we also need to remove the indicies from manual column array\n      rmindx = colpos.splice(index, amount);\n\n      // We need to remap manualColPositions so it remains constant linear from 0->ncols\n      colpos = colpos.map(function (colpos) {\n        var i, newpos = colpos;\n\n       for (i = 0; i < rmindx.length; i++) {\n         if (colpos > rmindx[i]) newpos--;\n       }\n\n       return newpos;\n     });\n\n      this.manualColumnPositions = colpos;\n    };\n\n    // need to reconstruct manualcolpositions after adding columns\n    this.afterCreateCol = function (index, amount) {\n      if (!this.getSettings().manualColumnMove) return;\n\n      var colpos = this.manualColumnPositions;\n      if (!colpos.length) return;\n\n      var addindx = [];\n      for (var i = 0; i < amount; i++) {\n        addindx.push(index + i);\n      }\n\n      if (index >= colpos.length) {\n        colpos.concat(addindx);\n      }\n      else {\n        // We need to remap manualColPositions so it remains constant linear from 0->ncols\n        colpos = colpos.map(function (colpos) {\n          return (colpos >= index) ? (colpos + amount) : colpos;\n        });\n\n        // We have added columns, we also need to add new indicies to manualcolumn position array\n        colpos.splice.apply(colpos, [index, 0].concat(addindx));\n      }\n\n      this.manualColumnPositions = colpos;\n    };\n}\nvar htManualColumnMove = new HandsontableManualColumnMove();\n\nHandsontable.hooks.add('beforeInit', htManualColumnMove.beforeInit);\nHandsontable.hooks.add('afterInit', function () {\n  htManualColumnMove.init.call(this, 'afterInit')\n});\n\nHandsontable.hooks.add('afterUpdateSettings', function () {\n  htManualColumnMove.init.call(this, 'afterUpdateSettings')\n});\nHandsontable.hooks.add('modifyCol', htManualColumnMove.modifyCol);\n\nHandsontable.hooks.add('afterRemoveCol', htManualColumnMove.afterRemoveCol);\nHandsontable.hooks.add('afterCreateCol', htManualColumnMove.afterCreateCol);\nHandsontable.hooks.register('afterColumnMove');\n\n})(Handsontable);\n\n\n\n/**\n * HandsontableManualColumnResize\n *\n * Has 2 UI components:\n * - handle - the draggable element that sets the desired width of the column\n * - guide - the helper guide that shows the desired width as a vertical guide\n *\n * Warning! Whenever you make a change in this file, make an analogous change in manualRowResize.js\n * @constructor\n */\n(function (Handsontable) {\nfunction HandsontableManualColumnResize() {\n  var currentTH\n    , currentCol\n    , currentWidth\n    , instance\n    , newSize\n    , startX\n    , startWidth\n    , startOffset\n    , handle = document.createElement('DIV')\n    , guide = document.createElement('DIV')\n    , eventManager = Handsontable.eventManager(this);\n\n\n\n  handle.className = 'manualColumnResizer';\n  guide.className = 'manualColumnResizerGuide';\n\n  var saveManualColumnWidths = function () {\n    var instance = this;\n    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnWidths', instance.manualColumnWidths);\n  };\n\n  var loadManualColumnWidths = function () {\n    var instance = this;\n    var storedState = {};\n    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnWidths', storedState);\n    return storedState.value;\n  };\n\n  function setupHandlePosition(TH) {\n    instance = this;\n    currentTH = TH;\n\n    var col = this.view.wt.wtTable.getCoords(TH).col; //getCoords returns WalkontableCellCoords\n    if (col >= 0) { //if not row header\n      currentCol = col;\n      var box = currentTH.getBoundingClientRect();\n      startOffset = box.left - 6;\n      startWidth = parseInt(box.width, 10);\n      handle.style.top = box.top + 'px';\n      handle.style.left = startOffset + startWidth + 'px';\n      instance.rootElement.appendChild(handle);\n    }\n  }\n\n  function refreshHandlePosition() {\n    handle.style.left = startOffset + currentWidth + 'px';\n  }\n\n  function setupGuidePosition() {\n    var instance = this;\n    Handsontable.Dom.addClass(handle, 'active');\n    Handsontable.Dom.addClass(guide, 'active');\n    guide.style.top = handle.style.top;\n    guide.style.left = handle.style.left;\n    guide.style.height = instance.view.maximumVisibleElementHeight(0) + 'px';\n    instance.rootElement.appendChild(guide);\n  }\n\n  function refreshGuidePosition() {\n    guide.style.left = handle.style.left;\n  }\n\n  function hideHandleAndGuide() {\n    Handsontable.Dom.removeClass(handle, 'active');\n    Handsontable.Dom.removeClass(guide, 'active');\n  }\n\n  var checkColumnHeader = function (element) {\n    if (element.tagName != 'BODY') {\n      if (element.parentNode.tagName == 'THEAD') {\n        return true;\n      } else {\n        element = element.parentNode;\n        return checkColumnHeader(element);\n      }\n    }\n    return false;\n  };\n\n  var getTHFromTargetElement = function (element) {\n    if (element.tagName != 'TABLE') {\n      if (element.tagName == 'TH') {\n        return element;\n      } else {\n        return getTHFromTargetElement(element.parentNode);\n      }\n    }\n    return null;\n  };\n\n  var bindEvents = function () {\n    var instance = this;\n    var pressed;\n    var dblclick = 0;\n    var autoresizeTimeout = null;\n\n    eventManager.addEventListener(instance.rootElement, 'mouseover',function (e) {\n      if (checkColumnHeader(e.target)) {\n        var th = getTHFromTargetElement(e.target);\n        if (th) {\n          if (!pressed) {\n            setupHandlePosition.call(instance, th);\n          }\n        }\n      }\n    });\n\n    eventManager.addEventListener(instance.rootElement,'mousedown', function (e) {\n      if (Handsontable.Dom.hasClass(e.target, 'manualColumnResizer')) {\n        setupGuidePosition.call(instance);\n        pressed = instance;\n\n        if (autoresizeTimeout == null) {\n          autoresizeTimeout = setTimeout(function () {\n            if (dblclick >= 2) {\n              newSize = instance.determineColumnWidth.call(instance, currentCol);\n              setManualSize(currentCol, newSize);\n              instance.forceFullRender = true;\n              instance.view.render(); //updates all\n              Handsontable.hooks.run(instance, 'afterColumnResize', currentCol, newSize);\n            }\n            dblclick = 0;\n            autoresizeTimeout = null;\n          }, 500);\n          instance._registerTimeout(autoresizeTimeout);\n        }\n        dblclick++;\n\n        startX = Handsontable.helper.pageX(e);\n        newSize = startWidth;\n      }\n    });\n\n    eventManager.addEventListener(window,'mousemove', function (e) {\n      if (pressed) {\n        currentWidth = startWidth + (Handsontable.helper.pageX(e) - startX);\n        newSize = setManualSize(currentCol, currentWidth); //save col width\n        refreshHandlePosition();\n        refreshGuidePosition();\n      }\n    });\n\n    eventManager.addEventListener(window, 'mouseup', function (){\n      if (pressed) {\n        hideHandleAndGuide();\n        pressed = false;\n\n        if(newSize != startWidth){\n          instance.forceFullRender = true;\n          instance.view.render(); //updates all\n\n          saveManualColumnWidths.call(instance);\n\n          Handsontable.hooks.run(instance, 'afterColumnResize', currentCol, newSize);\n        }\n\n        setupHandlePosition.call(instance, currentTH);\n      }\n    });\n\n    instance.addHook('afterDestroy', unbindEvents);\n  };\n\n  var unbindEvents = function(){\n    eventManager.clear();\n  };\n\n  this.beforeInit = function () {\n    this.manualColumnWidths = [];\n  };\n\n  this.init = function (source) {\n    var instance = this;\n    var manualColumnWidthEnabled = !!(this.getSettings().manualColumnResize);\n\n    if (manualColumnWidthEnabled) {\n      var initialColumnWidths = this.getSettings().manualColumnResize;\n\n      var loadedManualColumnWidths = loadManualColumnWidths.call(instance);\n\n      if (typeof loadedManualColumnWidths != 'undefined') {\n        this.manualColumnWidths = loadedManualColumnWidths;\n      } else if (Array.isArray(initialColumnWidths)) {\n        this.manualColumnWidths = initialColumnWidths;\n      } else {\n        this.manualColumnWidths = [];\n      }\n\n      if (source == 'afterInit') {\n        bindEvents.call(this);\n        if (this.manualColumnWidths.length > 0) {\n          this.forceFullRender = true;\n          this.render();\n        }\n      }\n    }\n    else {\n      unbindEvents.call(this);\n      this.manualColumnWidths = [];\n    }\n  };\n\n\n  var setManualSize = function (col, width) {\n    width = Math.max(width, 20);\n\n    /**\n     *  We need to run col through modifyCol hook, in case the order of displayed columns is different than the order\n     *  in data source. For instance, this order can be modified by manualColumnMove plugin.\n     */\n    col = Handsontable.hooks.execute(instance, 'modifyCol', col);\n\n    instance.manualColumnWidths[col] = width;\n    return width;\n  };\n\n  this.modifyColWidth = function (width, col) {\n    col = this.runHooksAndReturn('modifyCol', col);\n    if (this.getSettings().manualColumnResize && this.manualColumnWidths[col]) {\n      return this.manualColumnWidths[col];\n    }\n    return width;\n  };\n}\nvar htManualColumnResize = new HandsontableManualColumnResize();\n\nHandsontable.hooks.add('beforeInit', htManualColumnResize.beforeInit);\nHandsontable.hooks.add('afterInit', function () {\n  htManualColumnResize.init.call(this, 'afterInit')\n});\nHandsontable.hooks.add('afterUpdateSettings', function () {\n  htManualColumnResize.init.call(this, 'afterUpdateSettings')\n});\nHandsontable.hooks.add('modifyColWidth', htManualColumnResize.modifyColWidth);\n\nHandsontable.hooks.register('afterColumnResize');\n\n})(Handsontable);\n\n/**\n * HandsontableManualRowResize\n *\n * Has 2 UI components:\n * - handle - the draggable element that sets the desired height of the row\n * - guide - the helper guide that shows the desired height as a horizontal guide\n *\n * Warning! Whenever you make a change in this file, make an analogous change in manualRowResize.js\n * @constructor\n */\n(function (Handsontable) {\n  function HandsontableManualRowResize () {\n\n    var currentTH\n      , currentRow\n      , currentHeight\n      , instance\n      , newSize\n      , startY\n      , startHeight\n      , startOffset\n      , handle = document.createElement('DIV')\n      , guide = document.createElement('DIV')\n      , eventManager = Handsontable.eventManager(this);\n\n    handle.className = 'manualRowResizer';\n    guide.className = 'manualRowResizerGuide';\n\n    var saveManualRowHeights = function () {\n      var instance = this;\n      Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowHeights', instance.manualRowHeights);\n    };\n\n    var loadManualRowHeights = function () {\n      var instance = this\n        , storedState = {};\n      Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowHeights', storedState);\n      return storedState.value;\n    };\n\n    function setupHandlePosition(TH) {\n      instance = this;\n      currentTH = TH;\n\n      var row = this.view.wt.wtTable.getCoords(TH).row; //getCoords returns WalkontableCellCoords\n      if (row >= 0) { //if not col header\n        currentRow = row;\n        var box = currentTH.getBoundingClientRect();\n        startOffset = box.top - 6;\n        startHeight = parseInt(box.height, 10);\n        handle.style.left = box.left + 'px';\n        handle.style.top = startOffset + startHeight + 'px';\n        instance.rootElement.appendChild(handle);\n      }\n    }\n\n    function refreshHandlePosition() {\n      handle.style.top = startOffset + currentHeight + 'px';\n    }\n\n    function setupGuidePosition() {\n      var instance = this;\n      Handsontable.Dom.addClass(handle, 'active');\n      Handsontable.Dom.addClass(guide, 'active');\n      guide.style.top = handle.style.top;\n      guide.style.left = handle.style.left;\n      guide.style.width = instance.view.maximumVisibleElementWidth(0) + 'px';\n      instance.rootElement.appendChild(guide);\n    }\n\n    function refreshGuidePosition() {\n      guide.style.top = handle.style.top;\n    }\n\n    function hideHandleAndGuide() {\n      Handsontable.Dom.removeClass(handle, 'active');\n      Handsontable.Dom.removeClass(guide, 'active');\n    }\n\n    var checkRowHeader = function (element) {\n      if (element.tagName != 'BODY') {\n        if (element.parentNode.tagName == 'TBODY') {\n          return true;\n        } else {\n          element = element.parentNode;\n          return checkRowHeader(element);\n        }\n      }\n      return false;\n    };\n\n    var getTHFromTargetElement = function (element) {\n      if (element.tagName != 'TABLE') {\n        if (element.tagName == 'TH') {\n          return element;\n        } else {\n          return getTHFromTargetElement(element.parentNode);\n        }\n      }\n      return null;\n    };\n\n    var bindEvents = function () {\n      var instance = this;\n      var pressed;\n      var dblclick = 0;\n      var autoresizeTimeout = null;\n\n      eventManager.addEventListener(instance.rootElement,'mouseover', function (e){\n        if(checkRowHeader(e.target)) {\n          var th = getTHFromTargetElement(e.target)\n          if (th) {\n            if (!pressed) {\n              setupHandlePosition.call(instance, th);\n            }\n          }\n        }\n      });\n\n      eventManager.addEventListener(instance.rootElement,'mousedown', function (e) {\n        if (Handsontable.Dom.hasClass(e.target, 'manualRowResizer')) {\n          setupGuidePosition.call(instance);\n          pressed = instance;\n\n          if (autoresizeTimeout == null) {\n            autoresizeTimeout = setTimeout(function () {\n              if (dblclick >= 2) {\n                setManualSize(currentRow, null); //double click sets auto row size\n                instance.forceFullRender = true;\n                instance.view.render(); //updates all\n                Handsontable.hooks.run(instance, 'afterRowResize', currentRow, newSize);\n              }\n              dblclick = 0;\n              autoresizeTimeout = null;\n            }, 500);\n            instance._registerTimeout(autoresizeTimeout);\n          }\n          dblclick++;\n\n          startY = Handsontable.helper.pageY(e);\n          newSize = startHeight;\n        }\n      });\n\n      eventManager.addEventListener(window,'mousemove',function (e) {\n        if (pressed) {\n          currentHeight = startHeight + (Handsontable.helper.pageY(e) - startY);\n          newSize = setManualSize(currentRow, currentHeight);\n          refreshHandlePosition();\n          refreshGuidePosition();\n        }\n      });\n\n      eventManager.addEventListener(window,'mouseup',function (e) {\n        if (pressed) {\n          hideHandleAndGuide();\n          pressed = false;\n\n          if(newSize != startHeight){\n            instance.forceFullRender = true;\n            instance.view.render(); //updates all\n\n            saveManualRowHeights.call(instance);\n\n            Handsontable.hooks.run(instance, 'afterRowResize', currentRow, newSize);\n          }\n\n          setupHandlePosition.call(instance, currentTH);\n        }\n      });\n\n      instance.addHook('afterDestroy', unbindEvents);\n    };\n\n    var unbindEvents = function(){\n      eventManager.clear();\n    };\n\n    this.beforeInit = function () {\n      this.manualRowHeights = [];\n    };\n\n    this.init = function (source) {\n      var instance = this;\n      var manualColumnHeightEnabled = !!(this.getSettings().manualRowResize);\n\n      if (manualColumnHeightEnabled) {\n\n        var initialRowHeights = this.getSettings().manualRowResize;\n\n        var loadedManualRowHeights = loadManualRowHeights.call(instance);\n\n        if (typeof loadedManualRowHeights != 'undefined') {\n          this.manualRowHeights = loadedManualRowHeights;\n        } else if (Array.isArray(initialRowHeights)) {\n          this.manualRowHeights = initialRowHeights;\n        } else {\n          this.manualRowHeights = [];\n        }\n\n        if (source === 'afterInit') {\n          bindEvents.call(this);\n          if (this.manualRowHeights.length > 0) {\n            this.forceFullRender = true;\n            this.render();\n          }\n        }\n        else {\n          this.forceFullRender = true;\n          this.render();\n\n        }\n      }\n      else {\n        unbindEvents.call(this);\n        this.manualRowHeights = [];\n      }\n    };\n\n    var setManualSize = function (row, height) {\n      row = Handsontable.hooks.execute(instance, 'modifyRow', row);\n\n      instance.manualRowHeights[row] = height;\n      return height;\n    };\n\n    this.modifyRowHeight = function (height, row) {\n      if (this.getSettings().manualRowResize) {\n        row = this.runHooksAndReturn('modifyRow', row);\n        if (this.manualRowHeights[row] !== void 0) {\n          return this.manualRowHeights[row];\n        }\n      }\n      return height;\n    };\n  }\n\n  var htManualRowResize = new HandsontableManualRowResize();\n\n  Handsontable.hooks.add('beforeInit', htManualRowResize.beforeInit);\n  Handsontable.hooks.add('afterInit', function () {\n    htManualRowResize.init.call(this, 'afterInit');\n  });\n\n  Handsontable.hooks.add('afterUpdateSettings', function () {\n    htManualRowResize.init.call(this, 'afterUpdateSettings')\n  });\n\n  Handsontable.hooks.add('modifyRowHeight', htManualRowResize.modifyRowHeight);\n\n  Handsontable.hooks.register('afterRowResize');\n\n})(Handsontable);\n\n(function HandsontableObserveChanges() {\n\n  Handsontable.hooks.add('afterLoadData', init);\n  Handsontable.hooks.add('afterUpdateSettings', init);\n\n  Handsontable.hooks.register('afterChangesObserved');\n\n  function init() {\n    var instance = this;\n    var pluginEnabled = instance.getSettings().observeChanges;\n\n    if (pluginEnabled) {\n      if(instance.observer) {\n        destroy.call(instance); //destroy observer for old data object\n      }\n      createObserver.call(instance);\n      bindEvents.call(instance);\n\n    } else if (!pluginEnabled){\n      destroy.call(instance);\n    }\n  }\n\n  function createObserver(){\n    var instance = this;\n\n    instance.observeChangesActive = true;\n\n    instance.pauseObservingChanges = function(){\n      instance.observeChangesActive = false;\n    };\n\n    instance.resumeObservingChanges = function(){\n      instance.observeChangesActive = true;\n    };\n\n    instance.observedData = instance.getData();\n    instance.observer = jsonpatch.observe(instance.observedData, function (patches) {\n      if(instance.observeChangesActive){\n        runHookForOperation.call(instance, patches);\n        instance.render();\n      }\n\n      instance.runHooks('afterChangesObserved');\n    });\n  }\n\n  function runHookForOperation(rawPatches){\n    var instance = this;\n    var patches = cleanPatches(rawPatches);\n\n    for(var i = 0, len = patches.length; i < len; i++){\n      var patch = patches[i];\n      var parsedPath = parsePath(patch.path);\n\n\n      switch(patch.op){\n        case 'add':\n          if(isNaN(parsedPath.col)){\n            instance.runHooks('afterCreateRow', parsedPath.row);\n          } else {\n            instance.runHooks('afterCreateCol', parsedPath.col);\n          }\n          break;\n\n        case 'remove':\n          if(isNaN(parsedPath.col)){\n            instance.runHooks('afterRemoveRow', parsedPath.row, 1);\n          } else {\n            instance.runHooks('afterRemoveCol', parsedPath.col, 1);\n          }\n          break;\n\n        case 'replace':\n          instance.runHooks('afterChange', [parsedPath.row, parsedPath.col, null, patch.value], 'external');\n          break;\n      }\n    }\n\n    function cleanPatches(rawPatches){\n      var patches;\n\n      patches = removeLengthRelatedPatches(rawPatches);\n      patches = removeMultipleAddOrRemoveColPatches(patches);\n\n      return patches;\n    }\n\n    /**\n     * Removing or adding column will produce one patch for each table row.\n     * This function leaves only one patch for each column add/remove operation\n     */\n    function removeMultipleAddOrRemoveColPatches(rawPatches){\n      var newOrRemovedColumns = [];\n\n      return rawPatches.filter(function(patch){\n        var parsedPath = parsePath(patch.path);\n\n        if(['add', 'remove'].indexOf(patch.op) != -1 && !isNaN(parsedPath.col)){\n          if(newOrRemovedColumns.indexOf(parsedPath.col) != -1){\n            return false;\n          } else {\n            newOrRemovedColumns.push(parsedPath.col);\n          }\n        }\n\n        return true;\n      });\n\n    }\n\n    /**\n     * If observeChanges uses native Object.observe method, then it produces patches for length property.\n     * This function removes them.\n     */\n    function removeLengthRelatedPatches(rawPatches){\n      return rawPatches.filter(function(patch){\n        return !/[/]length/ig.test(patch.path);\n      })\n    }\n\n    function parsePath(path){\n      var match = path.match(/^\\/(\\d+)\\/?(.*)?$/);\n      return {\n        row: parseInt(match[1], 10),\n        col: /^\\d*$/.test(match[2]) ? parseInt(match[2], 10) : match[2]\n      }\n    }\n  }\n\n  function destroy(){\n    var instance = this;\n\n    if (instance.observer){\n      destroyObserver.call(instance);\n      unbindEvents.call(instance);\n    }\n  }\n\n  function destroyObserver(){\n    var instance = this;\n\n    jsonpatch.unobserve(instance.observedData, instance.observer);\n    delete instance.observeChangesActive;\n    delete instance.pauseObservingChanges;\n    delete instance.resumeObservingChanges;\n  }\n\n  function bindEvents(){\n    var instance = this;\n    instance.addHook('afterDestroy', destroy);\n\n    instance.addHook('afterCreateRow', afterTableAlter);\n    instance.addHook('afterRemoveRow', afterTableAlter);\n\n    instance.addHook('afterCreateCol', afterTableAlter);\n    instance.addHook('afterRemoveCol', afterTableAlter);\n\n    instance.addHook('afterChange', function(changes, source){\n      if(source != 'loadData'){\n        afterTableAlter.call(this);\n      }\n    });\n  }\n\n  function unbindEvents(){\n    var instance = this;\n    instance.removeHook('afterDestroy', destroy);\n\n    instance.removeHook('afterCreateRow', afterTableAlter);\n    instance.removeHook('afterRemoveRow', afterTableAlter);\n\n    instance.removeHook('afterCreateCol', afterTableAlter);\n    instance.removeHook('afterRemoveCol', afterTableAlter);\n\n    instance.removeHook('afterChange', afterTableAlter);\n  }\n\n  function afterTableAlter(){\n    var instance = this;\n\n    instance.pauseObservingChanges();\n\n    instance.addHookOnce('afterChangesObserved', function(){\n      instance.resumeObservingChanges();\n    });\n\n  }\n})();\n\n\n/*\n *\n * Plugin enables saving table state\n *\n * */\n\n\nfunction Storage(prefix) {\n\n  var savedKeys;\n\n  var saveSavedKeys = function () {\n    window.localStorage[prefix + '__' + 'persistentStateKeys'] = JSON.stringify(savedKeys);\n  };\n\n  var loadSavedKeys = function () {\n    var keysJSON = window.localStorage[prefix + '__' + 'persistentStateKeys'];\n    var keys = typeof keysJSON == 'string' ? JSON.parse(keysJSON) : void 0;\n    savedKeys = keys ? keys : [];\n  };\n\n  var clearSavedKeys = function () {\n    savedKeys = [];\n    saveSavedKeys();\n  };\n\n  loadSavedKeys();\n\n  this.saveValue = function (key, value) {\n    window.localStorage[prefix + '_' + key] = JSON.stringify(value);\n    if (savedKeys.indexOf(key) == -1) {\n      savedKeys.push(key);\n      saveSavedKeys();\n    }\n\n  };\n\n  this.loadValue = function (key, defaultValue) {\n\n    key = typeof key != 'undefined' ? key : defaultValue;\n\n    var value = window.localStorage[prefix + '_' + key];\n\n    return typeof value == \"undefined\" ? void 0 : JSON.parse(value);\n\n  };\n\n  this.reset = function (key) {\n    window.localStorage.removeItem(prefix + '_' + key);\n  };\n\n  this.resetAll = function () {\n    for (var index = 0; index < savedKeys.length; index++) {\n      window.localStorage.removeItem(prefix + '_' + savedKeys[index]);\n    }\n\n    clearSavedKeys();\n  };\n\n}\n\n\n(function (StorageClass) {\n  function HandsontablePersistentState() {\n    var plugin = this;\n\n\n    this.init = function () {\n      var instance = this,\n        pluginSettings = instance.getSettings()['persistentState'];\n\n      plugin.enabled = !!(pluginSettings);\n\n      if (!plugin.enabled) {\n        removeHooks.call(instance);\n        return;\n      }\n\n      if (!instance.storage) {\n        instance.storage = new StorageClass(instance.rootElement.id);\n      }\n\n      instance.resetState = plugin.resetValue;\n\n      addHooks.call(instance);\n\n    };\n\n    this.saveValue = function (key, value) {\n      var instance = this;\n\n      instance.storage.saveValue(key, value);\n    };\n\n    this.loadValue = function (key, saveTo) {\n      var instance = this;\n\n      saveTo.value = instance.storage.loadValue(key);\n    };\n\n    this.resetValue = function (key) {\n      var instance = this;\n\n      if (typeof  key != 'undefined') {\n        instance.storage.reset(key);\n      } else {\n        instance.storage.resetAll();\n      }\n\n    };\n\n    var hooks = {\n      'persistentStateSave': plugin.saveValue,\n      'persistentStateLoad': plugin.loadValue,\n      'persistentStateReset': plugin.resetValue\n    };\n\n    for (var hookName in hooks) {\n      if (hooks.hasOwnProperty(hookName)) {\n        Handsontable.hooks.register(hookName);\n      }\n    }\n\n    function addHooks() {\n      var instance = this;\n\n      for (var hookName in hooks) {\n        if (hooks.hasOwnProperty(hookName)) {\n          instance.addHook(hookName, hooks[hookName]);\n        }\n      }\n    }\n\n    function removeHooks() {\n      var instance = this;\n\n      for (var hookName in hooks) {\n        if (hooks.hasOwnProperty(hookName)) {\n          instance.removeHook(hookName, hooks[hookName]);\n        }\n      }\n    }\n  }\n\n  var htPersistentState = new HandsontablePersistentState();\n  Handsontable.hooks.add('beforeInit', htPersistentState.init);\n  Handsontable.hooks.add('afterUpdateSettings', htPersistentState.init);\n})(Storage);\n\n/**\n * Handsontable UndoRedo class\n */\n(function(Handsontable){\n  Handsontable.UndoRedo = function (instance) {\n    var plugin = this;\n    this.instance = instance;\n    this.doneActions = [];\n    this.undoneActions = [];\n    this.ignoreNewActions = false;\n    instance.addHook(\"afterChange\", function (changes, origin) {\n      if(changes){\n        var action = new Handsontable.UndoRedo.ChangeAction(changes);\n        plugin.done(action);\n      }\n    });\n\n    instance.addHook(\"afterCreateRow\", function (index, amount, createdAutomatically) {\n\n      if (createdAutomatically) {\n        return;\n      }\n\n      var action = new Handsontable.UndoRedo.CreateRowAction(index, amount);\n      plugin.done(action);\n    });\n\n    instance.addHook(\"beforeRemoveRow\", function (index, amount) {\n      var originalData = plugin.instance.getData();\n      index = ( originalData.length + index ) % originalData.length;\n      var removedData = originalData.slice(index, index + amount);\n      var action = new Handsontable.UndoRedo.RemoveRowAction(index, removedData);\n      plugin.done(action);\n    });\n\n    instance.addHook(\"afterCreateCol\", function (index, amount, createdAutomatically) {\n\n      if (createdAutomatically) {\n        return;\n      }\n\n      var action = new Handsontable.UndoRedo.CreateColumnAction(index, amount);\n      plugin.done(action);\n    });\n\n    instance.addHook(\"beforeRemoveCol\", function (index, amount) {\n      var originalData = plugin.instance.getData();\n      index = ( plugin.instance.countCols() + index ) % plugin.instance.countCols();\n      var removedData = [];\n\n      for (var i = 0, len = originalData.length; i < len; i++) {\n        removedData[i] = originalData[i].slice(index, index + amount);\n      }\n\n      var headers;\n      if(Array.isArray(instance.getSettings().colHeaders)){\n        headers = instance.getSettings().colHeaders.slice(index, index + removedData.length);\n      }\n\n      var action = new Handsontable.UndoRedo.RemoveColumnAction(index, removedData, headers);\n      plugin.done(action);\n    });\n  };\n\n  Handsontable.UndoRedo.prototype.done = function (action) {\n    if (!this.ignoreNewActions) {\n      this.doneActions.push(action);\n      this.undoneActions.length = 0;\n    }\n  };\n\n  /**\n   * Undo operation from current revision\n   */\n  Handsontable.UndoRedo.prototype.undo = function () {\n    if (this.isUndoAvailable()) {\n      var action = this.doneActions.pop();\n\n      this.ignoreNewActions = true;\n      var that = this;\n      action.undo(this.instance, function () {\n        that.ignoreNewActions = false;\n        that.undoneActions.push(action);\n      });\n\n\n\n    }\n  };\n\n  /**\n   * Redo operation from current revision\n   */\n  Handsontable.UndoRedo.prototype.redo = function () {\n    if (this.isRedoAvailable()) {\n      var action = this.undoneActions.pop();\n\n      this.ignoreNewActions = true;\n      var that = this;\n      action.redo(this.instance, function () {\n        that.ignoreNewActions = false;\n        that.doneActions.push(action);\n      });\n\n\n\n    }\n  };\n\n  /**\n   * Returns true if undo point is available\n   * @return {Boolean}\n   */\n  Handsontable.UndoRedo.prototype.isUndoAvailable = function () {\n    return this.doneActions.length > 0;\n  };\n\n  /**\n   * Returns true if redo point is available\n   * @return {Boolean}\n   */\n  Handsontable.UndoRedo.prototype.isRedoAvailable = function () {\n    return this.undoneActions.length > 0;\n  };\n\n  /**\n   * Clears undo history\n   */\n  Handsontable.UndoRedo.prototype.clear = function () {\n    this.doneActions.length = 0;\n    this.undoneActions.length = 0;\n  };\n\n  Handsontable.UndoRedo.Action = function () {\n  };\n  Handsontable.UndoRedo.Action.prototype.undo = function () {\n  };\n  Handsontable.UndoRedo.Action.prototype.redo = function () {\n  };\n\n  Handsontable.UndoRedo.ChangeAction = function (changes) {\n    this.changes = changes;\n  };\n  Handsontable.helper.inherit(Handsontable.UndoRedo.ChangeAction, Handsontable.UndoRedo.Action);\n  Handsontable.UndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {\n    var data = Handsontable.helper.deepClone(this.changes),\n        emptyRowsAtTheEnd = instance.countEmptyRows(true),\n        emptyColsAtTheEnd = instance.countEmptyCols(true);\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      data[i].splice(3, 1);\n    }\n\n    instance.addHookOnce('afterChange', undoneCallback);\n\n    instance.setDataAtRowProp(data, null, null, 'undo');\n\n    for (var i = 0, len = data.length; i < len; i++) {\n     if(instance.getSettings().minSpareRows &&\n      data[i][0] + 1 + instance.getSettings().minSpareRows === instance.countRows()\n      && emptyRowsAtTheEnd == instance.getSettings().minSpareRows) {\n        instance.alter('remove_row', parseInt(data[i][0]+1,10), instance.getSettings().minSpareRows);\n\n        instance.undoRedo.doneActions.pop();\n\n      }\n\n      if (instance.getSettings().minSpareCols &&\n      data[i][1] + 1 + instance.getSettings().minSpareCols === instance.countCols()\n      && emptyColsAtTheEnd == instance.getSettings().minSpareCols) {\n        instance.alter('remove_col', parseInt(data[i][1]+1,10), instance.getSettings().minSpareCols);\n\n        instance.undoRedo.doneActions.pop();\n      }\n    }\n\n  };\n  Handsontable.UndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {\n    var data = Handsontable.helper.deepClone(this.changes);\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      data[i].splice(2, 1);\n    }\n\n    instance.addHookOnce('afterChange', onFinishCallback);\n\n    instance.setDataAtRowProp(data, null, null, 'redo');\n\n  };\n\n  Handsontable.UndoRedo.CreateRowAction = function (index, amount) {\n    this.index = index;\n    this.amount = amount;\n  };\n  Handsontable.helper.inherit(Handsontable.UndoRedo.CreateRowAction, Handsontable.UndoRedo.Action);\n  Handsontable.UndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {\n    instance.addHookOnce('afterRemoveRow', undoneCallback);\n    instance.alter('remove_row', this.index, this.amount);\n  };\n  Handsontable.UndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {\n    instance.addHookOnce('afterCreateRow', redoneCallback);\n    instance.alter('insert_row', this.index + 1, this.amount);\n  };\n\n  Handsontable.UndoRedo.RemoveRowAction = function (index, data) {\n    this.index = index;\n    this.data = data;\n  };\n  Handsontable.helper.inherit(Handsontable.UndoRedo.RemoveRowAction, Handsontable.UndoRedo.Action);\n  Handsontable.UndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {\n    var spliceArgs = [this.index, 0];\n    Array.prototype.push.apply(spliceArgs, this.data);\n\n    Array.prototype.splice.apply(instance.getData(), spliceArgs);\n\n    instance.addHookOnce('afterRender', undoneCallback);\n    instance.render();\n  };\n  Handsontable.UndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {\n    instance.addHookOnce('afterRemoveRow', redoneCallback);\n    instance.alter('remove_row', this.index, this.data.length);\n  };\n\n  Handsontable.UndoRedo.CreateColumnAction = function (index, amount) {\n    this.index = index;\n    this.amount = amount;\n  };\n  Handsontable.helper.inherit(Handsontable.UndoRedo.CreateColumnAction, Handsontable.UndoRedo.Action);\n  Handsontable.UndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {\n    instance.addHookOnce('afterRemoveCol', undoneCallback);\n    instance.alter('remove_col', this.index, this.amount);\n  };\n  Handsontable.UndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {\n    instance.addHookOnce('afterCreateCol', redoneCallback);\n    instance.alter('insert_col', this.index + 1, this.amount);\n  };\n\n  Handsontable.UndoRedo.RemoveColumnAction = function (index, data, headers) {\n    this.index = index;\n    this.data = data;\n    this.amount = this.data[0].length;\n    this.headers = headers;\n  };\n  Handsontable.helper.inherit(Handsontable.UndoRedo.RemoveColumnAction, Handsontable.UndoRedo.Action);\n  Handsontable.UndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {\n    var row, spliceArgs;\n    for (var i = 0, len = instance.getData().length; i < len; i++) {\n      row = instance.getSourceDataAtRow(i);\n\n      spliceArgs = [this.index, 0];\n      Array.prototype.push.apply(spliceArgs, this.data[i]);\n\n      Array.prototype.splice.apply(row, spliceArgs);\n\n    }\n\n    if(typeof this.headers != 'undefined'){\n      spliceArgs = [this.index, 0];\n      Array.prototype.push.apply(spliceArgs, this.headers);\n      Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArgs);\n    }\n\n    instance.addHookOnce('afterRender', undoneCallback);\n    instance.render();\n  };\n  Handsontable.UndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {\n    instance.addHookOnce('afterRemoveCol', redoneCallback);\n    instance.alter('remove_col', this.index, this.amount);\n  };\n})(Handsontable);\n\n(function(Handsontable){\n\n  function init(){\n    var instance = this;\n    var pluginEnabled = typeof instance.getSettings().undo == 'undefined' || instance.getSettings().undo;\n\n    if(pluginEnabled){\n      if(!instance.undoRedo){\n        instance.undoRedo = new Handsontable.UndoRedo(instance);\n\n        exposeUndoRedoMethods(instance);\n\n        instance.addHook('beforeKeyDown', onBeforeKeyDown);\n        instance.addHook('afterChange', onAfterChange);\n      }\n    } else {\n      if(instance.undoRedo){\n        delete instance.undoRedo;\n\n        removeExposedUndoRedoMethods(instance);\n\n        instance.removeHook('beforeKeyDown', onBeforeKeyDown);\n        instance.removeHook('afterChange', onAfterChange);\n      }\n    }\n  }\n\n  function onBeforeKeyDown(event){\n    var instance = this;\n\n    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n    if(ctrlDown){\n      if (event.keyCode === 89 || (event.shiftKey && event.keyCode === 90)) { //CTRL + Y or CTRL + SHIFT + Z\n        instance.undoRedo.redo();\n        event.stopImmediatePropagation();\n      }\n      else if (event.keyCode === 90) { //CTRL + Z\n        instance.undoRedo.undo();\n        event.stopImmediatePropagation();\n      }\n    }\n  }\n\n  function onAfterChange(changes, source){\n    var instance = this;\n    if (source == 'loadData'){\n      return instance.undoRedo.clear();\n    }\n  }\n\n  function exposeUndoRedoMethods(instance){\n    instance.undo = function(){\n      return instance.undoRedo.undo();\n    };\n\n    instance.redo = function(){\n      return instance.undoRedo.redo();\n    };\n\n    instance.isUndoAvailable = function(){\n      return instance.undoRedo.isUndoAvailable();\n    };\n\n    instance.isRedoAvailable = function(){\n      return instance.undoRedo.isRedoAvailable();\n    };\n\n    instance.clearUndo = function(){\n      return instance.undoRedo.clear();\n    };\n  }\n\n  function removeExposedUndoRedoMethods(instance){\n    delete instance.undo;\n    delete instance.redo;\n    delete instance.isUndoAvailable;\n    delete instance.isRedoAvailable;\n    delete instance.clearUndo;\n  }\n\n  Handsontable.hooks.add('afterInit', init);\n  Handsontable.hooks.add('afterUpdateSettings', init);\n\n})(Handsontable);\n\n/**\n * Plugin used to scroll Handsontable by selecting a cell and dragging outside of visible viewport\n * @constructor\n */\nfunction DragToScroll() {\n  this.boundaries = null;\n  this.callback = null;\n}\n\n/**\n * @param boundaries {Object} compatible with getBoundingClientRect\n */\nDragToScroll.prototype.setBoundaries = function (boundaries) {\n  this.boundaries = boundaries;\n};\n\n/**\n * @param callback {Function}\n */\nDragToScroll.prototype.setCallback = function (callback) {\n  this.callback = callback;\n};\n\n/**\n * Check if mouse position (x, y) is outside of the viewport\n * @param x\n * @param y\n */\nDragToScroll.prototype.check = function (x, y) {\n  var diffX = 0;\n  var diffY = 0;\n\n  if (y < this.boundaries.top) {\n    //y is less than top\n    diffY = y - this.boundaries.top;\n  }\n  else if (y > this.boundaries.bottom) {\n    //y is more than bottom\n    diffY = y - this.boundaries.bottom;\n  }\n\n  if (x < this.boundaries.left) {\n    //x is less than left\n    diffX = x - this.boundaries.left;\n  }\n  else if (x > this.boundaries.right) {\n    //x is more than right\n    diffX = x - this.boundaries.right;\n  }\n\n  this.callback(diffX, diffY);\n};\n\nvar dragToScroll;\nvar instance;\n\nif (typeof Handsontable !== 'undefined') {\n  var setupListening = function (instance) {\n    instance.dragToScrollListening = false;\n    var scrollHandler = instance.view.wt.wtScrollbars.vertical.scrollHandler; //native scroll\n    dragToScroll = new DragToScroll();\n    if (scrollHandler === window) {\n      //not much we can do currently\n      return;\n    }\n    else {\n      dragToScroll.setBoundaries(scrollHandler.getBoundingClientRect());\n    }\n\n    dragToScroll.setCallback(function (scrollX, scrollY) {\n      if (scrollX < 0) {\n          scrollHandler.scrollLeft -= 50;\n      }\n      else if (scrollX > 0) {\n          scrollHandler.scrollLeft += 50;\n      }\n\n      if (scrollY < 0) {\n          scrollHandler.scrollTop -= 20;\n      }\n      else if (scrollY > 0) {\n          scrollHandler.scrollTop += 20;\n      }\n    });\n\n    instance.dragToScrollListening = true;\n  };\n\n  Handsontable.hooks.add('afterInit', function () {\n    var instance = this;\n    var eventManager = Handsontable.eventManager(this);\n\n    eventManager.addEventListener(document,'mouseup', function () {\n      instance.dragToScrollListening = false;\n    });\n\n    eventManager.addEventListener(document,'mousemove', function () {\n      if (instance.dragToScrollListening) {\n        dragToScroll.check(event.clientX, event.clientY);\n      }\n    });\n  });\n\n  Handsontable.hooks.add('afterDestroy', function () {\n    var eventManager = Handsontable.eventManager(this);\n    eventManager.clear();\n  });\n\n  Handsontable.hooks.add('afterOnCellMouseDown', function () {\n    setupListening(this);\n  });\n\n  Handsontable.hooks.add('afterOnCellCornerMouseDown', function () {\n    setupListening(this);\n  });\n\n  Handsontable.plugins.DragToScroll = DragToScroll;\n}\n\n(function (Handsontable, CopyPaste, SheetClip) {\n\n  function CopyPastePlugin(instance) {\n    this.copyPasteInstance = CopyPaste.getInstance();\n\n    this.copyPasteInstance.onCut(onCut);\n    this.copyPasteInstance.onPaste(onPaste);\n    var plugin = this;\n\n    instance.addHook('beforeKeyDown', onBeforeKeyDown);\n\n    function onCut() {\n      if (!instance.isListening()) {\n        return;\n      }\n\n      instance.selection.empty();\n    }\n\n    function onPaste(str) {\n      if (!instance.isListening() || !instance.selection.isSelected()) {\n        return;\n      }\n\n      var input = str.replace(/^[\\r\\n]*/g, '').replace(/[\\r\\n]*$/g, '') //remove newline from the start and the end of the input\n        , inputArray = SheetClip.parse(input)\n        , selected = instance.getSelected()\n        , coordsFrom = new WalkontableCellCoords(selected[0], selected[1])\n        , coordsTo = new WalkontableCellCoords(selected[2], selected[3])\n        , cellRange = new WalkontableCellRange(coordsFrom, coordsFrom, coordsTo)\n        , topLeftCorner = cellRange.getTopLeftCorner()\n        , bottomRightCorner = cellRange.getBottomRightCorner()\n        , areaStart = topLeftCorner\n        , areaEnd = new WalkontableCellCoords(\n          Math.max(bottomRightCorner.row, inputArray.length - 1 + topLeftCorner.row),\n          Math.max(bottomRightCorner.col, inputArray[0].length - 1 + topLeftCorner.col)\n        );\n\n      instance.addHookOnce('afterChange', function (changes, source) {\n        if (changes && changes.length) {\n          this.selectCell(areaStart.row, areaStart.col, areaEnd.row, areaEnd.col);\n        }\n      });\n\n      instance.populateFromArray(areaStart.row, areaStart.col, inputArray, areaEnd.row, areaEnd.col, 'paste', instance.getSettings().pasteMode);\n    };\n\n    function onBeforeKeyDown (event) {\n      if (instance.getSelected()) {\n        if (Handsontable.helper.isCtrlKey(event.keyCode)) {\n          //when CTRL is pressed, prepare selectable text in textarea\n          //http://stackoverflow.com/questions/3902635/how-does-one-capture-a-macs-command-key-via-javascript\n          plugin.setCopyableText();\n          event.stopImmediatePropagation();\n          return;\n        }\n\n        var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n\n        if (event.keyCode == Handsontable.helper.keyCode.A && ctrlDown) {\n          instance._registerTimeout(setTimeout(Handsontable.helper.proxy(plugin.setCopyableText, plugin), 0));\n        }\n      }\n    }\n\n    this.destroy = function () {\n      this.copyPasteInstance.removeCallback(onCut);\n      this.copyPasteInstance.removeCallback(onPaste);\n      this.copyPasteInstance.destroy();\n      instance.removeHook('beforeKeyDown', onBeforeKeyDown);\n    };\n\n    instance.addHook('afterDestroy', Handsontable.helper.proxy(this.destroy, this));\n\n    this.triggerPaste = Handsontable.helper.proxy(this.copyPasteInstance.triggerPaste, this.copyPasteInstance);\n    this.triggerCut = Handsontable.helper.proxy(this.copyPasteInstance.triggerCut, this.copyPasteInstance);\n\n    /**\n     * Prepares copyable text in the invisible textarea\n     */\n    this.setCopyableText = function () {\n\n      var settings = instance.getSettings();\n      var copyRowsLimit = settings.copyRowsLimit;\n      var copyColsLimit = settings.copyColsLimit;\n\n      var selRange = instance.getSelectedRange();\n      var topLeft = selRange.getTopLeftCorner();\n      var bottomRight = selRange.getBottomRightCorner();\n      var startRow = topLeft.row;\n      var startCol = topLeft.col;\n      var endRow = bottomRight.row;\n      var endCol = bottomRight.col;\n      var finalEndRow = Math.min(endRow, startRow + copyRowsLimit - 1);\n      var finalEndCol = Math.min(endCol, startCol + copyColsLimit - 1);\n\n      instance.copyPaste.copyPasteInstance.copyable(instance.getCopyableData(startRow, startCol, finalEndRow, finalEndCol));\n\n      if (endRow !== finalEndRow || endCol !== finalEndCol) {\n        Handsontable.hooks.run(instance, \"afterCopyLimit\", endRow - startRow + 1, endCol - startCol + 1, copyRowsLimit, copyColsLimit);\n      }\n    };\n\n  }\n\n\n\n  function init() {\n    var instance  = this;\n    var pluginEnabled = instance.getSettings().copyPaste !== false;\n\n    if(pluginEnabled && !instance.copyPaste){\n\n      instance.copyPaste = new CopyPastePlugin(instance);\n\n    } else if (!pluginEnabled && instance.copyPaste) {\n\n      instance.copyPaste.destroy();\n      delete instance.copyPaste;\n\n    }\n\n  }\n\n  Handsontable.hooks.add('afterInit', init);\n  Handsontable.hooks.add('afterUpdateSettings', init);\n\n  Handsontable.hooks.register('afterCopyLimit');\n})(Handsontable, CopyPaste, SheetClip);\n(function (Handsontable) {\n\n  'use strict';\n\n  Handsontable.Search = function Search(instance) {\n    this.query = function (queryStr, callback, queryMethod) {\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n      var queryResult = [];\n\n      if (!callback) {\n        callback = Handsontable.Search.global.getDefaultCallback();\n      }\n\n      if (!queryMethod) {\n        queryMethod = Handsontable.Search.global.getDefaultQueryMethod();\n      }\n\n      for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n        for (var colIndex = 0; colIndex < colCount; colIndex++) {\n          var cellData = instance.getDataAtCell(rowIndex, colIndex);\n          var cellProperties = instance.getCellMeta(rowIndex, colIndex);\n          var cellCallback = cellProperties.search.callback || callback;\n          var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;\n          var testResult = cellQueryMethod(queryStr, cellData);\n\n          if (testResult) {\n            var singleResult = {\n              row: rowIndex,\n              col: colIndex,\n              data: cellData\n            };\n\n            queryResult.push(singleResult);\n          }\n\n          if (cellCallback) {\n            cellCallback(instance, rowIndex, colIndex, cellData, testResult);\n          }\n        }\n      }\n\n      return queryResult;\n\n    };\n\n  };\n\n  Handsontable.Search.DEFAULT_CALLBACK = function (instance, row, col, data, testResult) {\n    instance.getCellMeta(row, col).isSearchResult = testResult;\n  };\n\n  Handsontable.Search.DEFAULT_QUERY_METHOD = function (query, value) {\n\n    if (typeof query == 'undefined' || query == null || !query.toLowerCase || query.length == 0){\n      return false;\n    }\n\n    if(typeof value == 'undefined' || value == null) {\n      return false;\n    }\n\n    return value.toString().toLowerCase().indexOf(query.toLowerCase()) != -1;\n  };\n\n  Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS = 'htSearchResult';\n\n  Handsontable.Search.global = (function () {\n\n    var defaultCallback = Handsontable.Search.DEFAULT_CALLBACK;\n    var defaultQueryMethod = Handsontable.Search.DEFAULT_QUERY_METHOD;\n    var defaultSearchResultClass = Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS;\n\n    return {\n      getDefaultCallback: function () {\n        return defaultCallback;\n      },\n\n      setDefaultCallback: function (newDefaultCallback) {\n        defaultCallback = newDefaultCallback;\n      },\n\n      getDefaultQueryMethod: function () {\n        return defaultQueryMethod;\n      },\n\n      setDefaultQueryMethod: function (newDefaultQueryMethod) {\n        defaultQueryMethod = newDefaultQueryMethod;\n      },\n\n      getDefaultSearchResultClass: function () {\n        return defaultSearchResultClass;\n      },\n\n      setDefaultSearchResultClass: function (newSearchResultClass) {\n        defaultSearchResultClass = newSearchResultClass;\n      }\n    }\n\n  })();\n\n\n\n  Handsontable.SearchCellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {\n\n    var searchResultClass = (typeof cellProperties.search == 'object' && cellProperties.search.searchResultClass) || Handsontable.Search.global.getDefaultSearchResultClass();\n\n    if(cellProperties.isSearchResult){\n      Handsontable.Dom.addClass(TD, searchResultClass);\n    } else {\n      Handsontable.Dom.removeClass(TD, searchResultClass);\n    }\n  };\n\n\n\n  var originalDecorator = Handsontable.renderers.cellDecorator;\n\n  Handsontable.renderers.cellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {\n    originalDecorator.apply(this, arguments);\n    Handsontable.SearchCellDecorator.apply(this, arguments);\n  };\n\n  function init() {\n    var instance = this;\n\n    var pluginEnabled = !!instance.getSettings().search;\n\n    if (pluginEnabled) {\n      instance.search = new Handsontable.Search(instance);\n    } else {\n      delete instance.search;\n    }\n\n  }\n\n  Handsontable.hooks.add('afterInit', init);\n  Handsontable.hooks.add('afterUpdateSettings', init);\n\n\n})(Handsontable);\nfunction CellInfoCollection() {\n\n  var collection = [];\n\n  collection.getInfo = function (row, col) {\n    for (var i = 0, ilen = this.length; i < ilen; i++) {\n      if (this[i].row <= row && this[i].row + this[i].rowspan - 1 >= row && this[i].col <= col && this[i].col + this[i].colspan - 1 >= col) {\n        return this[i];\n      }\n    }\n  };\n\n  collection.setInfo = function (info) {\n    for (var i = 0, ilen = this.length; i < ilen; i++) {\n      if (this[i].row === info.row && this[i].col === info.col) {\n        this[i] = info;\n        return;\n      }\n    }\n    this.push(info);\n  };\n\n  collection.removeInfo = function (row, col) {\n    for (var i = 0, ilen = this.length; i < ilen; i++) {\n      if (this[i].row === row && this[i].col === col) {\n        this.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  return collection;\n\n}\n\n\n/**\n * Plugin used to merge cells in Handsontable\n * @constructor\n */\nfunction MergeCells(mergeCellsSetting) {\n  this.mergedCellInfoCollection = new CellInfoCollection();\n\n  if (Array.isArray(mergeCellsSetting)) {\n    for (var i = 0, ilen = mergeCellsSetting.length; i < ilen; i++) {\n      this.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);\n    }\n  }\n}\n\n/**\n * @param cellRange (WalkontableCellRange)\n */\nMergeCells.prototype.canMergeRange = function (cellRange) {\n  //is more than one cell selected\n  return !cellRange.isSingle();\n};\n\nMergeCells.prototype.mergeRange = function (cellRange) {\n  if (!this.canMergeRange(cellRange)) {\n    return;\n  }\n\n  //normalize top left corner\n  var topLeft = cellRange.getTopLeftCorner();\n  var bottomRight = cellRange.getBottomRightCorner();\n\n  var mergeParent = {};\n  mergeParent.row = topLeft.row;\n  mergeParent.col = topLeft.col;\n  mergeParent.rowspan = bottomRight.row - topLeft.row + 1; //TD has rowspan == 1 by default. rowspan == 2 means spread over 2 cells\n  mergeParent.colspan = bottomRight.col - topLeft.col + 1;\n  this.mergedCellInfoCollection.setInfo(mergeParent);\n};\n\nMergeCells.prototype.mergeOrUnmergeSelection = function (cellRange) {\n  var info = this.mergedCellInfoCollection.getInfo(cellRange.from.row, cellRange.from.col);\n  if (info) {\n    //unmerge\n    this.unmergeSelection(cellRange.from);\n  }\n  else {\n    //merge\n    this.mergeSelection(cellRange);\n  }\n};\n\nMergeCells.prototype.mergeSelection = function (cellRange) {\n  this.mergeRange(cellRange);\n};\n\nMergeCells.prototype.unmergeSelection = function (cellRange) {\n  var info = this.mergedCellInfoCollection.getInfo(cellRange.row, cellRange.col);\n  this.mergedCellInfoCollection.removeInfo(info.row, info.col);\n};\n\nMergeCells.prototype.applySpanProperties = function (TD, row, col) {\n  var info = this.mergedCellInfoCollection.getInfo(row, col);\n\n  if (info) {\n    if (info.row === row && info.col === col) {\n      TD.setAttribute('rowspan', info.rowspan);\n      TD.setAttribute('colspan', info.colspan);\n    }\n    else {\n      TD.removeAttribute('rowspan');\n      TD.removeAttribute('colspan');\n\n      TD.style.display = \"none\";\n    }\n  }\n  else {\n    TD.removeAttribute('rowspan');\n    TD.removeAttribute('colspan');\n  }\n};\n\nMergeCells.prototype.modifyTransform = function (hook, currentSelectedRange, delta) {\n  var sameRowspan = function (merged, coords) {\n      if (coords.row >= merged.row && coords.row <= (merged.row + merged.rowspan - 1)) {\n        return true;\n      }\n      return false;\n    }\n    , sameColspan = function (merged, coords) {\n      if (coords.col >= merged.col && coords.col <= (merged.col + merged.colspan - 1)) {\n        return true;\n      }\n      return false;\n    }\n    , getNextPosition = function (newDelta) {\n      return new WalkontableCellCoords(currentSelectedRange.to.row + newDelta.row, currentSelectedRange.to.col + newDelta.col);\n    };\n\n  var newDelta = {\n    row: delta.row,\n    col: delta.col\n  };\n\n\n  if (hook == 'modifyTransformStart') {\n\n    if (!this.lastDesiredCoords) {\n      this.lastDesiredCoords = new WalkontableCellCoords(null, null);\n    }\n    var currentPosition = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col)\n      , mergedParent = this.mergedCellInfoCollection.getInfo(currentPosition.row, currentPosition.col)// if current position's parent is a merged range, returns it\n      , currentRangeContainsMerge; // if current range contains a merged range\n\n    for (var i = 0, mergesLength = this.mergedCellInfoCollection.length; i < mergesLength; i++) {\n      var range = this.mergedCellInfoCollection[i];\n      range = new WalkontableCellCoords(range.row + range.rowspan - 1, range.col + range.colspan - 1);\n      if (currentSelectedRange.includes(range)) {\n        currentRangeContainsMerge = true;\n        break;\n      }\n    }\n\n    if (mergedParent) { // only merge selected\n      var mergeTopLeft = new WalkontableCellCoords(mergedParent.row, mergedParent.col)\n        , mergeBottomRight = new WalkontableCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1)\n        , mergeRange = new WalkontableCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n\n      if (!mergeRange.includes(this.lastDesiredCoords)) {\n        this.lastDesiredCoords = new WalkontableCellCoords(null, null); // reset outdated version of lastDesiredCoords\n      }\n\n      newDelta.row = this.lastDesiredCoords.row ? this.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n      newDelta.col = this.lastDesiredCoords.col ? this.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n\n      if (delta.row > 0) { // moving down\n        newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n      } else if (delta.row < 0) { //moving up\n        newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n      }\n      if (delta.col > 0) { // moving right\n        newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n      } else if (delta.col < 0) { // moving left\n        newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n      }\n    }\n\n    var nextPosition = new WalkontableCellCoords(currentSelectedRange.highlight.row + newDelta.row, currentSelectedRange.highlight.col + newDelta.col)\n      , nextParentIsMerged = this.mergedCellInfoCollection.getInfo(nextPosition.row, nextPosition.col);\n\n    if (nextParentIsMerged) { // skipping the invisible cells in the merge range\n      this.lastDesiredCoords = nextPosition;\n      newDelta = {\n        row: nextParentIsMerged.row - currentPosition.row,\n        col: nextParentIsMerged.col - currentPosition.col\n      }\n    }\n  } else if (hook == 'modifyTransformEnd') {\n    for (var i = 0, mergesLength = this.mergedCellInfoCollection.length; i < mergesLength; i++) {\n      var currentMerge = this.mergedCellInfoCollection[i]\n        , mergeTopLeft = new WalkontableCellCoords(currentMerge.row, currentMerge.col)\n        , mergeBottomRight = new WalkontableCellCoords(currentMerge.row + currentMerge.rowspan - 1, currentMerge.col + currentMerge.colspan - 1)\n        , mergedRange = new WalkontableCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight)\n        , sharedBorders = currentSelectedRange.getBordersSharedWith(mergedRange);\n\n      if (mergedRange.isEqual(currentSelectedRange)) { // only the merged range is selected\n        currentSelectedRange.setDirection(\"NW-SE\");\n      }\n      else if (sharedBorders.length > 0) {\n        var mergeHighlighted = (currentSelectedRange.highlight.isEqual(mergedRange.from));\n\n        if (sharedBorders.indexOf('top') > -1) { // if range shares a border with the merged section, change range direction accordingly\n          if (currentSelectedRange.to.isSouthEastOf(mergedRange.from) && mergeHighlighted) {\n            currentSelectedRange.setDirection(\"NW-SE\");\n          } else if (currentSelectedRange.to.isSouthWestOf(mergedRange.from) && mergeHighlighted) {\n            currentSelectedRange.setDirection(\"NE-SW\");\n          }\n        } else if (sharedBorders.indexOf('bottom') > -1) {\n          if (currentSelectedRange.to.isNorthEastOf(mergedRange.from) && mergeHighlighted) {\n            currentSelectedRange.setDirection(\"SW-NE\");\n          } else if (currentSelectedRange.to.isNorthWestOf(mergedRange.from) && mergeHighlighted) {\n            currentSelectedRange.setDirection(\"SE-NW\");\n          }\n        }\n      }\n\n      var nextPosition = getNextPosition(newDelta)\n        , withinRowspan = sameRowspan(currentMerge, nextPosition)\n        , withinColspan = sameColspan(currentMerge, nextPosition);\n\n      if (currentSelectedRange.includesRange(mergedRange) && (mergedRange.includes(nextPosition) || withinRowspan || withinColspan)) { // if next step overlaps a merged range, jump past it\n        if (withinRowspan) {\n          if (newDelta.row < 0) {\n            newDelta.row -= currentMerge.rowspan - 1;\n          } else if (newDelta.row > 0) {\n            newDelta.row += currentMerge.rowspan - 1;\n          }\n        }\n        if (withinColspan) {\n          if (newDelta.col < 0) {\n            newDelta.col -= currentMerge.colspan - 1;\n          } else if (newDelta.col > 0) {\n            newDelta.col += currentMerge.colspan - 1;\n          }\n        }\n      }\n    }\n  }\n\n  if (newDelta.row != 0) delta.row = newDelta.row;\n  if (newDelta.col != 0) delta.col = newDelta.col;\n};\n\nif (typeof Handsontable == 'undefined') {\n  throw new Error('Handsontable is not defined');\n}\n\nvar beforeInit = function () {\n  var instance = this;\n  var mergeCellsSetting = instance.getSettings().mergeCells;\n\n  if (mergeCellsSetting) {\n    if (!instance.mergeCells) {\n      instance.mergeCells = new MergeCells(mergeCellsSetting);\n    }\n  }\n};\n\nvar afterInit = function () {\n  var instance = this;\n  if (instance.mergeCells) {\n    /**\n     * Monkey patch WalkontableTable.prototype.getCell to return TD for merged cell parent if asked for TD of a cell that is\n     * invisible due to the merge. This is not the cleanest solution but there is a test case for it (merged cells scroll) so feel free to refactor it!\n     */\n    instance.view.wt.wtTable.getCell = function (coords) {\n      if (instance.getSettings().mergeCells) {\n        var mergeParent = instance.mergeCells.mergedCellInfoCollection.getInfo(coords.row, coords.col);\n        if (mergeParent) {\n          coords = mergeParent;\n        }\n      }\n      return WalkontableTable.prototype.getCell.call(this, coords);\n    };\n  }\n};\n\nvar onBeforeKeyDown = function (event) {\n  if (!this.mergeCells) {\n    return;\n  }\n\n  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n  if (ctrlDown) {\n    if (event.keyCode === 77) { //CTRL + M\n      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());\n      this.render();\n      event.stopImmediatePropagation();\n    }\n  }\n};\n\nvar addMergeActionsToContextMenu = function (defaultOptions) {\n  if (!this.getSettings().mergeCells) {\n    return;\n  }\n\n  defaultOptions.items.push(Handsontable.ContextMenu.SEPARATOR);\n\n  defaultOptions.items.push({\n    key: 'mergeCells',\n    name: function () {\n      var sel = this.getSelected();\n      var info = this.mergeCells.mergedCellInfoCollection.getInfo(sel[0], sel[1]);\n      if (info) {\n        return 'Unmerge cells';\n      }\n      else {\n        return 'Merge cells';\n      }\n    },\n    callback: function () {\n      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());\n      this.render();\n    },\n    disabled: function () {\n      return false;\n    }\n  });\n};\n\nvar afterRenderer = function (TD, row, col, prop, value, cellProperties) {\n  if (this.mergeCells) {\n    this.mergeCells.applySpanProperties(TD, row, col);\n  }\n};\n\nvar modifyTransformFactory = function (hook) {\n  return function (delta) {\n    var mergeCellsSetting = this.getSettings().mergeCells;\n    if (mergeCellsSetting) {\n      var currentSelectedRange = this.getSelectedRange();\n      this.mergeCells.modifyTransform(hook, currentSelectedRange, delta);\n\n      if (hook === \"modifyTransformEnd\") {\n        //sanitize \"from\" (core.js will sanitize to)\n        var totalRows = this.countRows();\n        var totalCols = this.countCols();\n        if (currentSelectedRange.from.row < 0) {\n          currentSelectedRange.from.row = 0;\n        }\n        else if (currentSelectedRange.from.row > 0 && currentSelectedRange.from.row >= totalRows) {\n          currentSelectedRange.from.row = currentSelectedRange.from - 1;\n        }\n\n        if (currentSelectedRange.from.col < 0) {\n          currentSelectedRange.from.col = 0;\n        }\n        else if (currentSelectedRange.from.col > 0 && currentSelectedRange.from.col >= totalCols) {\n          currentSelectedRange.from.col = totalCols - 1;\n        }\n      }\n    }\n  }\n};\n\n/**\n * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell\n * @param coords\n */\nvar beforeSetRangeEnd = function (coords) {\n\n  this.lastDesiredCoords = null; //unset lastDesiredCoords when selection is changed with mouse\n  var mergeCellsSetting = this.getSettings().mergeCells;\n  if (mergeCellsSetting) {\n    var selRange = this.getSelectedRange();\n    selRange.highlight = new WalkontableCellCoords(selRange.highlight.row, selRange.highlight.col); //clone in case we will modify its reference\n    selRange.to = coords;\n\n    var rangeExpanded = false;\n    do {\n      rangeExpanded = false;\n\n      for (var i = 0, ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {\n        var cellInfo = this.mergeCells.mergedCellInfoCollection[i];\n        var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);\n        var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);\n\n        var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n        if (selRange.expandByRange(mergedCellRange)) {\n          coords.row = selRange.to.row;\n          coords.col = selRange.to.col;\n\n          rangeExpanded = true;\n        }\n      }\n    } while (rangeExpanded);\n\n  }\n};\n\n/**\n * Returns correct coordinates for merged start / end cells in selection for area borders\n * @param corners\n * @param className\n */\nvar beforeDrawAreaBorders = function (corners, className) {\n  if (className && className == 'area') {\n    var mergeCellsSetting = this.getSettings().mergeCells;\n    if (mergeCellsSetting) {\n      var selRange = this.getSelectedRange();\n      var startRange = new WalkontableCellRange(selRange.from, selRange.from, selRange.from);\n      var stopRange = new WalkontableCellRange(selRange.to, selRange.to, selRange.to);\n\n      for (var i = 0, ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {\n        var cellInfo = this.mergeCells.mergedCellInfoCollection[i];\n        var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);\n        var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);\n        var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n\n        if (startRange.expandByRange(mergedCellRange)) {\n          corners[0] = startRange.from.row;\n          corners[1] = startRange.from.col;\n        }\n\n        if (stopRange.expandByRange(mergedCellRange)) {\n          corners[2] = stopRange.from.row;\n          corners[3] = stopRange.from.col;\n        }\n      }\n    }\n  }\n};\n\nvar afterGetCellMeta = function (row, col, cellProperties) {\n  var mergeCellsSetting = this.getSettings().mergeCells;\n  if (mergeCellsSetting) {\n    var mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(row, col);\n    if (mergeParent && (mergeParent.row != row || mergeParent.col != col)) {\n      cellProperties.copyable = false;\n    }\n  }\n};\n\nvar afterViewportRowCalculatorOverride = function (calc) {\n  var mergeCellsSetting = this.getSettings().mergeCells;\n  if (mergeCellsSetting) {\n    var colCount = this.countCols();\n    var mergeParent;\n    for (var c = 0; c < colCount; c++) {\n      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(calc.startRow, c);\n      if (mergeParent) {\n        if (mergeParent.row < calc.startRow) {\n          calc.startRow = mergeParent.row;\n          return afterViewportRowCalculatorOverride.call(this, calc); //recursively search upwards\n        }\n      }\n      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(calc.endRow, c);\n      if (mergeParent) {\n        var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;\n        if (mergeEnd > calc.endRow) {\n          calc.endRow = mergeEnd;\n          return afterViewportRowCalculatorOverride.call(this, calc); //recursively search upwards\n        }\n      }\n    }\n  }\n};\n\nvar afterViewportColumnCalculatorOverride = function (calc) {\n  var mergeCellsSetting = this.getSettings().mergeCells;\n  if (mergeCellsSetting) {\n    var rowCount = this.countRows();\n    var mergeParent;\n    for (var r = 0; r < rowCount; r++) {\n      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(r, calc.startColumn);\n\n      if (mergeParent) {\n        if (mergeParent.col < calc.startColumn) {\n          calc.startColumn = mergeParent.col;\n          return afterViewportColumnCalculatorOverride.call(this, calc); //recursively search upwards\n        }\n      }\n      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(r, calc.endColumn);\n      if (mergeParent) {\n        var mergeEnd = mergeParent.col + mergeParent.colspan - 1;\n        if (mergeEnd > calc.endColumn) {\n          calc.endColumn = mergeEnd;\n          return afterViewportColumnCalculatorOverride.call(this, calc); //recursively search upwards\n        }\n      }\n    }\n  }\n};\n\nvar isMultipleSelection = function (isMultiple) {\n  if (isMultiple && this.mergeCells) {\n    var mergedCells = this.mergeCells.mergedCellInfoCollection\n      , selectionRange = this.getSelectedRange();\n\n    for (var group in mergedCells) {\n      if (selectionRange.highlight.row == mergedCells[group].row && selectionRange.highlight.col == mergedCells[group].col\n        && selectionRange.to.row == mergedCells[group].row + mergedCells[group].rowspan - 1\n        && selectionRange.to.col == mergedCells[group].col + mergedCells[group].colspan - 1) {\n        return false;\n      }\n    }\n  }\n  return isMultiple;\n};\n\nHandsontable.hooks.add('beforeInit', beforeInit);\nHandsontable.hooks.add('afterInit', afterInit);\nHandsontable.hooks.add('beforeKeyDown', onBeforeKeyDown);\nHandsontable.hooks.add('modifyTransformStart', modifyTransformFactory('modifyTransformStart'));\nHandsontable.hooks.add('modifyTransformEnd', modifyTransformFactory('modifyTransformEnd'));\nHandsontable.hooks.add('beforeSetRangeEnd', beforeSetRangeEnd);\nHandsontable.hooks.add('beforeDrawBorders', beforeDrawAreaBorders);\nHandsontable.hooks.add('afterIsMultipleSelection', isMultipleSelection);\nHandsontable.hooks.add('afterRenderer', afterRenderer);\nHandsontable.hooks.add('afterContextMenuDefaultOptions', addMergeActionsToContextMenu);\nHandsontable.hooks.add('afterGetCellMeta', afterGetCellMeta);\nHandsontable.hooks.add('afterViewportRowCalculatorOverride', afterViewportRowCalculatorOverride);\nHandsontable.hooks.add('afterViewportColumnCalculatorOverride', afterViewportColumnCalculatorOverride);\n\nHandsontable.MergeCells = MergeCells;\n\n\n(function () {\n\n  function CustomBorders () {\n\n  }\n\n//  /***\n//   * Array for all custom border objects (for redraw)\n//   * @type {{}}\n//   */\n//  var bordersArray = {},\n        /***\n     * Current instance (table where borders should be placed)\n     */\n  var instance;\n\n\n  /***\n   * Check if plugin should be enabled\n   */\n  var checkEnable = function (customBorders) {\n    if(typeof customBorders === \"boolean\"){\n      if (customBorders == true){\n        return true;\n      }\n    }\n\n    if(typeof customBorders === \"object\"){\n      if(customBorders.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n\n  /***\n   * Initialize plugin\n    */\n  var init = function () {\n\n    if(checkEnable(this.getSettings().customBorders)){\n      if(!this.customBorders){\n        instance = this;\n        this.customBorders = new CustomBorders();\n      }\n    }\n  };\n\n  /***\n   * get index of border setting\n   * @param className\n   * @returns {number}\n   */\n  var getSettingIndex = function (className) {\n    for (var i = 0; i < instance.view.wt.selections.length; i++){\n      if (instance.view.wt.selections[i].settings.className == className){\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /***\n   * Insert WalkontableSelection instance into Walkontable.settings\n   * @param border\n   */\n  var insertBorderIntoSettings = function (border) {\n    var coordinates = {\n      row: border.row,\n      col: border.col\n    };\n    var selection = new WalkontableSelection(border, new WalkontableCellRange(coordinates, coordinates, coordinates));\n    var index = getSettingIndex(border.className);\n\n    if(index >=0) {\n      instance.view.wt.selections[index] = selection;\n    } else {\n      instance.view.wt.selections.push(selection);\n    }\n  };\n\n  /***\n   * Prepare borders from setting (single cell)\n   *\n   * @param row\n   * @param col\n   * @param borderObj\n   */\n  var prepareBorderFromCustomAdded = function (row, col, borderObj){\n    var border = createEmptyBorders(row, col);\n    border = extendDefaultBorder(border, borderObj);\n    this.setCellMeta(row, col, 'borders', border);\n\n    insertBorderIntoSettings(border);\n  };\n\n  /***\n   * Prepare borders from setting (object)\n   * @param rowObj\n   */\n  var prepareBorderFromCustomAddedRange = function (rowObj) {\n    var range = rowObj.range;\n\n    for (var row = range.from.row; row <= range.to.row; row ++) {\n      for (var col = range.from.col; col<= range.to.col; col++){\n\n        var border = createEmptyBorders(row, col);\n        var add = 0;\n\n        if(row == range.from.row) {\n          add++;\n          if(rowObj.hasOwnProperty('top')){\n            border.top = rowObj.top;\n          }\n        }\n\n        if(row == range.to.row){\n          add++;\n          if(rowObj.hasOwnProperty('bottom')){\n            border.bottom = rowObj.bottom;\n          }\n        }\n\n        if(col == range.from.col) {\n          add++;\n          if(rowObj.hasOwnProperty('left')){\n            border.left = rowObj.left;\n          }\n        }\n\n\n        if (col == range.to.col) {\n          add++;\n          if(rowObj.hasOwnProperty('right')){\n            border.right = rowObj.right;\n          }\n        }\n\n\n        if(add>0){\n          this.setCellMeta(row, col, 'borders', border);\n          insertBorderIntoSettings(border);\n        }\n      }\n    }\n  };\n\n  /***\n   * Create separated class name for borders for each cell\n   * @param row\n   * @param col\n   * @returns {string}\n   */\n  var createClassName = function (row, col) {\n    return \"border_row\" + row + \"col\" + col;\n  };\n\n\n  /***\n   * Create default single border for each position (top/right/bottom/left)\n   * @returns {{width: number, color: string}}\n   */\n  var createDefaultCustomBorder = function () {\n    return {\n      width: 1,\n      color: '#000'\n    };\n  };\n\n\n  /***\n   * Create default object for empty border\n   * @returns {{hide: boolean}}\n   */\n  var createSingleEmptyBorder = function () {\n    return {\n      hide: true\n    }\n  };\n\n\n  /***\n   * Create default Handsontable border object\n   * @returns {{width: number, color: string, cornerVisible: boolean}}\n   */\n  var createDefaultHtBorder = function () {\n    return {\n      width: 1,\n      color: '#000',\n      cornerVisible: false\n    }\n  };\n\n  /***\n   * Prepare empty border for each cell with all custom borders hidden\n   *\n   * @param row\n   * @param col\n   * @returns {{className: *, border: *, row: *, col: *, top: {hide: boolean}, right: {hide: boolean}, bottom: {hide: boolean}, left: {hide: boolean}}}\n   */\n  var createEmptyBorders = function (row, col){\n    return {\n      className: createClassName(row, col),\n      border: createDefaultHtBorder(),\n      row: row,\n      col: col,\n      top: createSingleEmptyBorder(),\n      right: createSingleEmptyBorder(),\n      bottom: createSingleEmptyBorder(),\n      left: createSingleEmptyBorder()\n    }\n  };\n\n\n  var extendDefaultBorder = function (defaultBorder, customBorder){\n\n    if(customBorder.hasOwnProperty('border')){\n      defaultBorder.border = customBorder.border;\n    }\n\n    if(customBorder.hasOwnProperty('top')){\n      defaultBorder.top = customBorder.top;\n    }\n\n    if(customBorder.hasOwnProperty('right')){\n      defaultBorder.right = customBorder.right;\n    }\n\n    if(customBorder.hasOwnProperty('bottom')){\n      defaultBorder.bottom = customBorder.bottom;\n    }\n\n    if(customBorder.hasOwnProperty('left')){\n      defaultBorder.left = customBorder.left;\n    }\n    return defaultBorder;\n  };\n\n  /***\n   * Remove borders divs from DOM\n   *\n   * @param borderClassName\n   */\n  var removeBordersFromDom = function (borderClassName) {\n    var borders = document.querySelectorAll(\".\" + borderClassName);\n\n    for(var i = 0; i< borders.length; i++) {\n      if (borders[i]) {\n        if(borders[i].nodeName != 'TD') {\n          var parent = borders[i].parentNode;\n          if(parent.parentNode) {\n            parent.parentNode.removeChild(parent);\n          }\n        }\n      }\n    }\n  };\n\n\n  /***\n   * Remove border (triggered from context menu)\n   *\n   * @param row\n   * @param col\n   */\n  var removeAllBorders = function(row,col) {\n    var borderClassName = createClassName(row,col);\n    removeBordersFromDom(borderClassName);\n    this.removeCellMeta(row, col, 'borders');\n  };\n\n  /***\n   * Set borders for each cell re. to border position\n   *\n   * @param row\n   * @param col\n   * @param place\n   * @param remove\n   */\n  var setBorder = function (row, col,place, remove){\n\n    var bordersMeta = this.getCellMeta(row, col).borders;\n    if (!bordersMeta || bordersMeta.border == undefined){\n      bordersMeta = createEmptyBorders(row, col);\n    }\n\n    if (remove) {\n      bordersMeta[place] = createSingleEmptyBorder();\n    } else {\n      bordersMeta[place] = createDefaultCustomBorder();\n    }\n\n    this.setCellMeta(row, col, 'borders', bordersMeta);\n\n    var borderClassName = createClassName(row,col);\n    removeBordersFromDom(borderClassName);\n    insertBorderIntoSettings(bordersMeta);\n\n    this.render();\n  };\n\n\n  /***\n   * Prepare borders based on cell and border position\n   *\n   * @param range\n   * @param place\n   * @param remove\n   */\n  var prepareBorder = function (range, place, remove) {\n\n    if (range.from.row == range.to.row && range.from.col == range.to.col){\n      if(place == \"noBorders\"){\n        removeAllBorders.call(this, range.from.row, range.from.col);\n      } else {\n        setBorder.call(this, range.from.row, range.from.col, place, remove);\n      }\n    } else {\n      switch (place) {\n        case \"noBorders\":\n          for(var column = range.from.col; column <= range.to.col; column++){\n            for(var row = range.from.row; row <= range.to.row; row++) {\n              removeAllBorders.call(this, row, column);\n            }\n          }\n          break;\n        case \"top\":\n          for(var topCol = range.from.col; topCol <= range.to.col; topCol++){\n            setBorder.call(this, range.from.row, topCol, place, remove);\n          }\n          break;\n        case \"right\":\n          for(var rowRight = range.from.row; rowRight <=range.to.row; rowRight++){\n            setBorder.call(this,rowRight, range.to.col, place);\n          }\n          break;\n        case \"bottom\":\n          for(var bottomCol = range.from.col; bottomCol <= range.to.col; bottomCol++){\n            setBorder.call(this, range.to.row, bottomCol, place);\n          }\n          break;\n        case \"left\":\n          for(var rowLeft = range.from.row; rowLeft <=range.to.row; rowLeft++){\n            setBorder.call(this,rowLeft, range.from.col, place);\n          }\n          break;\n      }\n    }\n  };\n\n  /***\n   * Check if selection has border by className\n   *\n   * @param hot\n   * @param direction\n   */\n  var checkSelectionBorders = function (hot, direction) {\n    var atLeastOneHasBorder = false;\n\n    hot.getSelectedRange().forAll(function(r, c) {\n      var metaBorders = hot.getCellMeta(r,c).borders;\n\n      if (metaBorders) {\n        if(direction) {\n          if (!metaBorders[direction].hasOwnProperty('hide')){\n            atLeastOneHasBorder = true;\n            return false; //breaks forAll\n          }\n        } else {\n          atLeastOneHasBorder = true;\n          return false; //breaks forAll\n        }\n      }\n    });\n    return atLeastOneHasBorder;\n  };\n\n\n  /***\n   * Mark label in contextMenu as selected\n   *\n   * @param label\n   * @returns {string}\n   */\n  var markSelected = function (label) {\n    return \"<span class='selected'>\" + String.fromCharCode(10003) + \"</span>\" + label; // workaround for https://github.com/handsontable/handsontable/issues/1946\n  };\n\n  /***\n   * Add border options to context menu\n   *\n   * @param defaultOptions\n   */\n  var addBordersOptionsToContextMenu = function (defaultOptions) {\n    if(!this.getSettings().customBorders){\n      return;\n    }\n\n    defaultOptions.items.push(Handsontable.ContextMenu.SEPARATOR);\n\n    defaultOptions.items.push({\n      key: 'borders',\n      name: 'Borders',\n      submenu: {\n        items: {\n          top: {\n            name: function () {\n              var label = \"Top\";\n              var hasBorder = checkSelectionBorders(this, 'top');\n              if(hasBorder) {\n                label = markSelected(label);\n              }\n\n              return label;\n            },\n            callback: function () {\n              var hasBorder = checkSelectionBorders(this, 'top');\n              prepareBorder.call(this, this.getSelectedRange(), 'top', hasBorder);\n            },\n            disabled: false\n          },\n          right: {\n            name: function () {\n              var label = 'Right';\n              var hasBorder = checkSelectionBorders(this, 'right');\n              if(hasBorder) {\n                label = markSelected(label);\n              }\n              return label;\n            },\n            callback: function () {\n              var hasBorder = checkSelectionBorders(this, 'right');\n              prepareBorder.call(this, this.getSelectedRange(), 'right', hasBorder);\n            },\n            disabled: false\n          },\n          bottom: {\n            name: function () {\n              var label = 'Bottom';\n              var hasBorder = checkSelectionBorders(this, 'bottom');\n              if(hasBorder) {\n                label = markSelected(label);\n              }\n              return label;\n            },\n            callback: function () {\n              var hasBorder = checkSelectionBorders(this, 'bottom');\n              prepareBorder.call(this, this.getSelectedRange(), 'bottom', hasBorder);\n            },\n            disabled: false\n          },\n          left: {\n            name: function () {\n              var label = 'Left';\n              var hasBorder = checkSelectionBorders(this, 'left');\n              if(hasBorder) {\n                label = markSelected(label);\n              }\n\n              return label\n            },\n            callback: function () {\n              var hasBorder = checkSelectionBorders(this, 'left');\n              prepareBorder.call(this, this.getSelectedRange(), 'left', hasBorder);\n            },\n            disabled: false\n          },\n          remove: {\n            name: 'Remove border(s)',\n            callback: function () {\n              prepareBorder.call(this, this.getSelectedRange(), 'noBorders');\n            },\n            disabled: function () {\n              return !checkSelectionBorders(this);\n            }\n          }\n        }\n      }\n    });\n  };\n\n  Handsontable.hooks.add('beforeInit', init);\n  Handsontable.hooks.add('afterContextMenuDefaultOptions', addBordersOptionsToContextMenu);\n\n\n  Handsontable.hooks.add('afterInit', function () {\n    var customBorders = this.getSettings().customBorders;\n\n    if (customBorders){\n\n      for(var i = 0; i< customBorders.length; i++) {\n        if(customBorders[i].range){\n          prepareBorderFromCustomAddedRange.call(this,customBorders[i]);\n        } else {\n          prepareBorderFromCustomAdded.call(this,customBorders[i].row, customBorders[i].col, customBorders[i]);\n        }\n      }\n\n      this.render();\n      this.view.wt.draw(true);\n    }\n\n  });\n\n  Handsontable.CustomBorders = CustomBorders;\n\n}());\n\n/**\n * HandsontableManualRowMove\n *\n * Has 2 UI components:\n * - handle - the draggable element that sets the desired position of the row\n * - guide - the helper guide that shows the desired position as a horizontal guide\n *\n * Warning! Whenever you make a change in this file, make an analogous change in manualRowMove.js\n * @constructor\n */\n(function (Handsontable) {\n  function HandsontableManualRowMove() {\n\n    var startRow,\n        endRow,\n        startY,\n        startOffset,\n        currentRow,\n        currentTH,\n        handle = document.createElement('DIV'),\n        guide = document.createElement('DIV'),\n        eventManager = Handsontable.eventManager(this);\n\n    handle.className = 'manualRowMover';\n    guide.className = 'manualRowMoverGuide';\n\n    var saveManualRowPositions = function () {\n      var instance = this;\n      Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowPositions', instance.manualRowPositions);\n    };\n\n    var loadManualRowPositions = function () {\n      var instance = this,\n          storedState = {};\n      Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowPositions', storedState);\n      return storedState.value;\n    };\n\n    function setupHandlePosition(TH) {\n      instance = this;\n      currentTH = TH;\n\n      var row = this.view.wt.wtTable.getCoords(TH).row; //getCoords returns WalkontableCellCoords\n      if (row >= 0) { //if not row header\n        currentRow = row;\n        var box = currentTH.getBoundingClientRect();\n        startOffset = box.top;\n        handle.style.top = startOffset + 'px';\n        handle.style.left = box.left + 'px';\n        instance.rootElement.appendChild(handle);\n      }\n    }\n\n    function refreshHandlePosition(TH, delta) {\n      var box = TH.getBoundingClientRect();\n      var handleHeight = 6;\n      if (delta > 0) {\n        handle.style.top = (box.top + box.height - handleHeight) + 'px';\n      }\n      else {\n        handle.style.top = box.top + 'px';\n      }\n    }\n\n    function setupGuidePosition() {\n      var instance = this;\n      Handsontable.Dom.addClass(handle, 'active');\n      Handsontable.Dom.addClass(guide, 'active');\n      var box = currentTH.getBoundingClientRect();\n      guide.style.width = instance.view.maximumVisibleElementWidth(0) + 'px';\n      guide.style.height = box.height + 'px';\n      guide.style.top = startOffset + 'px';\n      guide.style.left = handle.style.left;\n      instance.rootElement.appendChild(guide);\n    }\n\n    function refreshGuidePosition(diff) {\n      guide.style.top = startOffset + diff + 'px';\n    }\n\n    function hideHandleAndGuide() {\n      Handsontable.Dom.removeClass(handle, 'active');\n      Handsontable.Dom.removeClass(guide, 'active');\n    }\n\n    var checkRowHeader = function (element) {\n      if (element.tagName != 'BODY') {\n        if (element.parentNode.tagName == 'TBODY') {\n          return true;\n        } else {\n          element = element.parentNode;\n          return checkRowHeader(element);\n        }\n      }\n      return false;\n    };\n\n    var getTHFromTargetElement = function (element) {\n      if (element.tagName != 'TABLE') {\n        if (element.tagName == 'TH') {\n          return element;\n        } else {\n          return getTHFromTargetElement(element.parentNode);\n        }\n      }\n      return null;\n    };\n\n    var bindEvents = function () {\n      var instance = this;\n      var pressed;\n\n\n      eventManager.addEventListener(instance.rootElement,'mouseover', function (e){\n        if(checkRowHeader(e.target)){\n          var th = getTHFromTargetElement(e.target)\n          if (th) {\n            if (pressed) {\n              endRow = instance.view.wt.wtTable.getCoords(th).row;\n              refreshHandlePosition(th, endRow - startRow);\n            }\n            else {\n              setupHandlePosition.call(instance, th);\n            }\n          }\n        }\n      });\n\n      eventManager.addEventListener(instance.rootElement,'mousedown', function (e) {\n        if (Handsontable.Dom.hasClass(e.target, 'manualRowMover')) {\n          startY = Handsontable.helper.pageY(e);\n          setupGuidePosition.call(instance);\n          pressed = instance;\n\n          startRow = currentRow;\n          endRow = currentRow;\n        }\n      });\n\n      eventManager.addEventListener(window,'mousemove',function (e) {\n        if (pressed) {\n          refreshGuidePosition(Handsontable.helper.pageY(e) - startY);\n        }\n      });\n\n      eventManager.addEventListener(window,'mouseup',function (e) {\n        if (pressed) {\n          hideHandleAndGuide();\n          pressed = false;\n\n          createPositionData(instance.manualRowPositions, instance.countRows());\n          instance.manualRowPositions.splice(endRow, 0, instance.manualRowPositions.splice(startRow, 1)[0]);\n\n          instance.forceFullRender = true;\n          instance.view.render(); //updates all\n\n          saveManualRowPositions.call(instance);\n\n          Handsontable.hooks.run(instance, 'afterRowMove', startRow, endRow);\n\n          setupHandlePosition.call(instance, currentTH);\n        }\n      });\n\n      instance.addHook('afterDestroy', unbindEvents);\n    };\n\n    var unbindEvents = function () {\n      eventManager.clear();\n    };\n\n    var createPositionData = function (positionArr, len) {\n      if (positionArr.length < len) {\n        for (var i = positionArr.length; i < len; i++) {\n          positionArr[i] = i;\n        }\n      }\n    };\n\n    this.beforeInit = function () {\n      this.manualRowPositions = [];\n    };\n\n    this.init = function (source) {\n      var instance = this;\n\n      var manualRowMoveEnabled = !!(instance.getSettings().manualRowMove);\n\n      if (manualRowMoveEnabled) {\n        var initialManualRowPositions = instance.getSettings().manualRowMove;\n\n        var loadedManualRowPostions = loadManualRowPositions.call(instance);\n\n        if (typeof loadedManualRowPostions != 'undefined') {\n          this.manualRowPositions = loadedManualRowPostions;\n        } else if(Array.isArray(initialManualRowPositions)) {\n          this.manualRowPositions = initialManualRowPositions;\n        } else {\n          this.manualRowPositions = [];\n        }\n\n        if (source === 'afterInit') {\n          bindEvents.call(this);\n          if (this.manualRowPositions.length > 0) {\n            instance.forceFullRender = true;\n            instance.render();\n          }\n        }\n      } else {\n        unbindEvents.call(this);\n        instance.manualRowPositions = [];\n      }\n\n    };\n\n    this.modifyRow = function (row) {\n      var instance = this;\n      if (instance.getSettings().manualRowMove) {\n        if (typeof instance.manualRowPositions[row] === 'undefined') {\n          createPositionData(this.manualRowPositions, row + 1);\n        }\n        return instance.manualRowPositions[row];\n      }\n\n      return row;\n    };\n  }\n\n  var htManualRowMove = new HandsontableManualRowMove();\n\n  Handsontable.hooks.add('beforeInit', htManualRowMove.beforeInit);\n  Handsontable.hooks.add('afterInit',  function () {\n    htManualRowMove.init.call(this, 'afterInit');\n  });\n\n  Handsontable.hooks.add('afterUpdateSettings', function () {\n    htManualRowMove.init.call(this, 'afterUpdateSettings');\n  });\n\n  Handsontable.hooks.add('modifyRow', htManualRowMove.modifyRow);\n  Handsontable.hooks.register('afterRowMove');\n\n})(Handsontable);\n\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated\n * using the small square in the right bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring\n * cells when you drag the small square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells\n * below when you double click the small square.\n */\n(function (Handsontable) {\n  'use strict';\n\n  function Autofill(instance) {\n    this.instance = instance;\n    this.addingStarted = false;\n\n    var  wtOnCellCornerMouseDown,\n      wtOnCellMouseOver,\n      mouseDownOnCellCorner = false,\n      plugin = this,\n      eventManager = Handsontable.eventManager(instance);\n\n\n    var mouseUpCallback = function (event) {\n      if (!instance.autofill) {\n        return true;\n      }\n\n      if (instance.autofill.handle && instance.autofill.handle.isDragged) {\n        if (instance.autofill.handle.isDragged > 1) {\n          instance.autofill.apply();\n        }\n        instance.autofill.handle.isDragged = 0;\n        mouseDownOnCellCorner = false;\n      }\n    };\n\n    eventManager.addEventListener(document, 'mouseup', function (event) {\n      mouseUpCallback(event);\n    });\n\n    eventManager.addEventListener(document,'mousemove', function (event){\n      if (!plugin.instance.autofill) {\n        return 0;\n      }\n\n      var tableBottom = Handsontable.Dom.offset(plugin.instance.table).top - (window.pageYOffset || document.documentElement.scrollTop) + Handsontable.Dom.outerHeight(plugin.instance.table)\n        , tableRight = Handsontable.Dom.offset(plugin.instance.table).left - (window.pageXOffset || document.documentElement.scrollLeft) + Handsontable.Dom.outerWidth(plugin.instance.table);\n\n\n      if (plugin.addingStarted === false && plugin.instance.autofill.handle.isDragged > 0 && event.clientY > tableBottom && event.clientX <= tableRight) { // dragged outside bottom\n        this.mouseDragOutside = true;\n        plugin.addingStarted = true;\n      } else {\n        this.mouseDragOutside = false;\n      }\n\n      if (this.mouseDragOutside) {\n        setTimeout(function () {\n          plugin.addingStarted = false;\n          plugin.instance.alter('insert_row');\n        }, 200);\n      }\n    });\n\n    /*\n     * Appeding autofill-specific methods to walkontable event settings\n     */\n    wtOnCellCornerMouseDown = this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown;\n    this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown = function (event) {\n      instance.autofill.handle.isDragged = 1;\n      mouseDownOnCellCorner = true;\n\n      wtOnCellCornerMouseDown(event);\n    };\n\n    wtOnCellMouseOver = this.instance.view.wt.wtSettings.settings.onCellMouseOver;\n    this.instance.view.wt.wtSettings.settings.onCellMouseOver = function (event, coords, TD, wt) {\n\n      if (instance.autofill && (mouseDownOnCellCorner && !instance.view.isMouseDown() && instance.autofill.handle && instance.autofill.handle.isDragged)) {\n        instance.autofill.handle.isDragged++;\n        instance.autofill.showBorder(coords);\n        instance.autofill.checkIfNewRowNeeded();\n      }\n\n      wtOnCellMouseOver(event, coords, TD, wt);\n    };\n\n    this.instance.view.wt.wtSettings.settings.onCellCornerDblClick = function () {\n      instance.autofill.selectAdjacent();\n    };\n\n  }\n\n  /**\n   * Create fill handle and fill border objects\n   */\n  Autofill.prototype.init = function () {\n    this.handle = {};\n  },\n\n  /**\n   * Hide fill handle and fill border permanently\n   */\n    Autofill.prototype.disable = function () {\n      this.handle.disabled = true;\n    },\n\n  /**\n   * Selects cells down to the last row in the left column, then fills down to that cell\n   */\n    Autofill.prototype.selectAdjacent = function () {\n      var select, data, r, maxR, c;\n\n      if (this.instance.selection.isMultiple()) {\n        select = this.instance.view.wt.selections.area.getCorners();\n      }\n      else {\n        select = this.instance.view.wt.selections.current.getCorners();\n      }\n\n      data = this.instance.getData();\n      rows : for (r = select[2] + 1; r < this.instance.countRows(); r++) {\n        for (c = select[1]; c <= select[3]; c++) {\n          if (data[r][c]) {\n            break rows;\n          }\n        }\n        if (!!data[r][select[1] - 1] || !!data[r][select[3] + 1]) {\n          maxR = r;\n        }\n      }\n      if (maxR) {\n        this.instance.view.wt.selections.fill.clear();\n        this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(select[0], select[1]));\n        this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(maxR, select[3]));\n        this.apply();\n      }\n    },\n\n  /**\n   * Apply fill values to the area in fill border, omitting the selection border\n   */\n    Autofill.prototype.apply = function () {\n      var drag, select, start, end, _data;\n\n      this.handle.isDragged = 0;\n\n      drag = this.instance.view.wt.selections.fill.getCorners();\n      if (!drag) {\n        return;\n      }\n\n      var getDeltas = function (start, end, data, direction) {\n        var rlength = data.length, // rows\n            clength = data ? data[0].length : 0; // cols\n\n        var deltas = [];\n\n        var diffRow = end.row - start.row,\n            diffCol = end.col - start.col;\n\n        var startValue, endValue, delta;\n\n        var arr = [];\n\n        if (['down', 'up'].indexOf(direction) !== -1) {\n          for (var col = 0; col <= diffCol; col++) {\n\n            startValue = parseInt(data[0][col], 10);\n            endValue = parseInt(data[rlength-1][col], 10);\n            delta = (direction === 'down' ? (endValue - startValue) : (startValue - endValue))  / (rlength - 1) || 0;\n\n            arr.push(delta);\n          }\n\n          deltas.push(arr);\n        }\n\n        if (['right', 'left'].indexOf(direction) !== -1) {\n          for (var row = 0; row <= diffRow; row++) {\n\n            startValue = parseInt(data[row][0], 10);\n            endValue = parseInt(data[row][clength-1], 10);\n            delta = (direction === 'right' ? (endValue - startValue) : (startValue - endValue)) / (clength - 1) || 0;\n\n            arr = [];\n            arr.push(delta);\n\n            deltas.push(arr);\n          }\n        }\n\n        return deltas;\n      };\n\n      this.instance.view.wt.selections.fill.clear();\n\n      if (this.instance.selection.isMultiple()) {\n        select = this.instance.view.wt.selections.area.getCorners();\n      }\n      else {\n        select = this.instance.view.wt.selections.current.getCorners();\n      }\n\n      var direction;\n\n      if (drag[0] === select[0] && drag[1] < select[1]) {\n        direction = 'left';\n\n        start = new WalkontableCellCoords(\n          drag[0],\n          drag[1]\n        );\n        end = new WalkontableCellCoords(\n          drag[2],\n            select[1] - 1\n        );\n      }\n      else if (drag[0] === select[0] && drag[3] > select[3]) {\n        direction = 'right';\n\n        start = new WalkontableCellCoords(\n          drag[0],\n          select[3] + 1\n        );\n        end = new WalkontableCellCoords(\n          drag[2],\n          drag[3]\n        );\n      }\n      else if (drag[0] < select[0] && drag[1] === select[1]) {\n        direction = 'up';\n\n        start = new WalkontableCellCoords(\n          drag[0],\n          drag[1]\n        );\n        end = new WalkontableCellCoords(\n          select[0] - 1,\n          drag[3]\n        );\n      }\n      else if (drag[2] > select[2] && drag[1] === select[1]) {\n        direction = 'down';\n\n        start = new WalkontableCellCoords(\n          select[2] + 1,\n          drag[1]\n        );\n        end = new WalkontableCellCoords(\n          drag[2],\n          drag[3]\n        );\n      }\n\n      if (start && start.row > -1 && start.col > -1) {\n        var selRange = {from: this.instance.getSelectedRange().from, to: this.instance.getSelectedRange().to};\n\n        _data = this.instance.getData(selRange.from.row, selRange.from.col, selRange.to.row, selRange.to.col);\n\n        var deltas = getDeltas(start, end, _data, direction);\n\n        Handsontable.hooks.run(this.instance, 'beforeAutofill', start, end, _data);\n\n        this.instance.populateFromArray(start.row, start.col, _data, end.row, end.col, 'autofill', null, direction, deltas);\n\n        this.instance.selection.setRangeStart(new WalkontableCellCoords(drag[0], drag[1]));\n        this.instance.selection.setRangeEnd(new WalkontableCellCoords(drag[2], drag[3]));\n      } else {\n       //reset to avoid some range bug\n       this.instance.selection.refreshBorders();\n     }\n    },\n\n  /**\n   * Show fill border\n   * @param {WalkontableCellCoords} coords\n   */\n    Autofill.prototype.showBorder = function (coords) {\n      var topLeft = this.instance.getSelectedRange().getTopLeftCorner();\n      var bottomRight = this.instance.getSelectedRange().getBottomRightCorner();\n      if (this.instance.getSettings().fillHandle !== 'horizontal' && (bottomRight.row < coords.row || topLeft.row > coords.row)) {\n        coords = new WalkontableCellCoords(coords.row, bottomRight.col);\n      }\n      else if (this.instance.getSettings().fillHandle !== 'vertical') {\n        coords = new WalkontableCellCoords(bottomRight.row, coords.col);\n      }\n      else {\n        return; //wrong direction\n      }\n\n      this.instance.view.wt.selections.fill.clear();\n      this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().from);\n      this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().to);\n      this.instance.view.wt.selections.fill.add(coords);\n      this.instance.view.render();\n    };\n\n  Autofill.prototype.checkIfNewRowNeeded = function () {\n    var fillCorners,\n      selection,\n      tableRows = this.instance.countRows(),\n      that = this;\n\n    if (this.instance.view.wt.selections.fill.cellRange && this.addingStarted === false) {\n      selection = this.instance.getSelected();\n      fillCorners = this.instance.view.wt.selections.fill.getCorners();\n\n      if (selection[2] < tableRows - 1 && fillCorners[2] === tableRows - 1) {\n        this.addingStarted = true;\n\n        this.instance._registerTimeout(setTimeout(function () {\n          that.instance.alter('insert_row');\n          that.addingStarted = false;\n        }, 200));\n      }\n    }\n\n  };\n\n\n  Handsontable.hooks.add('afterInit', function () {\n    var autofill = new Autofill(this);\n\n    if (typeof this.getSettings().fillHandle !== \"undefined\") {\n      if (autofill.handle && this.getSettings().fillHandle === false) {\n        autofill.disable();\n      }\n      else if (!autofill.handle && this.getSettings().fillHandle !== false) {\n        this.autofill = autofill;\n        this.autofill.init();\n      }\n    }\n\n  });\n\n  Handsontable.Autofill = Autofill;\n\n})(Handsontable);\n\nvar Grouping = function (instance) {\n  /**\n   * array of items\n   * @type {Array}\n   */\n  var groups = [];\n\n  /**\n   * group definition\n   * @type {{id: String, level: Number, rows: Array, cols: Array, hidden: Number}}\n   */\n  var item = {\n    id: '',\n    level: 0,\n    hidden: 0,\n    rows: [],\n    cols: []\n  };\n\n  /**\n   * total rows and cols merged in groups\n   * @type {{rows: number, cols: number}}\n   */\n  var counters = {\n    rows: 0,\n    cols: 0\n  };\n\n  /**\n   * Number of group levels in each dimension\n   * @type {{rows: number, cols: number}}\n   */\n  var levels = {\n    rows: 0,\n    cols: 0\n  };\n\n  /**\n   * List of hidden rows\n   * @type {Array}\n   */\n  var hiddenRows = [];\n\n  /**\n   * List of hidden columns\n   * @type {Array}\n   */\n  var hiddenCols = [];\n\n  /**\n   * Classes used\n   */\n  var classes = {\n    'groupIndicatorContainer': 'htGroupIndicatorContainer',\n    'groupIndicator': function (direction) {\n      return 'ht' + direction + 'Group';\n    },\n    'groupStart': 'htGroupStart',\n    'collapseButton': 'htCollapseButton',\n    'expandButton': 'htExpandButton',\n    'collapseGroupId': function (id) {\n      return 'htCollapse-' + id;\n    },\n    'collapseFromLevel': function (direction, level) {\n      return 'htCollapse' + direction + 'FromLevel-' + level;\n    },\n    'clickable': 'clickable',\n    'levelTrigger': 'htGroupLevelTrigger'\n  };\n\n  /**\n   * compare object properties\n   * @param {String} property\n   * @param {String} orderDirection\n   * @returns {Function}\n   */\n  var compare = function (property, orderDirection) {\n    return function (item1, item2) {\n      return typeof (orderDirection) === 'undefined' || orderDirection === 'asc' ? item1[property] - item2[property] : item2[property] - item1[property];\n    }\n  };\n\n  /**\n   * Create range array between from and to\n   * @param {Number} from\n   * @param {Number} to\n   * @returns {Array}\n   */\n  var range = function (from, to) {\n    var arr = [];\n    while (from <= to) {\n      arr.push(from++);\n    }\n\n    return arr;\n  };\n\n  /**\n   * * Get groups for range\n   * @param from\n   * @param to\n   * @returns {{total: {rows: number, cols: number}, groups: Array}}\n   */\n  var getRangeGroups = function (dataType, from, to) {\n    var cells = [],\n      cell = {\n        row: null,\n        col: null\n      };\n\n    if (dataType == \"cols\") {\n      // get all rows for selected columns\n      while (from <= to) {\n        cell = {\n          row: -1,\n          col: from++\n        };\n        cells.push(cell);\n      }\n\n    } else {\n      // get all columns for selected rows\n      while (from <= to) {\n        cell = {\n          row: from++,\n          col: -1\n        };\n        cells.push(cell);\n      }\n    }\n\n    var cellsGroups = getCellsGroups(cells),\n      totalRows = 0,\n      totalCols = 0;\n\n    // for selected cells, calculate total groups divided into rows and columns\n    for (var i = 0; i < cellsGroups.length; i++) {\n      totalRows += cellsGroups[i].filter(function (item) {\n        return item['rows']\n      }).length;\n\n      totalCols += cellsGroups[i].filter(function (item) {\n        return item['cols']\n      }).length;\n    }\n\n    return {\n      total: {\n        rows: totalRows,\n        cols: totalCols\n      },\n      groups: cellsGroups\n    };\n  };\n\n  /**\n   * Get all groups for cells\n   * @param {Array} cells [{row:0, col:0}, {row:0, col:1}, {row:1, col:2}]\n   * @returns {Array}\n   */\n  var getCellsGroups = function (cells) {\n    var _groups = [];\n\n    for (var i = 0; i < cells.length; i++) {\n      _groups.push(getCellGroups(cells[i]));\n    }\n\n    return _groups;\n  };\n\n  /**\n   * Get all groups for cell\n   * @param {Object} coords {row:1, col:2}\n   * @param {Number} groupLevel Optional\n   * @param {String} groupType Optional\n   * @returns {Array}\n   */\n  var getCellGroups = function (coords, groupLevel, groupType) {\n    var row = coords.row,\n      col = coords.col;\n\n    // for row = -1 and col = -1, get all columns and rows\n    var tmpRow = (row === -1 ? 0 : row),\n      tmpCol = (col === -1 ? 0 : col);\n\n    var _groups = [];\n\n    for (var i = 0; i < groups.length; i++) {\n      var group = groups[i],\n        id = group['id'],\n        level = group['level'],\n        rows = group['rows'] || [],\n        cols = group['cols'] || [];\n\n      if (_groups.indexOf(id) === -1) {\n        if (rows.indexOf(tmpRow) !== -1 || cols.indexOf(tmpCol) !== -1) {\n          _groups.push(group);\n        }\n      }\n    }\n\n    // add col groups\n    if (col === -1) {\n      _groups = _groups.concat(getColGroups());\n    } else if (row === -1) {\n      // add row groups\n      _groups = _groups.concat(getRowGroups());\n    }\n\n    if (groupLevel) {\n      _groups = _groups.filter(function (item) {\n        return item['level'] === groupLevel;\n      });\n    }\n\n    if (groupType) {\n      if (groupType === 'cols') {\n        _groups = _groups.filter(function (item) {\n          return item['cols'];\n        });\n      } else if (groupType === 'rows') {\n        _groups = _groups.filter(function (item) {\n          return item['rows'];\n        });\n      }\n    }\n\n    // remove duplicates\n    var tmp = [];\n    return _groups.filter(function (item) {\n      if (tmp.indexOf(item.id) === -1) {\n        tmp.push(item.id);\n        return item;\n      }\n    });\n  };\n\n  /**\n   * get group by id\n   * @param id\n   * @returns {Object} group\n   */\n  var getGroupById = function (id) {\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (groups[i].id == id) return groups[i];\n    }\n    return false;\n  };\n\n  /**\n   * get group by row and level\n   * @param row\n   * @param level\n   * @returns {Object} group\n   */\n  var getGroupByRowAndLevel = function (row, level) {\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (groups[i].level == level && groups[i].rows && groups[i].rows.indexOf(row) > -1) return groups[i];\n    }\n    return false;\n  };\n\n  /**\n   * get group by row and level\n   * @param row\n   * @param level\n   * @returns {Object} group\n   */\n  var getGroupByColAndLevel = function (col, level) {\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (groups[i].level == level && groups[i].cols && groups[i].cols.indexOf(col) > -1) return groups[i];\n    }\n    return false;\n  };\n\n  /**\n   * get total column groups\n   * @returns {*|Array}\n   */\n  var getColGroups = function () {\n    var result = [];\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (Array.isArray(groups[i]['cols'])) result.push(groups[i]);\n    }\n    return result;\n  };\n\n  /**\n   * get total col groups by level\n   * @param {Number} level\n   * @returns {*|Array}\n   */\n  var getColGroupsByLevel = function (level) {\n    var result = [];\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (groups[i]['cols'] && groups[i]['level'] === level) result.push(groups[i]);\n    }\n    return result;\n  };\n\n  /**\n   * get total row groups\n   * @returns {*|Array}\n   */\n  var getRowGroups = function () {\n    var result = [];\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (Array.isArray(groups[i]['rows'])) result.push(groups[i]);\n    }\n    return result;\n  };\n\n  /**\n   * get total row groups by level\n   * @param {Number} level\n   * @returns {*|Array}\n   */\n  var getRowGroupsByLevel = function (level) {\n    var result = [];\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      if (groups[i]['rows'] && groups[i]['level'] === level) result.push(groups[i]);\n    }\n    return result;\n  };\n\n  /**\n   * get last inserted range level in columns\n   * @param {Array} rangeGroups\n   * @returns {number}\n   */\n  var getLastLevelColsInRange = function (rangeGroups) {\n    var level = 0;\n\n    if (rangeGroups.length) {\n      rangeGroups.forEach(function (items) {\n        items = items.filter(function (item) {\n          return item['cols'];\n        });\n\n        if (items.length) {\n          var sortedGroup = items.sort(compare('level', 'desc')),\n            lastLevel = sortedGroup[0].level;\n\n          if (level < lastLevel) {\n            level = lastLevel;\n          }\n        }\n      });\n    }\n\n    return level;\n  };\n\n  /**\n   * get last inserted range level in rows\n   * @param {Array} rangeGroups\n   * @returns {number}\n   */\n  var getLastLevelRowsInRange = function (rangeGroups) {\n    var level = 0;\n\n    if (rangeGroups.length) {\n      rangeGroups.forEach(function (items) {\n        items = items.filter(function (item) {\n          return item['rows'];\n        });\n\n        if (items.length) {\n          var sortedGroup = items.sort(compare('level', 'desc')),\n            lastLevel = sortedGroup[0].level;\n\n          if (level < lastLevel) {\n            level = lastLevel;\n          }\n        }\n      });\n    }\n\n    return level;\n  };\n\n  /**\n   * create group for cols\n   * @param {Number} from\n   * @param {Number} to\n   */\n  var groupCols = function (from, to) {\n    var rangeGroups = getRangeGroups(\"cols\", from, to),\n      lastLevel = getLastLevelColsInRange(rangeGroups.groups);\n\n    if (lastLevel === levels.cols) {\n      levels.cols++;\n    } else if (lastLevel > levels.cols) {\n      levels.cols = lastLevel + 1;\n    }\n\n    if (!counters.cols) {\n      counters.cols = getColGroups().length;\n    }\n\n    counters.cols++;\n    groups.push({\n      id: 'c' + counters.cols,\n      level: lastLevel + 1,\n      cols: range(from, to),\n      hidden: 0\n    });\n  };\n\n  /**\n   * create group for rows\n   * @param {Number} from\n   * @param {Number} to\n   */\n  var groupRows = function (from, to) {\n    var rangeGroups = getRangeGroups(\"rows\", from, to),\n      lastLevel = getLastLevelRowsInRange(rangeGroups.groups);\n\n    levels.rows = Math.max(levels.rows, lastLevel + 1);\n\n\n    if (!counters.rows) {\n      counters.rows = getRowGroups().length;\n    }\n\n    counters.rows++;\n    groups.push({\n      id: 'r' + counters.rows,\n      level: lastLevel + 1,\n      rows: range(from, to),\n      hidden: 0\n    });\n  };\n\n  /**\n   * show or hide groups\n   * @param showHide\n   * @param groups\n   */\n  var showHideGroups = function (hidden, groups) {\n    var level;\n    for (var i = 0, groupsLength = groups.length; i < groupsLength; i++) {\n      groups[i].hidden = hidden;\n      level = groups[i].level;\n\n      if (!hiddenRows[level]) hiddenRows[level] = [];\n      if (!hiddenCols[level]) hiddenCols[level] = [];\n\n      if (groups[i].rows) {\n        for (var j = 0, rowsLength = groups[i].rows.length; j < rowsLength; j++) {\n          if (hidden > 0) {\n            hiddenRows[level][groups[i].rows[j]] = true;\n          } else {\n            hiddenRows[level][groups[i].rows[j]] = void 0;\n          }\n        }\n      } else if (groups[i].cols) {\n        for (var j = 0, colsLength = groups[i].cols.length; j < colsLength; j++) {\n          if (hidden > 0) {\n            hiddenCols[level][groups[i].cols[j]] = true;\n          } else {\n            hiddenCols[level][groups[i].cols[j]] = void 0;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Check if the next cell of the dimension (row / column) contains a group at the same level\n   * @param dimension\n   * @param currentPosition\n   * @param level\n   * @param currentGroupId\n   * @returns {boolean}\n   */\n  var nextIndexSharesLevel = function (dimension, currentPosition, level, currentGroupId) {\n    var nextCellGroupId\n      , levelsByOrder;\n\n    switch (dimension) {\n      case 'rows':\n        nextCellGroupId = getGroupByRowAndLevel(currentPosition + 1, level).id;\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByRows();\n        break;\n      case 'cols':\n        nextCellGroupId = getGroupByColAndLevel(currentPosition + 1, level).id;\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByCols();\n        break;\n    }\n\n    return !!(levelsByOrder[currentPosition + 1] && levelsByOrder[currentPosition + 1].indexOf(level) > -1 && currentGroupId == nextCellGroupId);\n\n  };\n\n  /**\n   * Check if the previous cell of the dimension (row / column) contains a group at the same level\n   * @param dimension\n   * @param currentPosition\n   * @param level\n   * @param currentGroupId\n   * @returns {boolean}\n   */\n  var previousIndexSharesLevel = function (dimension, currentPosition, level, currentGroupId) {\n    var previousCellGroupId\n      , levelsByOrder;\n\n    switch (dimension) {\n      case 'rows':\n        previousCellGroupId = getGroupByRowAndLevel(currentPosition - 1, level).id;\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByRows();\n        break;\n      case 'cols':\n        previousCellGroupId = getGroupByColAndLevel(currentPosition - 1, level).id;\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByCols();\n        break;\n    }\n\n    return !!(levelsByOrder[currentPosition - 1] && levelsByOrder[currentPosition - 1].indexOf(level) > -1 && currentGroupId == previousCellGroupId);\n\n  };\n\n  /**\n   * Check if the provided index is at the end of the group indicator line\n   * @param dimension\n   * @param index\n   * @param level\n   * @param currentGroupId\n   * @returns {boolean}\n   */\n  var isLastIndexOfTheLine = function (dimension, index, level, currentGroupId) {\n    if (index === 0) return false;\n    var levelsByOrder\n      , entriesLength\n      , previousSharesLevel = previousIndexSharesLevel(dimension, index, level, currentGroupId)\n      , nextSharesLevel = nextIndexSharesLevel(dimension, index, level, currentGroupId)\n      , nextIsHidden = false;\n\n    switch (dimension) {\n      case 'rows':\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByRows();\n        entriesLength = instance.countRows();\n        for (var i = 0; i <= levels.rows; i++) {\n          if (hiddenRows[i] && hiddenRows[i][index + 1]) {\n            nextIsHidden = true;\n            break;\n          }\n        }\n        break;\n      case 'cols':\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByCols();\n        entriesLength = instance.countCols();\n        for (var i = 0; i <= levels.cols; i++) {\n          if (hiddenCols[i] && hiddenCols[i][index + 1]) {\n            nextIsHidden = true;\n            break;\n          }\n        }\n        break;\n    }\n\n    if (previousSharesLevel) {\n      if (index == entriesLength - 1) {\n        return true;\n      } else if (!nextSharesLevel || (nextSharesLevel && nextIsHidden)) {\n        return true;\n      } else if (!levelsByOrder[index + 1]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Check if all rows/cols are hidden\n   * @param dataType\n   */\n  var isLastHidden = function (dataType) {\n    var levelAmount;\n\n    switch (dataType) {\n      case 'rows':\n        levelAmount = levels.rows;\n        for (var j = 0; j <= levelAmount; j++) {\n          if (hiddenRows[j] && hiddenRows[j][instance.countRows() - 1]) {\n            return true;\n          }\n        }\n\n        break;\n      case 'cols':\n        levelAmount = levels.cols;\n        for (var j = 0; j <= levelAmount; j++) {\n          if (hiddenCols[j] && hiddenCols[j][instance.countCols() - 1]) {\n            return true;\n          }\n        }\n        break;\n    }\n\n    return false;\n  };\n\n  /**\n   * Check if the provided index is at the beginning of the group indicator line\n   * @param dimension\n   * @param index\n   * @param level\n   * @param currentGroupId\n   * @returns {boolean}\n   */\n  var isFirstIndexOfTheLine = function (dimension, index, level, currentGroupId) {\n    var levelsByOrder\n      , entriesLength\n      , currentGroup = getGroupById(currentGroupId)\n      , previousAreHidden = false\n      , arePreviousHidden = function (dimension) {\n        var hidden = false\n          , hiddenArr = dimension == 'rows' ? hiddenRows : hiddenCols;\n        for (var i = 0; i <= levels[dimension]; i++) {\n          tempInd = index;\n          while (currentGroup[dimension].indexOf(tempInd) > -1) {\n            hidden = !!(hiddenArr[i] && hiddenArr[i][tempInd]);\n            tempInd--;\n          }\n          if (hidden) break;\n        }\n        return hidden;\n      }\n      , previousSharesLevel = previousIndexSharesLevel(dimension, index, level, currentGroupId)\n      , nextSharesLevel = nextIndexSharesLevel(dimension, index, level, currentGroupId)\n      , tempInd;\n\n    switch (dimension) {\n      case 'rows':\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByRows();\n        entriesLength = instance.countRows();\n        previousAreHidden = arePreviousHidden(dimension);\n        break;\n      case 'cols':\n        levelsByOrder = Handsontable.Grouping.getGroupLevelsByCols();\n        entriesLength = instance.countCols();\n        previousAreHidden = arePreviousHidden(dimension);\n        break;\n    }\n\n    if (index == entriesLength - 1) return false;\n    else if (index == 0) {\n      if (nextSharesLevel) {\n        return true;\n      }\n    } else if (!previousSharesLevel || (previousSharesLevel && previousAreHidden)) {\n      if (nextSharesLevel) {\n        return true;\n      }\n    } else if (!levelsByOrder[index - 1]) {\n      if (nextSharesLevel) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add group expander button\n   * @param dimension\n   * @param index\n   * @param level\n   * @param id\n   * @param elem\n   * @returns {*}\n   */\n  var addGroupExpander = function (dataType, index, level, id, elem) {\n    var previousIndexGroupId;\n\n    switch (dataType) {\n      case 'rows':\n        previousIndexGroupId = getGroupByRowAndLevel(index - 1, level).id;\n        break;\n      case 'cols':\n        previousIndexGroupId = getGroupByColAndLevel(index - 1, level).id;\n        break;\n    }\n\n    if (!previousIndexGroupId) return null;\n\n    if (index > 0) {\n      if (previousIndexSharesLevel(dataType, index - 1, level, previousIndexGroupId) && previousIndexGroupId != id) {\n\n        var expanderButton = document.createElement('DIV');\n        Handsontable.Dom.addClass(expanderButton, classes.expandButton);\n        expanderButton.id = 'htExpand-' + previousIndexGroupId;\n        expanderButton.appendChild(document.createTextNode('+'));\n        expanderButton.setAttribute('data-level', level);\n        expanderButton.setAttribute('data-type', dataType);\n        expanderButton.setAttribute('data-hidden', \"1\");\n\n        elem.appendChild(expanderButton);\n\n        return expanderButton;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Check if provided cell is collapsed (either by rows or cols)\n   * @param currentPosition\n   * @returns {boolean}\n   */\n  var isCollapsed = function (currentPosition) {\n    var rowGroups = getRowGroups()\n      , colGroups = getColGroups();\n\n    for (var i = 0, rowGroupsCount = rowGroups.length; i < rowGroupsCount; i++) {\n      if (rowGroups[i].rows.indexOf(currentPosition.row) > -1 && rowGroups[i].hidden) {\n        return true;\n      }\n    }\n\n    if (currentPosition.col === null) { // if col is set to null, check only rows\n      return false;\n    }\n\n    for (var i = 0, colGroupsCount = colGroups.length; i < colGroupsCount; i++) {\n      if (colGroups[i].cols.indexOf(currentPosition.col) > -1 && colGroups[i].hidden) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return {\n\n    /**\n     * all groups for ht instance\n     */\n    getGroups: function () {\n      return groups;\n    },\n    /**\n     * All levels for rows and cols respectively\n     */\n    getLevels: function () {\n      return levels;\n    },\n    /**\n     * Current instance\n     */\n    instance: instance,\n    /**\n     * Initial setting for minSpareRows\n     */\n    baseSpareRows: instance.getSettings().minSpareRows,\n    /**\n     * Initial setting for minSpareCols\n     */\n    baseSpareCols: instance.getSettings().minSpareCols,\n\n    getRowGroups: getRowGroups,\n    getColGroups: getColGroups,\n    /**\n     * init group\n     * @param {Object} settings, could be an array of objects [{cols: [0,1,2]}, {cols: [3,4,5]}, {rows: [0,1]}]\n     */\n    init: function () {\n      var groupsSetting = instance.getSettings().groups;\n      if (groupsSetting) {\n        if (Array.isArray(groupsSetting)) {\n          Handsontable.Grouping.initGroups(groupsSetting);\n        }\n      }\n    },\n\n    /**\n     * init groups from configuration on startup\n     */\n    initGroups: function (initialGroups) {\n      var that = this;\n\n      groups = [];\n\n      initialGroups.forEach(function (item) {\n        var _group = [],\n          isRow = false,\n          isCol = false;\n\n        if (Array.isArray(item.rows)) {\n          _group = item.rows;\n          isRow = true;\n        } else if (Array.isArray(item.cols)) {\n          _group = item.cols;\n          isCol = true;\n        }\n\n        var from = _group[0],\n          to = _group[_group.length - 1];\n\n        if (isRow) {\n          groupRows(from, to);\n        } else if (isCol) {\n          groupCols(from, to);\n        }\n      });\n//      this.render();\n    },\n\n    /**\n     * Remove all existing groups\n     */\n    resetGroups: function () {\n      groups = [];\n      counters = {\n        rows: 0,\n        cols: 0\n      };\n      levels = {\n        rows: 0,\n        cols: 0\n      };\n\n      var allOccurrences;\n      for (var i in classes) {\n        if (typeof classes[i] != 'function') {\n          allOccurrences = document.querySelectorAll('.' + classes[i]);\n          for (var j = 0, occurrencesLength = allOccurrences.length; j < occurrencesLength; j++) {\n            Handsontable.Dom.removeClass(allOccurrences[j], classes[i]);\n          }\n        }\n      }\n\n      var otherClasses = ['htGroupColClosest', 'htGroupCol'];\n      for (var i = 0, otherClassesLength = otherClasses.length; i < otherClassesLength; i++) {\n        allOccurrences = document.querySelectorAll('.' + otherClasses[i]);\n        for (var j = 0, occurrencesLength = allOccurrences.length; j < occurrencesLength; j++) {\n          Handsontable.Dom.removeClass(allOccurrences[j], otherClasses[i]);\n        }\n      }\n    },\n    /**\n     * Update groups from the instance settings\n     */\n    updateGroups: function () {\n      var groupSettings = this.getSettings().groups;\n\n      Handsontable.Grouping.resetGroups();\n      Handsontable.Grouping.initGroups(groupSettings);\n    },\n    afterGetRowHeader: function (row, TH) {\n      var currentRowHidden = false;\n      for (var i = 0, levels = hiddenRows.length; i < levels; i++) {\n        if (hiddenRows[i] && hiddenRows[i][row] === true) {\n          currentRowHidden = true;\n        }\n      }\n\n      if (currentRowHidden) {\n        Handsontable.Dom.addClass(TH.parentNode, 'hidden');\n      } else if (!currentRowHidden && Handsontable.Dom.hasClass(TH.parentNode, 'hidden')) {\n        Handsontable.Dom.removeClass(TH.parentNode, 'hidden');\n      }\n\n    },\n    afterGetColHeader: function (col, TH) {\n      var rowHeaders = this.view.wt.wtSettings.getSetting('rowHeaders').length\n        , thisColgroup = instance.rootElement.querySelectorAll('colgroup col:nth-child(' + parseInt(col + rowHeaders + 1, 10) + ')');\n\n      if (thisColgroup.length === 0) {\n        return;\n      }\n\n      var currentColHidden = false;\n      for (var i = 0, levels = hiddenCols.length; i < levels; i++) {\n        if (hiddenCols[i] && hiddenCols[i][col] === true) {\n          currentColHidden = true;\n        }\n      }\n\n      if (currentColHidden) {\n        for (var i = 0, colsAmount = thisColgroup.length; i < colsAmount; i++) {\n          Handsontable.Dom.addClass(thisColgroup[i], 'hidden');\n        }\n      } else if (!currentColHidden && Handsontable.Dom.hasClass(thisColgroup[0], 'hidden')) {\n        for (var i = 0, colsAmount = thisColgroup.length; i < colsAmount; i++) {\n          Handsontable.Dom.removeClass(thisColgroup[i], 'hidden');\n        }\n      }\n    },\n    /**\n     * Create a renderer for additional row/col headers, acting as group indicators\n     * @param walkontableConfig\n     * @param direction\n     */\n    groupIndicatorsFactory: function (renderersArr, direction) {\n      var groupsLevelsList\n        , getCurrentLevel\n        , getCurrentGroupId\n        , dataType\n        , getGroupByIndexAndLevel\n        , headersType\n        , currentHeaderModifier\n        , createLevelTriggers;\n\n      switch (direction) {\n        case 'horizontal':\n          groupsLevelsList = Handsontable.Grouping.getGroupLevelsByCols();\n          getCurrentLevel = function (elem) {\n            return Array.prototype.indexOf.call(elem.parentNode.parentNode.childNodes, elem.parentNode) + 1;\n          };\n          getCurrentGroupId = function (col, level) {\n            return getGroupByColAndLevel(col, level).id;\n          };\n          dataType = 'cols';\n          getGroupByIndexAndLevel = function (col, level) {\n            return getGroupByColAndLevel(col - 1, level);\n          };\n          headersType = \"columnHeaders\";\n          currentHeaderModifier = function (headerRenderers) {\n            if (headerRenderers.length === 1) {\n              var oldFn = headerRenderers[0];\n\n              headerRenderers[0] = function (index, elem, level) {\n\n                if (index < -1)\n                  makeGroupIndicatorsForLevel()(index, elem, level);\n                else {\n                  Handsontable.Dom.removeClass(elem, classes.groupIndicatorContainer);\n                  oldFn(index, elem, level);\n                }\n              }\n            }\n            return function () {\n              return headerRenderers;\n            };\n          };\n          createLevelTriggers = true;\n          break;\n        case 'vertical':\n          groupsLevelsList = Handsontable.Grouping.getGroupLevelsByRows();\n          getCurrentLevel = function (elem) {\n            return Handsontable.Dom.index(elem) + 1;\n          };\n          getCurrentGroupId = function (row, level) {\n            return getGroupByRowAndLevel(row, level).id;\n          };\n          dataType = 'rows';\n          getGroupByIndexAndLevel = function (row, level) {\n            return getGroupByRowAndLevel(row - 1, level);\n          };\n          headersType = \"rowHeaders\";\n          currentHeaderModifier = function (headerRenderers) {\n            return headerRenderers;\n          };\n          break;\n      }\n\n      var createButton = function (parent) {\n        var button = document.createElement('div');\n\n        parent.appendChild(button);\n\n        return {\n          button: button,\n          addClass: function (className) {\n            Handsontable.Dom.addClass(button, className);\n          }\n        };\n      };\n\n      var makeGroupIndicatorsForLevel = function () {\n        var directionClassname = direction.charAt(0).toUpperCase() + direction.slice(1); // capitalize the first letter\n\n        return function (index, elem, level) { // header rendering function\n\n          level++;\n          var child\n            , collapseButton;\n\n          while (child = elem.lastChild) {\n            elem.removeChild(child);\n          }\n\n          Handsontable.Dom.addClass(elem, classes.groupIndicatorContainer);\n\n          var currentGroupId = getCurrentGroupId(index, level);\n\n          if (index > -1 && (groupsLevelsList[index] && groupsLevelsList[index].indexOf(level) > -1)) {\n\n            collapseButton = createButton(elem);\n            collapseButton.addClass(classes.groupIndicator(directionClassname));\n\n            if (isFirstIndexOfTheLine(dataType, index, level, currentGroupId)) { // add a little thingy and the top of the group indicator\n              collapseButton.addClass(classes.groupStart);\n            }\n\n            if (isLastIndexOfTheLine(dataType, index, level, currentGroupId)) { // add [+]/[-] button at the end of the line\n              collapseButton.button.appendChild(document.createTextNode('-'));\n              collapseButton.addClass(classes.collapseButton);\n              collapseButton.button.id = classes.collapseGroupId(currentGroupId);\n              collapseButton.button.setAttribute('data-level', level);\n              collapseButton.button.setAttribute('data-type', dataType);\n            }\n\n          }\n\n          if (createLevelTriggers) {\n            var rowInd = Handsontable.Dom.index(elem.parentNode);\n            if (index === -1 || (index < -1 && rowInd === Handsontable.Grouping.getLevels().cols + 1) || (rowInd == 0 && Handsontable.Grouping.getLevels().cols == 0)) {\n              collapseButton = createButton(elem);\n              collapseButton.addClass(classes.levelTrigger);\n\n              if (index === -1) {\n                collapseButton.button.id = classes.collapseFromLevel(\"Cols\", level);\n                collapseButton.button.appendChild(document.createTextNode(level));\n              } else if (index < -1 && rowInd === Handsontable.Grouping.getLevels().cols + 1 || (rowInd == 0 && Handsontable.Grouping.getLevels().cols == 0)) {\n                var colInd = Handsontable.Dom.index(elem) + 1;\n                collapseButton.button.id = classes.collapseFromLevel(\"Rows\", colInd);\n                collapseButton.button.appendChild(document.createTextNode(colInd));\n              }\n            }\n          }\n\n          // add group expending button\n          var expanderButton = addGroupExpander(dataType, index, level, currentGroupId, elem);\n          if (index > 0) {\n            var previousGroupObj = getGroupByIndexAndLevel(index - 1, level);\n\n            if (expanderButton && previousGroupObj.hidden) {\n              Handsontable.Dom.addClass(expanderButton, classes.clickable);\n            }\n          }\n\n          updateHeaderWidths();\n\n        };\n      };\n\n\n      renderersArr = currentHeaderModifier(renderersArr);\n\n\n      if (counters[dataType] > 0) {\n        for (var i = 0; i < levels[dataType] + 1; i++) { // for each level of col groups add a header renderer\n          if (!Array.isArray(renderersArr)) {\n            renderersArr = typeof renderersArr === 'function' ? renderersArr() : new Array(renderersArr);\n          }\n          renderersArr.unshift(makeGroupIndicatorsForLevel());\n        }\n      }\n    },\n    /**\n     * Get group levels array arranged by rows\n     * @returns {Array}\n     */\n    getGroupLevelsByRows: function () {\n      var rowGroups = getRowGroups()\n        , result = [];\n\n      for (var i = 0, groupsLength = rowGroups.length; i < groupsLength; i++) {\n        if (rowGroups[i].rows) {\n          for (var j = 0, groupRowsLength = rowGroups[i].rows.length; j < groupRowsLength; j++) {\n            if (!result[rowGroups[i].rows[j]]) result[rowGroups[i].rows[j]] = [];\n            result[rowGroups[i].rows[j]].push(rowGroups[i].level);\n          }\n        }\n      }\n      return result;\n    },\n    /**\n     * Get group levels array arranged by cols\n     * @returns {Array}\n     */\n    getGroupLevelsByCols: function () {\n      var colGroups = getColGroups()\n        , result = [];\n\n      for (var i = 0, groupsLength = colGroups.length; i < groupsLength; i++) {\n        if (colGroups[i].cols) {\n          for (var j = 0, groupColsLength = colGroups[i].cols.length; j < groupColsLength; j++) {\n            if (!result[colGroups[i].cols[j]]) result[colGroups[i].cols[j]] = [];\n            result[colGroups[i].cols[j]].push(colGroups[i].level);\n          }\n        }\n      }\n      return result;\n    },\n    /**\n     * Toggle the group visibility ( + / - event handler)\n     * @param event\n     * @param coords\n     * @param TD\n     */\n    toggleGroupVisibility: function (event, coords, TD) {\n      if (Handsontable.Dom.hasClass(event.target, classes.expandButton)\n        || Handsontable.Dom.hasClass(event.target, classes.collapseButton)\n        || Handsontable.Dom.hasClass(event.target, classes.levelTrigger)) {\n        var element = event.target\n          , elemIdSplit = element.id.split('-');\n\n        var groups = []\n          , id\n          , level\n          , type\n          , hidden;\n\n        var prepareGroupData = function (componentElement) {\n          if (componentElement) element = componentElement;\n\n          elemIdSplit = element.id.split('-');\n\n          id = elemIdSplit[1];\n          level = parseInt(element.getAttribute('data-level'), 10);\n          type = element.getAttribute('data-type');\n          hidden = parseInt(element.getAttribute('data-hidden'));\n\n          if (isNaN(hidden)) {\n            hidden = 1;\n          } else {\n            hidden = (hidden ? 0 : 1);\n          }\n\n          element.setAttribute('data-hidden', hidden.toString());\n\n\n          groups.push(getGroupById(id));\n        };\n\n        if (element.className.indexOf(classes.levelTrigger) > -1) { // show levels below, hide all above\n          var groupsInLevel\n            , groupsToExpand = []\n            , groupsToCollapse = []\n            , levelType = element.id.indexOf(\"Rows\") > -1 ? \"rows\" : \"cols\";\n\n          for (var i = 1, levelsCount = levels[levelType]; i <= levelsCount; i++) {\n            groupsInLevel = levelType == \"rows\" ? getRowGroupsByLevel(i) : getColGroupsByLevel(i);\n\n            if (i >= parseInt(elemIdSplit[1], 10)) {\n              for (var j = 0, groupCount = groupsInLevel.length; j < groupCount; j++) {\n                groupsToCollapse.push(groupsInLevel[j]);\n              }\n            } else {\n              for (var j = 0, groupCount = groupsInLevel.length; j < groupCount; j++) {\n                groupsToExpand.push(groupsInLevel[j]);\n              }\n            }\n          }\n\n          showHideGroups(true, groupsToCollapse);\n          showHideGroups(false, groupsToExpand);\n\n        } else {\n          prepareGroupData();\n          showHideGroups(hidden, groups);\n        }\n\n\n        // add the expander button to a dummy spare row/col, if no longer needed -> remove it\n        type = type || levelType;\n        var lastHidden = isLastHidden(type)\n          , typeUppercase = type.charAt(0).toUpperCase() + type.slice(1)\n          , spareElements = Handsontable.Grouping['baseSpare' + typeUppercase];\n\n        if (lastHidden) {\n          if (spareElements == 0) {\n            instance.alter('insert_' + type.slice(0, -1), instance['count' + typeUppercase]());\n            Handsontable.Grouping[\"dummy\" + type.slice(0, -1)] = true;\n          }\n        } else {\n          if (spareElements == 0) {\n            if (Handsontable.Grouping[\"dummy\" + type.slice(0, -1)]) {\n              instance.alter('remove_' + type.slice(0, -1), instance['count' + typeUppercase]() - 1);\n              Handsontable.Grouping[\"dummy\" + type.slice(0, -1)] = false;\n            }\n          }\n        }\n\n        instance.render();\n\n        event.stopImmediatePropagation();\n      }\n    },\n    /**\n     * Modify the delta when changing cells using keyobard\n     * @param position\n     * @returns {Function}\n     */\n    modifySelectionFactory: function (position) {\n      var instance = this.instance;\n      var currentlySelected\n        , nextPosition = new WalkontableCellCoords(0, 0)\n        , nextVisible = function (direction, currentPosition) { // updates delta to skip to the next visible cell\n          var updateDelta = 0;\n\n          switch (direction) {\n            case 'down':\n              while (isCollapsed(currentPosition)) {\n                updateDelta++;\n                currentPosition.row += 1;\n              }\n              break;\n            case 'up':\n              while (isCollapsed(currentPosition)) {\n                updateDelta--;\n                currentPosition.row -= 1;\n              }\n              break;\n            case 'right':\n              while (isCollapsed(currentPosition)) {\n                updateDelta++;\n                currentPosition.col += 1;\n              }\n              break;\n            case 'left':\n              while (isCollapsed(currentPosition)) {\n                updateDelta--;\n                currentPosition.col -= 1;\n              }\n              break;\n          }\n\n          return updateDelta;\n        }\n        , updateDelta = function (delta, nextPosition) {\n          if (delta.row > 0) { // moving down\n            if (isCollapsed(nextPosition)) {\n              delta.row += nextVisible('down', nextPosition);\n            }\n          } else if (delta.row < 0) { // moving up\n            if (isCollapsed(nextPosition)) {\n              delta.row += nextVisible('up', nextPosition);\n            }\n          }\n\n          if (delta.col > 0) { // moving right\n            if (isCollapsed(nextPosition)) {\n              delta.col += nextVisible('right', nextPosition);\n            }\n          } else if (delta.col < 0) { // moving left\n            if (isCollapsed(nextPosition)) {\n              delta.col += nextVisible('left', nextPosition);\n            }\n          }\n        };\n\n      switch (position) {\n        case 'start':\n          return function (delta) {\n            currentlySelected = instance.getSelected();\n            nextPosition.row = currentlySelected[0] + delta.row;\n            nextPosition.col = currentlySelected[1] + delta.col;\n\n            updateDelta(delta, nextPosition);\n          };\n          break;\n        case 'end':\n          return function (delta) {\n            currentlySelected = instance.getSelected();\n            nextPosition.row = currentlySelected[2] + delta.row;\n            nextPosition.col = currentlySelected[3] + delta.col;\n\n            updateDelta(delta, nextPosition);\n          };\n          break;\n      }\n    },\n    modifyRowHeight: function (height, row) {\n      if (instance.view.wt.wtTable.rowFilter && isCollapsed({row: row, col: null})) {\n        return 0;\n      }\n    },\n    validateGroups: function () {\n\n      var areRangesOverlapping = function (a, b) {\n        if ((a[0] < b[0] && a[1] < b[1] && b[0] <= a[1])\n          || (a[0] > b[0] && b[1] < a[1] && a[0] <= b[1])) {\n          return true;\n        }\n      };\n\n      var configGroups = instance.getSettings().groups\n        , cols = []\n        , rows = [];\n\n      for (var i = 0, groupsLength = configGroups.length; i < groupsLength; i++) {\n        if (configGroups[i].rows) {\n\n          if(configGroups[i].rows.length === 1) { // single-entry group\n            throw new Error(\"Grouping error:  Group {\" + configGroups[i].rows[0] + \"} is invalid. Cannot define single-entry groups.\");\n            return false;\n          } else if(configGroups[i].rows.length === 0) {\n            throw new Error(\"Grouping error:  Cannot define empty groups.\");\n            return false;\n          }\n\n          rows.push(configGroups[i].rows);\n\n          for (var j = 0, rowsLength = rows.length; j < rowsLength; j++) {\n            if (areRangesOverlapping(configGroups[i].rows, rows[j])) {\n\n              throw new Error(\"Grouping error:  ranges {\" + configGroups[i].rows[0] + \", \" + configGroups[i].rows[1] + \"} and {\" + rows[j][0] + \", \" + rows[j][1] + \"} are overlapping.\");\n              return false;\n            }\n          }\n        } else if (configGroups[i].cols) {\n\n          if(configGroups[i].cols.length === 1) { // single-entry group\n            throw new Error(\"Grouping error:  Group {\" + configGroups[i].cols[0] + \"} is invalid. Cannot define single-entry groups.\");\n            return false;\n          } else if(configGroups[i].cols.length === 0) {\n            throw new Error(\"Grouping error:  Cannot define empty groups.\");\n            return false;\n          }\n\n          cols.push(configGroups[i].cols);\n\n          for (var j = 0, colsLength = cols.length; j < colsLength; j++) {\n            if (areRangesOverlapping(configGroups[i].cols, cols[j])) {\n\n              throw new Error(\"Grouping error:  ranges {\" + configGroups[i].cols[0] + \", \" + configGroups[i].cols[1] + \"} and {\" + cols[j][0] + \", \" + cols[j][1] + \"} are overlapping.\");\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    },\n    afterGetRowHeaderRenderers: function (arr) {\n      Handsontable.Grouping.groupIndicatorsFactory(arr, 'vertical');\n    },\n    afterGetColumnHeaderRenderers: function (arr) {\n      Handsontable.Grouping.groupIndicatorsFactory(arr, 'horizontal');\n    },\n    hookProxy: function (fn, arg) {\n      return function () {\n        if (instance.getSettings().groups) {\n          return arg ? Handsontable.Grouping[fn](arg).apply(this, arguments) : Handsontable.Grouping[fn].apply(this, arguments);\n        } else {\n          return void 0;\n        }\n      };\n    }\n  }\n};\n\n/**\n * create new instance\n */\nvar init = function () {\n  var instance = this,\n    groupingSetting = !!(instance.getSettings().groups);\n\n\n  if (groupingSetting) {\n    var headerUpdates = {};\n\n    Handsontable.Grouping = new Grouping(instance);\n\n    if (!instance.getSettings().rowHeaders) { // force using rowHeaders  --  needs to be changed later\n      headerUpdates.rowHeaders = true;\n    }\n    if (!instance.getSettings().colHeaders) { // force using colHeaders  --  needs to be changed later\n      headerUpdates.colHeaders = true;\n    }\n    if (headerUpdates.colHeaders || headerUpdates.rowHeaders) {\n      instance.updateSettings(headerUpdates);\n    }\n\n    var groupConfigValid = Handsontable.Grouping.validateGroups();\n    if (!groupConfigValid) {\n      return;\n    }\n\n    instance.addHook('beforeInit', Handsontable.Grouping.hookProxy('init'));\n    instance.addHook('afterUpdateSettings', Handsontable.Grouping.hookProxy('updateGroups'));\n    instance.addHook('afterGetColumnHeaderRenderers', Handsontable.Grouping.hookProxy('afterGetColumnHeaderRenderers'));\n    instance.addHook('afterGetRowHeaderRenderers', Handsontable.Grouping.hookProxy('afterGetRowHeaderRenderers'));\n    instance.addHook('afterGetRowHeader', Handsontable.Grouping.hookProxy('afterGetRowHeader'));\n    instance.addHook('afterGetColHeader', Handsontable.Grouping.hookProxy('afterGetColHeader'));\n    instance.addHook('beforeOnCellMouseDown', Handsontable.Grouping.hookProxy('toggleGroupVisibility'));\n    instance.addHook('modifyTransformStart', Handsontable.Grouping.hookProxy('modifySelectionFactory', 'start'));\n    instance.addHook('modifyTransformEnd', Handsontable.Grouping.hookProxy('modifySelectionFactory', 'end'));\n    instance.addHook('modifyRowHeight', Handsontable.Grouping.hookProxy('modifyRowHeight'));\n  }\n};\n\n/**\n * Update headers widths for the group indicators\n */\n// TODO: this needs cleaning up\nvar updateHeaderWidths = function () {\n  var colgroups = document.querySelectorAll('colgroup');\n  for (var i = 0, colgroupsLength = colgroups.length; i < colgroupsLength; i++) {\n    var rowHeaders = colgroups[i].querySelectorAll('col.rowHeader');\n    if (rowHeaders.length == 0) {\n      return;\n    }\n    for (var j = 0, rowHeadersLength = rowHeaders.length + 1; j < rowHeadersLength; j++) {\n      if (rowHeadersLength == 2) {\n        return;\n      }\n      if (j < Handsontable.Grouping.getLevels().rows + 1) {\n        if (j == Handsontable.Grouping.getLevels().rows) {\n          Handsontable.Dom.addClass(rowHeaders[j], 'htGroupColClosest');\n        } else {\n          Handsontable.Dom.addClass(rowHeaders[j], 'htGroupCol');\n        }\n      }\n    }\n  }\n};\n\nHandsontable.hooks.add('beforeInit', init);\n\nHandsontable.hooks.add('afterUpdateSettings', function () {\n\n  if (this.getSettings().groups && !Handsontable.Grouping) {\n    init.call(this, arguments);\n  } else if (!this.getSettings().groups && Handsontable.Grouping) {\n    Handsontable.Grouping.resetGroups();\n    Handsontable.Grouping = void 0;\n  }\n});\n\nHandsontable.plugins.Grouping = Grouping;\n\n(function (Handsontable) {\n  /**\n   * Plugin used to allow user to copy and paste from the context menu\n   * Currently uses ZeroClipboard due to browser limitations\n   * @constructor\n   */\n  function ContextMenuCopyPaste() {\n    this.zeroClipboardInstance = null;\n    this.instance = null;\n  }\n\n  /**\n   * Configure ZeroClipboard\n   */\n  ContextMenuCopyPaste.prototype.prepareZeroClipboard = function () {\n    if(this.swfPath) {\n      ZeroClipboard.config({\n        swfPath: this.swfPath\n      });\n    }\n  };\n\n  /**\n   * Copy action\n   * @returns {CopyPasteClass.elTextarea.value|*}\n   */\n  ContextMenuCopyPaste.prototype.copy = function () {\n    this.instance.copyPaste.setCopyableText();\n    return this.instance.copyPaste.copyPasteInstance.elTextarea.value;\n  };\n\n  /**\n   * Adds copy/paste items to context menu\n   */\n  ContextMenuCopyPaste.prototype.addToContextMenu = function (defaultOptions) {\n    if (!this.getSettings().contextMenuCopyPaste) {\n      return;\n    }\n\n    defaultOptions.items.unshift(\n      {\n        key: 'copy',\n        name: 'Copy'\n      },\n      {\n        key: 'paste',\n        name: 'Paste',\n        callback: function () {\n          this.copyPaste.triggerPaste();\n        }\n      },\n      Handsontable.ContextMenu.SEPARATOR\n    );\n  };\n\n  /**\n   * Setup ZeroClipboard swf clip position and event handlers\n   * @param cmInstance Current context menu instance\n   */\n  ContextMenuCopyPaste.prototype.setupZeroClipboard = function (cmInstance) {\n    var plugin = this;\n    this.cmInstance = cmInstance;\n\n    if (!Handsontable.Dom.hasClass(this.cmInstance.rootElement, 'htContextMenu')) {\n      return;\n    }\n\n    var data = cmInstance.getData();\n    for (var i = 0, ilen = data.length; i < ilen; i++) { //find position of 'copy' option\n      if (data[i].key === 'copy') {\n        this.zeroClipboardInstance = new ZeroClipboard(cmInstance.getCell(i, 0));\n\n        this.zeroClipboardInstance.off();\n        this.zeroClipboardInstance.on(\"copy\", function (event) {\n          var clipboard = event.clipboardData;\n          clipboard.setData(\"text/plain\", plugin.copy());\n          plugin.instance.getSettings().outsideClickDeselects = plugin.outsideClickDeselectsCache;\n        });\n\n        cmCopyPaste.bindEvents();\n        break;\n      }\n    }\n  };\n\n  /**\n   * Bind all the standard events\n   */\n  ContextMenuCopyPaste.prototype.bindEvents = function () {\n    var plugin = this;\n\n    // Workaround for 'current' and 'zeroclipboard-is-hover' classes being stuck when moving the cursor over the context menu\n    if (plugin.cmInstance) {\n\n      var eventManager = new Handsontable.eventManager(this.instance);\n\n      var removeCurrenClass = function (event) {\n        var hadClass = plugin.cmInstance.rootElement.querySelector('td.current');\n        if (hadClass) {\n          Handsontable.Dom.removeClass(hadClass, 'current');\n        }\n        plugin.outsideClickDeselectsCache = plugin.instance.getSettings().outsideClickDeselects;\n        plugin.instance.getSettings().outsideClickDeselects = false;\n      };\n\n      var removeZeroClipboardClass = function (event) {\n        var hadClass = plugin.cmInstance.rootElement.querySelector('td.zeroclipboard-is-hover');\n        if (hadClass) {\n          Handsontable.Dom.removeClass(hadClass, 'zeroclipboard-is-hover');\n        }\n        plugin.instance.getSettings().outsideClickDeselects = plugin.outsideClickDeselectsCache;\n      };\n\n      eventManager.removeEventListener(document,'mouseenter', function () {\n        removeCurrenClass();\n      });\n      eventManager.addEventListener(document, 'mouseenter', function (e) {\n        removeCurrenClass();\n      });\n\n      eventManager.removeEventListener(document,'mouseleave', function () {\n        removeZeroClipboardClass();\n      });\n      eventManager.addEventListener(document, 'mouseleave', function (e) {\n        removeZeroClipboardClass();\n      });\n\n\n    }\n  };\n\n  /**\n   * Initialize plugin\n   * @returns {boolean} Returns false if ZeroClipboard is not properly included\n   */\n  ContextMenuCopyPaste.prototype.init = function () {\n    if (!this.getSettings().contextMenuCopyPaste) {\n      return;\n    } else if (typeof this.getSettings().contextMenuCopyPaste == \"object\") {\n      cmCopyPaste.swfPath = this.getSettings().contextMenuCopyPaste.swfPath;\n    }\n\n    if (typeof ZeroClipboard === 'undefined') {\n      throw new Error(\"To be able to use the Copy/Paste feature from the context menu, you need to manualy include ZeroClipboard.js file to your website.\");\n\n      return false;\n    }\n\n    try {\n      var flashTest = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');\n    } catch(exception) {\n      if(!('undefined' != typeof navigator.mimeTypes['application/x-shockwave-flash'])) {\n        throw new Error(\"To be able to use the Copy/Paste feature from the context menu, your browser needs to have Flash Plugin installed.\");\n\n        return false;\n      }\n    }\n\n    cmCopyPaste.instance = this;\n    cmCopyPaste.prepareZeroClipboard();\n  };\n\n  var cmCopyPaste = new ContextMenuCopyPaste();\n\n  Handsontable.hooks.add('afterRender', function () {\n    cmCopyPaste.setupZeroClipboard(this);\n  });\n\n  Handsontable.hooks.add('afterInit', cmCopyPaste.init);\n  Handsontable.hooks.add('afterContextMenuDefaultOptions', cmCopyPaste.addToContextMenu);\n  Handsontable.ContextMenuCopyPaste = ContextMenuCopyPaste;\n\n})(Handsontable);\n\n(function (Handsontable) {\n  'use strict';\n\n  function MultipleSelectionHandles(instance) {\n    this.instance = instance;\n    this.dragged = [];\n\n    this.eventManager = Handsontable.eventManager(instance);\n\n    this.bindTouchEvents();\n  }\n\n  MultipleSelectionHandles.prototype.getCurrentRangeCoords = function (selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {\n    var topLeftCorner = selectedRange.getTopLeftCorner()\n      , bottomRightCorner = selectedRange.getBottomRightCorner()\n      , bottomLeftCorner = selectedRange.getBottomLeftCorner()\n      , topRightCorner = selectedRange.getTopRightCorner();\n\n    var newCoords = {\n      start: null,\n      end: null\n    };\n\n    switch (touchStartDirection) {\n      case \"NE-SW\":\n        switch (currentDirection) {\n          case \"NE-SW\":\n          case \"NW-SE\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: new WalkontableCellCoords(currentTouch.row, selectedRange.highlight.col),\n                end: new WalkontableCellCoords(bottomLeftCorner.row, currentTouch.col)\n              };\n            } else {\n              newCoords = {\n                start: new WalkontableCellCoords(selectedRange.highlight.row, currentTouch.col),\n                end: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col)\n              };\n            }\n            break;\n          case \"SE-NW\":\n            if (draggedHandle == \"bottomRight\") {\n              newCoords = {\n                start: new WalkontableCellCoords(bottomRightCorner.row, currentTouch.col),\n                end: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col)\n              };\n            }\n            break;\n          //case \"SW-NE\":\n          //  break;\n        }\n        break;\n      case \"NW-SE\":\n        switch (currentDirection) {\n          case \"NE-SW\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: currentTouch,\n                end: bottomLeftCorner\n              };\n            } else {\n              newCoords.end  = currentTouch;\n            }\n            break;\n          case \"NW-SE\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: currentTouch,\n                end: bottomRightCorner\n              };\n            } else {\n              newCoords.end  = currentTouch;\n            }\n            break;\n          case \"SE-NW\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: currentTouch,\n                end: topLeftCorner\n              };\n            } else {\n              newCoords.end  = currentTouch;\n            }\n            break;\n          case \"SW-NE\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: currentTouch,\n                end: topRightCorner\n              };\n            } else {\n              newCoords.end  = currentTouch;\n            }\n            break;\n        }\n        break;\n      case \"SW-NE\":\n        switch (currentDirection) {\n          case \"NW-SE\":\n            if (draggedHandle == \"bottomRight\") {\n              newCoords = {\n                start: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col),\n                end: new WalkontableCellCoords(bottomLeftCorner.row, currentTouch.col)\n              };\n            } else {\n              newCoords = {\n                start: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col),\n                end: new WalkontableCellCoords(currentTouch.row, bottomRightCorner.col)\n              };\n            }\n            break;\n          //case \"NE-SW\":\n          //\n          //  break;\n          case \"SW-NE\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: new WalkontableCellCoords(selectedRange.highlight.row, currentTouch.col),\n                end: new WalkontableCellCoords(currentTouch.row, bottomRightCorner.col)\n              };\n            } else {\n              newCoords = {\n                start: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col),\n                end: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col)\n              };\n            }\n            break;\n          case \"SE-NW\":\n            if (draggedHandle == \"bottomRight\") {\n              newCoords = {\n                start: new WalkontableCellCoords(currentTouch.row, topRightCorner.col),\n                end: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col)\n              };\n            } else if (draggedHandle == \"topLeft\") {\n              newCoords = {\n                start: bottomLeftCorner,\n                end: currentTouch\n              };\n            }\n            break;\n        }\n        break;\n      case \"SE-NW\":\n        switch (currentDirection) {\n          case \"NW-SE\":\n          case \"NE-SW\":\n          case \"SW-NE\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords.end = currentTouch;\n            }\n            break;\n          case \"SE-NW\":\n            if (draggedHandle == \"topLeft\") {\n              newCoords.end = currentTouch;\n            } else {\n              newCoords = {\n                start: currentTouch,\n                end: topLeftCorner\n              };\n            }\n            break;\n        }\n        break;\n    }\n\n    return newCoords;\n  };\n\n  MultipleSelectionHandles.prototype.bindTouchEvents = function () {\n    var that = this;\n    var removeFromDragged = function (query) {\n\n      if (this.dragged.length == 1) {\n        this.dragged = [];\n        return true;\n      }\n\n      var entryPosition = this.dragged.indexOf(query);\n\n      if (entryPosition == -1) {\n        return false;\n      } else if (entryPosition == 0) {\n        this.dragged = this.dragged.slice(0, 1);\n      } else if (entryPosition == 1) {\n        this.dragged = this.dragged.slice(-1);\n      }\n    };\n\n    this.eventManager.addEventListener(this.instance.rootElement,'touchstart', function (event) {\n      if(Handsontable.Dom.hasClass(event.target, \"topLeftSelectionHandle-HitArea\")) {\n        that.dragged.push(\"topLeft\");\n        var selectedRange = that.instance.getSelectedRange();\n        that.touchStartRange = {\n          width: selectedRange.getWidth(),\n          height: selectedRange.getHeight(),\n          direction: selectedRange.getDirection()\n        };\n        event.preventDefault();\n\n        return false;\n      } else if (Handsontable.Dom.hasClass(event.target, \"bottomRightSelectionHandle-HitArea\")) {\n        that.dragged.push(\"bottomRight\");\n        var selectedRange = that.instance.getSelectedRange();\n        that.touchStartRange = {\n          width: selectedRange.getWidth(),\n          height: selectedRange.getHeight(),\n          direction: selectedRange.getDirection()\n        };\n        event.preventDefault();\n\n        return false;\n      }\n    });\n\n    this.eventManager.addEventListener(this.instance.rootElement,'touchend', function (event) {\n      if(Handsontable.Dom.hasClass(event.target, \"topLeftSelectionHandle-HitArea\")) {\n        removeFromDragged.call(that, \"topLeft\");\n        that.touchStartRange = void 0;\n        event.preventDefault();\n\n        return false;\n      } else if (Handsontable.Dom.hasClass(event.target, \"bottomRightSelectionHandle-HitArea\")) {\n        removeFromDragged.call(that, \"bottomRight\");\n        that.touchStartRange = void 0;\n        event.preventDefault();\n\n        return false;\n      }\n    });\n\n    this.eventManager.addEventListener(this.instance.rootElement,'touchmove', function (event) {\n      var scrollTop = Handsontable.Dom.getWindowScrollTop()\n        , scrollLeft = Handsontable.Dom.getWindowScrollLeft();\n\n      if (that.dragged.length > 0) {\n        var endTarget = document.elementFromPoint(\n          event.touches[0].screenX - scrollLeft,\n          event.touches[0].screenY - scrollTop\n        );\n\n        if(!endTarget) {\n          return;\n        }\n\n        if (endTarget.nodeName == \"TD\" || endTarget.nodeName == \"TH\") {\n          var targetCoords = that.instance.getCoords(endTarget);\n\n          if(targetCoords.col == -1) {\n            targetCoords.col = 0;\n          }\n\n          var selectedRange = that.instance.getSelectedRange()\n            , rangeWidth = selectedRange.getWidth()\n            , rangeHeight = selectedRange.getHeight()\n            , rangeDirection = selectedRange.getDirection();\n\n          if (rangeWidth == 1 && rangeHeight == 1) {\n            that.instance.selection.setRangeEnd(targetCoords);\n          }\n\n          var newRangeCoords = that.getCurrentRangeCoords(selectedRange, targetCoords, that.touchStartRange.direction, rangeDirection, that.dragged[0]);\n\n          if(newRangeCoords.start != null) {\n            that.instance.selection.setRangeStart(newRangeCoords.start);\n          }\n          that.instance.selection.setRangeEnd(newRangeCoords.end);\n\n        }\n\n        event.preventDefault();\n      }\n    });\n\n  };\n\n  MultipleSelectionHandles.prototype.isDragged = function () {\n    if (this.dragged.length == 0) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  var init = function () {\n    var instance = this;\n\n    Handsontable.plugins.multipleSelectionHandles = new MultipleSelectionHandles(instance);\n  };\n\n  Handsontable.hooks.add('afterInit', init);\n\n})(Handsontable);\n\nvar TouchScroll = (function(instance) {\n\n  function TouchScroll(instance) {}\n\n  TouchScroll.prototype.init = function(instance) {\n    this.instance = instance;\n    this.bindEvents();\n\n    this.scrollbars = [\n      this.instance.view.wt.wtScrollbars.vertical,\n      this.instance.view.wt.wtScrollbars.horizontal,\n      this.instance.view.wt.wtScrollbars.corner\n    ]\n\n    this.clones = [\n      this.instance.view.wt.wtScrollbars.vertical.clone.wtTable.holder.parentNode,\n      this.instance.view.wt.wtScrollbars.horizontal.clone.wtTable.holder.parentNode,\n      this.instance.view.wt.wtScrollbars.corner.clone.wtTable.holder.parentNode\n    ]\n  };\n\n  TouchScroll.prototype.bindEvents = function () {\n  var that = this;\n\n    this.instance.addHook('beforeTouchScroll', function () {\n      Handsontable.freezeOverlays = true;\n\n      for(var i = 0, cloneCount = that.clones.length; i < cloneCount ; i++) {\n        Handsontable.Dom.addClass(that.clones[i], 'hide-tween');\n      }\n    });\n\n    this.instance.addHook('afterMomentumScroll', function () {\n      Handsontable.freezeOverlays = false;\n\n      for(var i = 0, cloneCount = that.clones.length; i < cloneCount ; i++) {\n        Handsontable.Dom.removeClass(that.clones[i], 'hide-tween');\n      }\n\n      for(var i = 0, cloneCount = that.clones.length; i < cloneCount ; i++) {\n        Handsontable.Dom.addClass(that.clones[i], 'show-tween');\n      }\n\n      setTimeout(function () {\n        for(var i = 0, cloneCount = that.clones.length; i < cloneCount ; i++) {\n          Handsontable.Dom.removeClass(that.clones[i], 'show-tween');\n        }\n      },400);\n\n      for(var i = 0, cloneCount = that.scrollbars.length; i < cloneCount ; i++) {\n        that.scrollbars[i].refresh();\n        that.scrollbars[i].resetFixedPosition();\n      }\n\n    });\n\n  };\n\n  return TouchScroll;\n}());\n\nvar touchScrollHandler = new TouchScroll();\n\nHandsontable.hooks.add('afterInit', function() {\n  touchScrollHandler.init.call(touchScrollHandler, this);\n});\n\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling\n */\nfunction WalkontableOverlay() {}\n\n/*\n Possible optimizations:\n [x] don't rerender if scroll delta is smaller than the fragment outside of the viewport\n [ ] move .style.top change before .draw()\n [ ] put .draw() in requestAnimationFrame\n [ ] don't rerender rows that remain visible after the scroll\n */\n\nWalkontableOverlay.prototype.init = function () {\n  this.TABLE = this.instance.wtTable.TABLE;\n  this.fixed = this.instance.wtTable.hider;\n  this.fixedContainer = this.instance.wtTable.holder;\n  this.scrollHandler = this.getScrollableElement(this.TABLE);\n};\n\nWalkontableOverlay.prototype.makeClone = function (direction) {\n  var clone = document.createElement('DIV');\n  clone.className = 'ht_clone_' + direction + ' handsontable';\n  clone.style.position = 'absolute';\n  clone.style.top = 0;\n  clone.style.left = 0;\n  clone.style.overflow = 'hidden';\n\n  var table2 = document.createElement('TABLE');\n  table2.className = this.instance.wtTable.TABLE.className;\n  clone.appendChild(table2);\n\n  this.instance.wtTable.holder.parentNode.appendChild(clone);\n\n  return new Walkontable({\n    cloneSource: this.instance,\n    cloneOverlay: this,\n    table: table2\n  });\n};\n\nWalkontableOverlay.prototype.getScrollableElement = function (TABLE) {\n  var el = TABLE.parentNode;\n  while (el && el.style) {\n    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {\n      return el;\n    }\n    if (this instanceof WalkontableHorizontalScrollbarNative && el.style.overflowX !== 'visible' && el.style.overflowX !== '') {\n      return el;\n    }\n    el = el.parentNode;\n  }\n  return window;\n};\n\nWalkontableOverlay.prototype.refresh = function (fastDraw) {\n  this.clone && this.clone.draw(fastDraw);\n};\n\nWalkontableOverlay.prototype.destroy = function () {\n  var eventManager = Handsontable.eventManager(this.clone);\n  eventManager.clear();\n};\n\nfunction WalkontableBorder(instance, settings) {\n  var style;\n  var createMultipleSelectorHandles = function () {\n    this.selectionHandles = {\n      topLeft: document.createElement('DIV'),\n      topLeftHitArea: document.createElement('DIV'),\n      bottomRight: document.createElement('DIV'),\n      bottomRightHitArea: document.createElement('DIV')\n    };\n    var width = 10\n      , hitAreaWidth = 40;\n\n    this.selectionHandles.topLeft.className = 'topLeftSelectionHandle';\n    this.selectionHandles.topLeftHitArea.className = 'topLeftSelectionHandle-HitArea';\n    this.selectionHandles.bottomRight.className = 'bottomRightSelectionHandle';\n    this.selectionHandles.bottomRightHitArea.className = 'bottomRightSelectionHandle-HitArea';\n\n    this.selectionHandles.styles = {\n      topLeft: this.selectionHandles.topLeft.style,\n      topLeftHitArea: this.selectionHandles.topLeftHitArea.style,\n      bottomRight: this.selectionHandles.bottomRight.style,\n      bottomRightHitArea: this.selectionHandles.bottomRightHitArea.style\n    };\n\n    var hitAreaStyle = {\n      'position': 'absolute',\n      'height': hitAreaWidth + 'px',\n      'width': hitAreaWidth + 'px',\n      'border-radius': parseInt(hitAreaWidth/1.5,10) + 'px'\n    };\n\n    for (var prop in hitAreaStyle) {\n      this.selectionHandles.styles.bottomRightHitArea[prop] = hitAreaStyle[prop];\n      this.selectionHandles.styles.topLeftHitArea[prop] = hitAreaStyle[prop];\n    }\n\n    var handleStyle = {\n      'position': 'absolute',\n      'height': width + 'px',\n      'width': width + 'px',\n      'border-radius': parseInt(width/1.5,10) + 'px',\n      'background': '#F5F5FF',\n      'border': '1px solid #4285c8'\n    };\n\n    for (var prop in handleStyle) {\n      this.selectionHandles.styles.bottomRight[prop] = handleStyle[prop];\n      this.selectionHandles.styles.topLeft[prop] = handleStyle[prop];\n    }\n\n    this.main.appendChild(this.selectionHandles.topLeft);\n    this.main.appendChild(this.selectionHandles.bottomRight);\n    this.main.appendChild(this.selectionHandles.topLeftHitArea);\n    this.main.appendChild(this.selectionHandles.bottomRightHitArea);\n  };\n\n  if(!settings){\n    return;\n  }\n\n  var eventManager = Handsontable.eventManager(instance);\n\n  //reference to instance\n  this.instance = instance;\n  this.settings = settings;\n\n  this.main = document.createElement(\"div\");\n  style = this.main.style;\n  style.position = 'absolute';\n  style.top = 0;\n  style.left = 0;\n\n  var borderDivs = ['top','left','bottom','right','corner'];\n\n  for (var i = 0; i < 5; i++) {\n    var position = borderDivs[i];\n\n    var DIV = document.createElement('DIV');\n    DIV.className = 'wtBorder ' + (this.settings.className || ''); // + borderDivs[i];\n    if(this.settings[position] && this.settings[position].hide){\n      DIV.className += \" hidden\";\n    }\n\n    style = DIV.style;\n    style.backgroundColor = (this.settings[position] && this.settings[position].color) ? this.settings[position].color : settings.border.color;\n    style.height = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';\n    style.width = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';\n\n    this.main.appendChild(DIV);\n  }\n\n  this.top = this.main.childNodes[0];\n  this.left = this.main.childNodes[1];\n  this.bottom = this.main.childNodes[2];\n  this.right = this.main.childNodes[3];\n\n  this.topStyle = this.top.style;\n  this.leftStyle = this.left.style;\n  this.bottomStyle = this.bottom.style;\n  this.rightStyle = this.right.style;\n\n  this.corner = this.main.childNodes[4];\n  this.corner.className += ' corner';\n  this.cornerStyle = this.corner.style;\n  this.cornerStyle.width = '5px';\n  this.cornerStyle.height = '5px';\n  this.cornerStyle.border = '2px solid #FFF';\n\n  if(Handsontable.mobileBrowser) {\n    createMultipleSelectorHandles.call(this);\n  }\n\n  this.disappear();\n  if (!instance.wtTable.bordersHolder) {\n    instance.wtTable.bordersHolder = document.createElement('div');\n    instance.wtTable.bordersHolder.className = 'htBorders';\n    instance.wtTable.hider.appendChild(instance.wtTable.bordersHolder);\n\n  }\n  instance.wtTable.bordersHolder.insertBefore(this.main, instance.wtTable.bordersHolder.firstChild);\n\n  var down = false;\n\n\n\n  eventManager.addEventListener(document.body, 'mousedown', function () {\n    down = true;\n  });\n\n\n  eventManager.addEventListener(document.body, 'mouseup', function () {\n    down = false\n  });\n\n  for (var c = 0, len = this.main.childNodes.length; c < len; c++) {\n\n    eventManager.addEventListener(this.main.childNodes[c], 'mouseenter', function (event) {\n      if (!down || !instance.getSetting('hideBorderOnMouseDownOver')) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n\n      var bounds = this.getBoundingClientRect();\n\n      this.style.display = 'none';\n\n      var isOutside = function (event) {\n        if (event.clientY < Math.floor(bounds.top)) {\n          return true;\n        }\n        if (event.clientY > Math.ceil(bounds.top + bounds.height)) {\n          return true;\n        }\n        if (event.clientX < Math.floor(bounds.left)) {\n          return true;\n        }\n        if (event.clientX > Math.ceil(bounds.left + bounds.width)) {\n          return true;\n        }\n      };\n\n      var handler = function (event) {\n        if (isOutside(event)) {\n          eventManager.removeEventListener(document.body, 'mousemove', handler);\n          this.style.display = 'block';\n        }\n      };\n      eventManager.addEventListener(document.body, 'mousemove', handler);;\n    });\n  }\n}\n\n/**\n * Show border around one or many cells\n * @param {Array} corners\n */\nWalkontableBorder.prototype.appear = function (corners) {\n  var isMultiple, fromTD, toTD, fromOffset, toOffset, containerOffset, top, minTop, left, minLeft, height, width;\n  if (this.disabled) {\n    return;\n  }\n\n  var instance = this.instance;\n\n  var fromRow\n    , fromColumn\n    , toRow\n    , toColumn\n    , i\n    , ilen\n    , s;\n\n  var isPartRange = function () {\n    if(this.instance.selections.area.cellRange) {\n\n      if(toRow != this.instance.selections.area.cellRange.to.row\n        || toColumn != this.instance.selections.area.cellRange.to.col) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var updateMultipleSelectionHandlesPosition = function (top, left, width, height) {\n    var handleWidth = parseInt(this.selectionHandles.styles.topLeft.width, 10)\n      , hitAreaWidth = parseInt(this.selectionHandles.styles.topLeftHitArea.width, 10);\n\n    this.selectionHandles.styles.topLeft.top = parseInt(top - handleWidth,10) + \"px\";\n    this.selectionHandles.styles.topLeft.left = parseInt(left - handleWidth,10) + \"px\";\n\n    this.selectionHandles.styles.topLeftHitArea.top = parseInt(top - (hitAreaWidth/4)*3,10) + \"px\";\n    this.selectionHandles.styles.topLeftHitArea.left = parseInt(left - (hitAreaWidth/4)*3,10) + \"px\";\n\n    this.selectionHandles.styles.bottomRight.top = parseInt(top + height,10) + \"px\";\n    this.selectionHandles.styles.bottomRight.left = parseInt(left + width,10) + \"px\";\n\n    this.selectionHandles.styles.bottomRightHitArea.top = parseInt(top + height - hitAreaWidth/4,10) + \"px\";\n    this.selectionHandles.styles.bottomRightHitArea.left = parseInt(left + width - hitAreaWidth/4,10) + \"px\";\n\n    if(this.settings.border.multipleSelectionHandlesVisible && this.settings.border.multipleSelectionHandlesVisible()) {\n      this.selectionHandles.styles.topLeft.display = \"block\";\n      this.selectionHandles.styles.topLeftHitArea.display = \"block\";\n      if(!isPartRange.call(this)) {\n        this.selectionHandles.styles.bottomRight.display = \"block\";\n        this.selectionHandles.styles.bottomRightHitArea.display = \"block\";\n      } else {\n        this.selectionHandles.styles.bottomRight.display = \"none\";\n        this.selectionHandles.styles.bottomRightHitArea.display = \"none\";\n      }\n    } else {\n      this.selectionHandles.styles.topLeft.display = \"none\";\n      this.selectionHandles.styles.bottomRight.display = \"none\";\n      this.selectionHandles.styles.topLeftHitArea.display = \"none\";\n      this.selectionHandles.styles.bottomRightHitArea.display = \"none\";\n    }\n\n    if(fromRow == this.instance.wtSettings.getSetting('fixedRowsTop') || fromColumn == this.instance.wtSettings.getSetting('fixedColumnsLeft')) {\n      this.selectionHandles.styles.topLeft.zIndex = \"9999\";\n      this.selectionHandles.styles.topLeftHitArea.zIndex = \"9999\";\n    } else {\n      this.selectionHandles.styles.topLeft.zIndex = \"\";\n      this.selectionHandles.styles.topLeftHitArea.zIndex = \"\";\n    }\n\n  };\n\n  if (instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {\n    ilen = instance.getSetting('fixedRowsTop');\n  }\n  else {\n    ilen = instance.wtTable.getRenderedRowsCount();\n  }\n\n  for (i = 0; i < ilen; i++) {\n    s = instance.wtTable.rowFilter.renderedToSource(i);\n    if (s >= corners[0] && s <= corners[2]) {\n      fromRow = s;\n      break;\n    }\n  }\n\n  for (i = ilen - 1; i >= 0; i--) {\n    s = instance.wtTable.rowFilter.renderedToSource(i);\n    if (s >= corners[0] && s <= corners[2]) {\n      toRow = s;\n      break;\n    }\n  }\n\n  ilen = instance.wtTable.getRenderedColumnsCount();\n\n  for (i = 0; i < ilen; i++) {\n    s = instance.wtTable.columnFilter.renderedToSource(i);\n    if (s >= corners[1] && s <= corners[3]) {\n      fromColumn = s;\n      break;\n    }\n  }\n\n  for (i = ilen - 1; i >= 0; i--) {\n    s = instance.wtTable.columnFilter.renderedToSource(i);\n    if (s >= corners[1] && s <= corners[3]) {\n      toColumn = s;\n      break;\n    }\n  }\n\n  if (fromRow !== void 0 && fromColumn !== void 0) {\n    isMultiple = (fromRow !== toRow || fromColumn !== toColumn);\n    fromTD = instance.wtTable.getCell(new WalkontableCellCoords(fromRow, fromColumn));\n    toTD = isMultiple ? instance.wtTable.getCell(new WalkontableCellCoords(toRow, toColumn)) : fromTD;\n    fromOffset = Handsontable.Dom.offset(fromTD);\n    toOffset = isMultiple ? Handsontable.Dom.offset(toTD) : fromOffset;\n    containerOffset = Handsontable.Dom.offset(instance.wtTable.TABLE);\n\n    minTop = fromOffset.top;\n    height = toOffset.top + Handsontable.Dom.outerHeight(toTD) - minTop;\n    minLeft = fromOffset.left;\n    width = toOffset.left + Handsontable.Dom.outerWidth(toTD) - minLeft;\n\n    top = minTop - containerOffset.top - 1;\n    left = minLeft - containerOffset.left - 1;\n\n    var style = Handsontable.Dom.getComputedStyle(fromTD);\n    if (parseInt(style['borderTopWidth'], 10) > 0) {\n      top += 1;\n      height = height > 0 ? height - 1 : 0;\n    }\n    if (parseInt(style['borderLeftWidth'], 10) > 0) {\n      left += 1;\n      width = width > 0 ? width - 1 : 0;\n    }\n  }\n  else {\n    this.disappear();\n    return;\n  }\n\n  this.topStyle.top = top + 'px';\n  this.topStyle.left = left + 'px';\n  this.topStyle.width = width + 'px';\n  this.topStyle.display = 'block';\n\n  this.leftStyle.top = top + 'px';\n  this.leftStyle.left = left + 'px';\n  this.leftStyle.height = height + 'px';\n  this.leftStyle.display = 'block';\n\n  var delta = Math.floor(this.settings.border.width / 2);\n\n  this.bottomStyle.top = top + height - delta + 'px';\n  this.bottomStyle.left = left + 'px';\n  this.bottomStyle.width = width + 'px';\n  this.bottomStyle.display = 'block';\n\n  this.rightStyle.top = top + 'px';\n  this.rightStyle.left = left + width - delta + 'px';\n  this.rightStyle.height = height + 1 + 'px';\n  this.rightStyle.display = 'block';\n\n  if (Handsontable.mobileBrowser || (!this.hasSetting(this.settings.border.cornerVisible) || isPartRange.call(this))) {\n    this.cornerStyle.display = 'none';\n  }\n  else {\n    this.cornerStyle.top = top + height - 4 + 'px';\n    this.cornerStyle.left = left + width - 4 + 'px';\n    this.cornerStyle.display = 'block';\n  }\n\n  if(Handsontable.mobileBrowser) {\n    updateMultipleSelectionHandlesPosition.call(this,top, left, width, height);\n  }\n};\n\n/**\n * Hide border\n */\nWalkontableBorder.prototype.disappear = function () {\n  this.topStyle.display = 'none';\n  this.leftStyle.display = 'none';\n  this.bottomStyle.display = 'none';\n  this.rightStyle.display = 'none';\n  this.cornerStyle.display = 'none';\n\n  if(Handsontable.mobileBrowser) {\n    this.selectionHandles.styles.topLeft.display = 'none';\n    this.selectionHandles.styles.bottomRight.display = 'none';\n  }\n\n\n};\n\nWalkontableBorder.prototype.hasSetting = function (setting) {\n  if (typeof setting === 'function') {\n    return setting();\n  }\n  return !!setting;\n};\n\n/**\n * WalkontableCellCoords holds cell coordinates (row, column) and few metiod to validate them and retrieve as an array or an object\n * TODO: change interface to WalkontableCellCoords(row, col) everywhere, remove those unnecessary setter and getter functions\n */\n\nfunction WalkontableCellCoords(row, col) {\n  if (typeof row !== 'undefined' && typeof col !== 'undefined') {\n    this.row = row;\n    this.col = col;\n  }\n  else {\n    this.row = null;\n    this.col = null;\n  }\n}\n\n/**\n * Returns boolean information if given set of coordinates is valid in context of a given Walkontable instance\n * @param instance\n * @returns {boolean}\n */\nWalkontableCellCoords.prototype.isValid = function (instance) {\n  //is it a valid cell index (0 or higher)\n  if (this.row < 0 || this.col < 0) {\n    return false;\n  }\n\n  //is selection within total rows and columns\n  if (this.row >= instance.getSetting('totalRows') || this.col >= instance.getSetting('totalColumns')) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Returns boolean information if this cell coords are the same as cell coords given as a parameter\n * @param {WalkontableCellCoords} cellCoords\n * @returns {boolean}\n */\nWalkontableCellCoords.prototype.isEqual = function (cellCoords) {\n  if (cellCoords === this) {\n    return true;\n  }\n  return (this.row === cellCoords.row && this.col === cellCoords.col);\n};\n\nWalkontableCellCoords.prototype.isSouthEastOf = function (testedCoords) {\n  return this.row >= testedCoords.row && this.col >= testedCoords.col;\n};\n\nWalkontableCellCoords.prototype.isNorthWestOf = function (testedCoords) {\n  return this.row <= testedCoords.row && this.col <= testedCoords.col;\n};\n\nWalkontableCellCoords.prototype.isSouthWestOf = function (testedCoords) {\n  return this.row >= testedCoords.row && this.col <= testedCoords.col;\n};\n\nWalkontableCellCoords.prototype.isNorthEastOf = function (testedCoords) {\n  return this.row <= testedCoords.row && this.col >= testedCoords.col;\n};\n\nwindow.WalkontableCellCoords = WalkontableCellCoords; //export\n\n/**\n * A cell range is a set of exactly two WalkontableCellCoords (that can be the same or different)\n */\n\nfunction WalkontableCellRange(highlight, from, to) {\n  this.highlight = highlight; //this property is used to draw bold border around a cell where selection was started and to edit the cell when you press Enter\n  this.from = from; //this property is usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection\n  this.to = to;\n}\n\nWalkontableCellRange.prototype.isValid = function (instance) {\n  return (this.from.isValid(instance) && this.to.isValid(instance));\n};\n\nWalkontableCellRange.prototype.isSingle = function () {\n  return (this.from.row === this.to.row && this.from.col === this.to.col);\n};\n\n/**\n * Returns selected range height (in number of rows)\n * @returns {number}\n */\nWalkontableCellRange.prototype.getHeight = function () {\n  return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n};\n\n/**\n * Returns selected range width (in number of columns)\n * @returns {number}\n */\nWalkontableCellRange.prototype.getWidth = function () {\n  return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n};\n\n/**\n * Returns boolean information if given cell coords is within `from` and `to` cell coords of this range\n * @param {WalkontableCellCoords} cellCoords\n * @returns {boolean}\n */\nWalkontableCellRange.prototype.includes = function (cellCoords) {\n  var topLeft = this.getTopLeftCorner();\n  var bottomRight = this.getBottomRightCorner();\n\n  if (cellCoords.row < 0) {\n    cellCoords.row = 0;\n  }\n\n  if (cellCoords.col < 0) {\n    cellCoords.col = 0;\n  }\n\n  return (topLeft.row <= cellCoords.row && bottomRight.row >= cellCoords.row && topLeft.col <= cellCoords.col && bottomRight.col >= cellCoords.col);\n};\n\nWalkontableCellRange.prototype.includesRange = function (testedRange) {\n  return this.includes(testedRange.getTopLeftCorner()) && this.includes(testedRange.getBottomRightCorner());\n};\n\nWalkontableCellRange.prototype.isEqual = function (testedRange) {\n  return (Math.min(this.from.row, this.to.row) == Math.min(testedRange.from.row, testedRange.to.row))\n    && (Math.max(this.from.row, this.to.row) == Math.max(testedRange.from.row, testedRange.to.row))\n    && (Math.min(this.from.col, this.to.col) == Math.min(testedRange.from.col, testedRange.to.col))\n    && (Math.max(this.from.col, this.to.col) == Math.max(testedRange.from.col, testedRange.to.col));\n};\n\n/**\n * Returns true if tested range overlaps with the range.\n * Range A is considered to to be overlapping with range B if intersection of A and B or B and A is not empty.\n * @param testedRange\n * @returns {boolean}\n */\nWalkontableCellRange.prototype.overlaps = function (testedRange) {\n  return testedRange.isSouthEastOf(this.getTopLeftCorner()) && testedRange.isNorthWestOf(this.getBottomRightCorner());\n};\n\nWalkontableCellRange.prototype.isSouthEastOf = function (testedCoords) {\n  return this.getTopLeftCorner().isSouthEastOf(testedCoords) || this.getBottomRightCorner().isSouthEastOf(testedCoords);\n};\n\nWalkontableCellRange.prototype.isNorthWestOf = function (testedCoords) {\n  return this.getTopLeftCorner().isNorthWestOf(testedCoords) || this.getBottomRightCorner().isNorthWestOf(testedCoords);\n};\n\n/**\n * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded\n * @param {WalkontableCellCoords} cellCoords\n * @returns {boolean}\n */\nWalkontableCellRange.prototype.expand = function (cellCoords) {\n  var topLeft = this.getTopLeftCorner();\n  var bottomRight = this.getBottomRightCorner();\n  if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n    this.from = new WalkontableCellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n    this.to = new WalkontableCellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n    return true;\n  }\n  return false;\n};\n\nWalkontableCellRange.prototype.expandByRange = function (expandingRange) {\n  if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n    return false;\n  }\n\n  var topLeft = this.getTopLeftCorner()\n    , bottomRight = this.getBottomRightCorner()\n    , topRight = this.getTopRightCorner()\n    , bottomLeft = this.getBottomLeftCorner();\n\n  var expandingTopLeft = expandingRange.getTopLeftCorner();\n  var expandingBottomRight = expandingRange.getBottomRightCorner();\n\n  var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n  var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n  var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n  var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n\n  var finalFrom = new WalkontableCellCoords(resultTopRow, resultTopCol)\n    , finalTo = new WalkontableCellCoords(resultBottomRow, resultBottomCol);\n  var isCorner = new WalkontableCellRange(finalFrom, finalFrom, finalTo).isCorner(this.from, expandingRange)\n    , onlyMerge = expandingRange.isEqual(new WalkontableCellRange(finalFrom, finalFrom, finalTo));\n\n  if (isCorner && !onlyMerge) {\n    if (this.from.col > finalFrom.col) {\n      finalFrom.col = resultBottomCol;\n      finalTo.col = resultTopCol;\n    }\n    if (this.from.row > finalFrom.row) {\n      finalFrom.row = resultBottomRow;\n      finalTo.row = resultTopRow;\n    }\n  }\n\n  this.from = finalFrom;\n  this.to = finalTo;\n\n  return true;\n};\n\nWalkontableCellRange.prototype.getDirection = function () {\n  if (this.from.isNorthWestOf(this.to)) {        // NorthWest - SouthEast\n    return \"NW-SE\";\n  } else if (this.from.isNorthEastOf(this.to)) { // NorthEast - SouthWest\n    return \"NE-SW\";\n  } else if (this.from.isSouthEastOf(this.to)) { // SouthEast - NorthWest\n    return \"SE-NW\";\n  } else if (this.from.isSouthWestOf(this.to)) { // SouthWest - NorthEast\n    return \"SW-NE\";\n  }\n};\n\nWalkontableCellRange.prototype.setDirection = function (direction) {\n  switch (direction) {\n    case \"NW-SE\" :\n      this.from = this.getTopLeftCorner();\n      this.to = this.getBottomRightCorner();\n      break;\n    case \"NE-SW\" :\n      this.from = this.getTopRightCorner();\n      this.to = this.getBottomLeftCorner();\n      break;\n    case \"SE-NW\" :\n      this.from = this.getBottomRightCorner();\n      this.to = this.getTopLeftCorner();\n      break;\n    case \"SW-NE\" :\n      this.from = this.getBottomLeftCorner();\n      this.to = this.getTopRightCorner();\n      break;\n  }\n};\n\nWalkontableCellRange.prototype.getTopLeftCorner = function () {\n  return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n};\n\nWalkontableCellRange.prototype.getBottomRightCorner = function () {\n  return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n};\n\nWalkontableCellRange.prototype.getTopRightCorner = function () {\n  return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n};\n\nWalkontableCellRange.prototype.getBottomLeftCorner = function () {\n  return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n};\n\nWalkontableCellRange.prototype.isCorner = function (coords, expandedRange) {\n  if (expandedRange) {\n    if (expandedRange.includes(coords)) {\n      if (this.getTopLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col))\n        || this.getTopRightCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col))\n        || this.getBottomLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col))\n        || this.getBottomRightCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {\n        return true;\n      }\n    }\n  }\n  return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());\n};\n\nWalkontableCellRange.prototype.getOppositeCorner = function (coords, expandedRange) {\n  if (!(coords instanceof WalkontableCellCoords)) return false;\n\n  if (expandedRange) {\n    if (expandedRange.includes(coords)) {\n      if (this.getTopLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col))) return this.getBottomRightCorner();\n      if (this.getTopRightCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col))) return this.getBottomLeftCorner();\n      if (this.getBottomLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col))) return this.getTopRightCorner();\n      if (this.getBottomRightCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) return this.getTopLeftCorner();\n    }\n  }\n\n  if (coords.isEqual(this.getBottomRightCorner())) {\n    return this.getTopLeftCorner();\n  } else if (coords.isEqual(this.getTopLeftCorner())) {\n    return this.getBottomRightCorner();\n  } else if (coords.isEqual(this.getTopRightCorner())) {\n    return this.getBottomLeftCorner();\n  } else if (coords.isEqual(this.getBottomLeftCorner())) {\n    return  this.getTopRightCorner();\n  }\n};\n\nWalkontableCellRange.prototype.getBordersSharedWith = function (range) {\n  if (!this.includesRange(range)) {\n    return [];\n  }\n\n  var thisBorders = {\n      top: Math.min(this.from.row, this.to.row),\n      bottom: Math.max(this.from.row, this.to.row),\n      left: Math.min(this.from.col, this.to.col),\n      right: Math.max(this.from.col, this.to.col)\n    }\n    , rangeBorders = {\n      top: Math.min(range.from.row, range.to.row),\n      bottom: Math.max(range.from.row, range.to.row),\n      left: Math.min(range.from.col, range.to.col),\n      right: Math.max(range.from.col, range.to.col)\n    }\n    , result = [];\n\n  if (thisBorders.top == rangeBorders.top) {\n    result.push('top');\n  }\n  if (thisBorders.right == rangeBorders.right) {\n    result.push('right');\n  }\n  if (thisBorders.bottom == rangeBorders.bottom) {\n    result.push('bottom');\n  }\n  if (thisBorders.left == rangeBorders.left) {\n    result.push('left');\n  }\n\n  return result;\n};\n\nWalkontableCellRange.prototype.getInner = function () {\n  var topLeft = this.getTopLeftCorner();\n  var bottomRight = this.getBottomRightCorner();\n  var out = [];\n  for (var r = topLeft.row; r <= bottomRight.row; r++) {\n    for (var c = topLeft.col; c <= bottomRight.col; c++) {\n      if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n        out.push(new WalkontableCellCoords(r, c));\n      }\n    }\n  }\n  return out;\n};\n\nWalkontableCellRange.prototype.getAll = function () {\n  var topLeft = this.getTopLeftCorner();\n  var bottomRight = this.getBottomRightCorner();\n  var out = [];\n  for (var r = topLeft.row; r <= bottomRight.row; r++) {\n    for (var c = topLeft.col; c <= bottomRight.col; c++) {\n      if (topLeft.row === r && topLeft.col === c) {\n        out.push(topLeft);\n      }\n      else if (bottomRight.row === r && bottomRight.col === c) {\n        out.push(bottomRight);\n      }\n      else {\n        out.push(new WalkontableCellCoords(r, c));\n      }\n    }\n  }\n  return out;\n};\n\n/**\n * Runs a callback function against all cells in the range. You can break the iteration by returning false in the callback function\n * @param callback {Function}\n */\nWalkontableCellRange.prototype.forAll = function (callback) {\n  var topLeft = this.getTopLeftCorner();\n  var bottomRight = this.getBottomRightCorner();\n  for (var r = topLeft.row; r <= bottomRight.row; r++) {\n    for (var c = topLeft.col; c <= bottomRight.col; c++) {\n      var breakIteration = callback(r, c);\n      if (breakIteration === false) {\n        return;\n      }\n    }\n  }\n};\n\nwindow.WalkontableCellRange = WalkontableCellRange; //export\n\n/**\n * WalkontableColumnFilter\n * @constructor\n */\nfunction WalkontableColumnFilter(offset,total, countTH) {\n  this.offset = offset;\n  this.total = total;\n  this.countTH = countTH;\n}\n\nWalkontableColumnFilter.prototype.offsetted = function (n) {\n  return n + this.offset;\n};\n\nWalkontableColumnFilter.prototype.unOffsetted = function (n) {\n  return n - this.offset;\n};\n\nWalkontableColumnFilter.prototype.renderedToSource = function (n) {\n  return this.offsetted(n);\n};\n\nWalkontableColumnFilter.prototype.sourceToRendered = function (n) {\n  return this.unOffsetted(n);\n};\n\nWalkontableColumnFilter.prototype.offsettedTH = function (n) {\n  return n - this.countTH;\n};\n\nWalkontableColumnFilter.prototype.unOffsettedTH = function (n) {\n  return n + this.countTH;\n};\n\nWalkontableColumnFilter.prototype.visibleRowHeadedColumnToSourceColumn = function (n) {\n  return this.renderedToSource(this.offsettedTH(n));\n};\n\nWalkontableColumnFilter.prototype.sourceColumnToVisibleRowHeadedColumn = function (n) {\n  return this.unOffsettedTH(this.sourceToRendered(n));\n};\n\n/**\n * WalkontableColumnStrategy\n * @param containerSizeFn\n * @param sizeAtIndex\n * @param strategy - all, last, none\n * @constructor\n */\nfunction WalkontableColumnStrategy(instance, containerSizeFn, sizeAtIndex, strategy) {\n  var size\n    , i = 0;\n\n  this.instance = instance;\n  this.containerSizeFn = containerSizeFn;\n  this.cellSizesSum = 0;\n  this.cellSizes = [];\n  this.cellStretch = [];\n  this.cellCount = 0;\n  this.visibleCellCount = 0;\n  this.remainingSize = 0;\n  this.strategy = strategy;\n\n  //step 1 - determine cells that fit containerSize and cache their widths\n  while (true) {\n    size = sizeAtIndex(i);\n    if (size === void 0) {\n      break; //total columns exceeded\n    }\n    if (this.cellSizesSum < this.getContainerSize()) {\n      this.visibleCellCount++;\n    }\n    this.cellSizes.push(size);\n    this.cellSizesSum += size;\n    this.cellCount++;\n\n    i++;\n  }\n\n  var containerSize = this.getContainerSize();\n  this.remainingSize = this.cellSizesSum - containerSize;\n  //negative value means the last cell is fully visible and there is some space left for stretching\n  //positive value means the last cell is not fully visible\n}\n\nWalkontableColumnStrategy.prototype.getContainerSize = function () {\n  return typeof this.containerSizeFn === 'function' ? this.containerSizeFn() : this.containerSizeFn;\n};\n\nWalkontableColumnStrategy.prototype.getSize = function (index) {\n  return this.cellSizes[index] + (this.cellStretch[index] || 0);\n};\n\nWalkontableColumnStrategy.prototype.stretch = function () {\n  //step 2 - apply stretching strategy\n  var containerSize = this.getContainerSize()\n    , i = 0;\n\n  this.remainingSize = this.cellSizesSum - containerSize;\n\n  this.cellStretch.length = 0; //clear previous stretch\n\n  if (this.strategy === 'all') {\n    if (this.remainingSize < 0) {\n      var ratio = containerSize / this.cellSizesSum;\n      var newSize;\n\n      while (i < this.cellCount - 1) { //\"i < this.cellCount - 1\" is needed because last cellSize is adjusted after the loop\n        newSize = Math.floor(ratio * this.cellSizes[i]);\n        this.remainingSize += newSize - this.cellSizes[i];\n        this.cellStretch[i] = newSize - this.cellSizes[i];\n        i++;\n      }\n      this.cellStretch[this.cellCount - 1] = -this.remainingSize;\n      this.remainingSize = 0;\n    }\n  }\n  else if (this.strategy === 'last') {\n    if (this.remainingSize < 0 && containerSize !== Infinity) { //Infinity is with native scroll when the table is wider than the viewport (TODO: test)\n      this.cellStretch[this.cellCount - 1] = -this.remainingSize;\n      this.remainingSize = 0;\n    }\n  }\n};\n\nWalkontableColumnStrategy.prototype.countVisible = function () {\n  return this.visibleCellCount;\n};\n\nWalkontableColumnStrategy.prototype.isLastIncomplete = function () {\n\n  var firstRow = this.instance.wtTable.getFirstVisibleRow();\n  var lastCol = this.instance.wtTable.getLastVisibleColumn();\n  var cell = this.instance.wtTable.getCell(new WalkontableCellCoords(firstRow, lastCol));\n  var cellOffset = Handsontable.Dom.offset(cell);\n  var cellWidth = Handsontable.Dom.outerWidth(cell);\n  var cellEnd = cellOffset.left + cellWidth;\n\n  var viewportOffsetLeft = this.instance.wtScrollbars.vertical.getScrollPosition();\n  var viewportWitdh = this.instance.wtViewport.getViewportWidth();\n  var viewportEnd = viewportOffsetLeft + viewportWitdh;\n\n\n  return viewportEnd >= cellEnd;\n};\n\nfunction Walkontable(settings) {\n  var originalHeaders = [];\n\n  this.guid = 'wt_' + walkontableRandomString(); //this is the namespace for global events\n\n  //bootstrap from settings\n  if (settings.cloneSource) {\n    this.cloneSource = settings.cloneSource;\n    this.cloneOverlay = settings.cloneOverlay;\n    this.wtSettings = settings.cloneSource.wtSettings;\n    this.wtTable = new WalkontableTable(this, settings.table);\n    this.wtScroll = new WalkontableScroll(this);\n    this.wtViewport = settings.cloneSource.wtViewport;\n    this.wtEvent = new WalkontableEvent(this);\n    this.selections = this.cloneSource.selections;\n  }\n  else {\n    this.wtSettings = new WalkontableSettings(this, settings);\n    this.wtTable = new WalkontableTable(this, settings.table);\n    this.wtScroll = new WalkontableScroll(this);\n    this.wtViewport = new WalkontableViewport(this);\n    this.wtEvent = new WalkontableEvent(this);\n    this.selections = this.getSetting('selections');\n\n    this.wtScrollbars = new WalkontableScrollbars(this);\n  }\n\n  //find original headers\n  if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n    for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n      originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n    }\n    if (!this.getSetting('columnHeaders').length) {\n      this.update('columnHeaders', [function (column, TH) {\n        Handsontable.Dom.fastInnerText(TH, originalHeaders[column]);\n      }]);\n    }\n  }\n\n\n\n  this.drawn = false;\n  this.drawInterrupted = false;\n}\n\n/**\n * Force rerender of Walkontable\n * @param fastDraw {Boolean} When TRUE, try to refresh only the positions of borders without rerendering the data. It will only work if WalkontableTable.draw() does not force rendering anyway\n * @returns {Walkontable}\n */\nWalkontable.prototype.draw = function (fastDraw) {\n  this.drawInterrupted = false;\n  if (!fastDraw && !Handsontable.Dom.isVisible(this.wtTable.TABLE)) {\n    this.drawInterrupted = true; //draw interrupted because TABLE is not visible\n    return;\n  }\n\n  this.wtTable.draw(fastDraw);\n\n  return this;\n};\n\n/**\n * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n * if not set or set to false, returns TD from the master table.\n * @param {WalkontableCellCoords} coords\n * @param {Boolean} topmost\n * @returns {Object}\n */\nWalkontable.prototype.getCell = function (coords, topmost) {\n  if(!topmost) {\n    return this.wtTable.getCell(coords);\n  } else {\n    var fixedRows = this.wtSettings.getSetting('fixedRowsTop')\n      , fixedColumns = this.wtSettings.getSetting('fixedColumnsLeft');\n\n    if(coords.row < fixedRows && coords.col < fixedColumns) {\n      return this.wtScrollbars.corner.clone.wtTable.getCell(coords);\n    } else if(coords.row < fixedRows) {\n      return this.wtScrollbars.vertical.clone.wtTable.getCell(coords);\n    } else if (coords.col < fixedColumns) {\n      return this.wtScrollbars.horizontal.clone.wtTable.getCell(coords);\n    } else {\n      return this.wtTable.getCell(coords);\n    }\n  }\n};\n\nWalkontable.prototype.update = function (settings, value) {\n  return this.wtSettings.update(settings, value);\n};\n\n/**\n * Scroll the viewport to a row at the given index in the data source\n * @param row\n * @returns {Walkontable}\n */\nWalkontable.prototype.scrollVertical = function (row) {\n  this.wtScrollbars.vertical.scrollTo(row);\n  this.getSetting('onScrollVertically');\n  return this;\n};\n\n/**\n * Scroll the viewport to a column at the given index in the data source\n * @param row\n * @returns {Walkontable}\n */\nWalkontable.prototype.scrollHorizontal = function (column) {\n  this.wtScrollbars.horizontal.scrollTo(column);\n  this.getSetting('onScrollHorizontally');\n  return this;\n};\n\n/**\n * Scrolls the viewport to a cell (rerenders if needed)\n * @param {WalkontableCellCoords} coords\n * @returns {Walkontable}\n */\n\nWalkontable.prototype.scrollViewport = function (coords) {\n  this.wtScroll.scrollViewport(coords);\n  return this;\n};\n\nWalkontable.prototype.getViewport = function () {\n  return [\n    this.wtTable.getFirstVisibleRow(),\n    this.wtTable.getFirstVisibleColumn(),\n    this.wtTable.getLastVisibleRow(),\n    this.wtTable.getLastVisibleColumn()\n  ];\n};\n\nWalkontable.prototype.getSetting = function (key, param1, param2, param3, param4) {\n  return this.wtSettings.getSetting(key, param1, param2, param3, param4); //this is faster than .apply - https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n};\n\nWalkontable.prototype.hasSetting = function (key) {\n  return this.wtSettings.has(key);\n};\n\nWalkontable.prototype.destroy = function () {\n  this.wtScrollbars.destroy();\n  this.wtEvent && this.wtEvent.destroy();\n};\n\n/**\n * A overlay that renders ALL available rows & columns positioned on top of the original Walkontable instance and all other overlays.\n * Used for debugging purposes to see if the other overlays (that render only part of the rows & columns) are positioned correctly\n * @param instance\n * @constructor\n */\nfunction WalkontableDebugOverlay(instance) {\n  this.instance = instance;\n  this.init();\n  this.clone = this.makeClone('debug');\n  this.clone.wtTable.holder.style.opacity = 0.4;\n  this.clone.wtTable.holder.style.textShadow = '0 0 2px #ff0000';\n  this.lastTimeout = null;\n\n  Handsontable.Dom.addClass(this.clone.wtTable.holder.parentNode, 'wtDebugVisible');\n\n  /*var that = this;\n  var lastX = 0;\n  var lastY = 0;\n  var overlayContainer = that.clone.wtTable.holder.parentNode;\n\n  var eventManager = Handsontable.eventManager(instance);\n\n  eventManager.addEventListener(document.body, 'mousemove', function (event) {\n    if (!that.instance.wtTable.holder.parentNode) {\n      return; //removed from DOM\n    }\n    if ((event.clientX - lastX > -5 && event.clientX - lastX < 5) && (event.clientY - lastY > -5 && event.clientY - lastY < 5)) {\n      return; //ignore minor mouse movement\n    }\n    lastX = event.clientX;\n    lastY = event.clientY;\n    Handsontable.Dom.addClass(overlayContainer, 'wtDebugHidden');\n    Handsontable.Dom.removeClass(overlayContainer, 'wtDebugVisible');\n    clearTimeout(this.lastTimeout);\n    this.lastTimeout = setTimeout(function () {\n      Handsontable.Dom.removeClass(overlayContainer, 'wtDebugHidden');\n      Handsontable.Dom.addClass(overlayContainer, 'wtDebugVisible');\n    }, 1000);\n  });*/\n}\n\nWalkontableDebugOverlay.prototype = new WalkontableOverlay();\n\nWalkontableDebugOverlay.prototype.destroy = function () {\n  WalkontableOverlay.prototype.destroy.call(this);\n  clearTimeout(this.lastTimeout);\n};\n\nfunction WalkontableEvent(instance) {\n  var that = this;\n\n  var eventManager = Handsontable.eventManager(instance);\n\n  //reference to instance\n  this.instance = instance;\n\n  var dblClickOrigin = [null, null];\n  this.dblClickTimeout = [null, null];\n\n  var onMouseDown = function (event) {\n    var cell = that.parentCell(event.target);\n    if (Handsontable.Dom.hasClass(event.target, 'corner')) {\n      that.instance.getSetting('onCellCornerMouseDown', event, event.target);\n    }\n    else if (cell.TD) {\n      if (that.instance.hasSetting('onCellMouseDown')) {\n        that.instance.getSetting('onCellMouseDown', event, cell.coords, cell.TD, that.instance);\n      }\n    }\n\n    if (event.button !== 2) { //if not right mouse button\n      if (cell.TD) {\n        dblClickOrigin[0] = cell.TD;\n        clearTimeout(that.dblClickTimeout[0]);\n        that.dblClickTimeout[0] = setTimeout(function () {\n          dblClickOrigin[0] = null;\n        }, 1000);\n      }\n    }\n  };\n\n  var onTouchMove = function (event) {\n    that.instance.touchMoving = true;\n  };\n\n  var longTouchTimeout;\n\n  ///**\n  // * Update touch event target - if user taps on resize handle 'hit area', update the target to the cell itself\n  // * @param event\n  // */\n  /*\n  var adjustTapTarget = function (event) {\n    var currentSelection\n      , properTarget;\n\n    if(Handsontable.Dom.hasClass(event.target,'SelectionHandle')) {\n      if(that.instance.selections[0].cellRange) {\n        currentSelection = that.instance.selections[0].cellRange.highlight;\n\n        properTarget = that.instance.getCell(currentSelection, true);\n      }\n    }\n\n    if(properTarget) {\n      Object.defineProperty(event,'target',{\n        value: properTarget\n      });\n    }\n\n    return event;\n  };*/\n\n  var onTouchStart = function (event) {\n    var container = this;\n\n    eventManager.addEventListener(this, 'touchmove', onTouchMove);\n\n    //this.addEventListener(\"touchmove\", onTouchMove, false);\n\n    // touch-and-hold event\n    //longTouchTimeout = setTimeout(function () {\n    //  if(!that.instance.touchMoving) {\n    //    that.instance.longTouch = true;\n    //\n    //    var targetCoords = Handsontable.Dom.offset(event.target);\n    //    var contextMenuEvent = new MouseEvent('contextmenu', {\n    //      clientX: targetCoords.left + event.target.offsetWidth,\n    //      clientY: targetCoords.top + event.target.offsetHeight,\n    //      button: 2\n    //    });\n    //\n    //    that.instance.wtTable.holder.parentNode.parentNode.dispatchEvent(contextMenuEvent);\n    //  }\n    //},200);\n\n      // Prevent cell selection when scrolling with touch event - not the best solution performance-wise\n      that.checkIfTouchMove = setTimeout(function () {\n        if (that.instance.touchMoving == true) {\n          that.instance.touchMoving = void 0;\n\n          eventManager.removeEventListener(\"touchmove\", onTouchMove, false);\n\n          return;\n        } else {\n          //event = adjustTapTarget(event);\n\n          onMouseDown(event);\n        }\n      }, 30);\n\n    //eventManager.removeEventListener(that.instance.wtTable.holder, \"mousedown\", onMouseDown);\n  };\n\n  var lastMouseOver;\n  var onMouseOver = function (event) {\n    if (that.instance.hasSetting('onCellMouseOver')) {\n      var TABLE = that.instance.wtTable.TABLE;\n      var TD = Handsontable.Dom.closest(event.target, ['TD', 'TH'], TABLE);\n      if (TD && TD !== lastMouseOver && Handsontable.Dom.isChildOf(TD, TABLE)) {\n        lastMouseOver = TD;\n        that.instance.getSetting('onCellMouseOver', event, that.instance.wtTable.getCoords(TD), TD, that.instance);\n      }\n    }\n  };\n\n  /*  var lastMouseOut;\n   var onMouseOut = function (event) {\n   if (that.instance.hasSetting('onCellMouseOut')) {\n   var TABLE = that.instance.wtTable.TABLE;\n   var TD = Handsontable.Dom.closest(event.target, ['TD', 'TH'], TABLE);\n   if (TD && TD !== lastMouseOut && Handsontable.Dom.isChildOf(TD, TABLE)) {\n   lastMouseOut = TD;\n   if (TD.nodeName === 'TD') {\n   that.instance.getSetting('onCellMouseOut', event, that.instance.wtTable.getCoords(TD), TD);\n   }\n   }\n   }\n   };*/\n\n  var onMouseUp = function (event) {\n    if (event.button !== 2) { //if not right mouse button\n      var cell = that.parentCell(event.target);\n\n      if (cell.TD === dblClickOrigin[0] && cell.TD === dblClickOrigin[1]) {\n        if (Handsontable.Dom.hasClass(event.target, 'corner')) {\n          that.instance.getSetting('onCellCornerDblClick', event, cell.coords, cell.TD, that.instance);\n        }\n        else {\n          that.instance.getSetting('onCellDblClick', event, cell.coords, cell.TD, that.instance);\n        }\n\n        dblClickOrigin[0] = null;\n        dblClickOrigin[1] = null;\n      }\n      else if (cell.TD === dblClickOrigin[0]) {\n        dblClickOrigin[1] = cell.TD;\n        clearTimeout(that.dblClickTimeout[1]);\n        that.dblClickTimeout[1] = setTimeout(function () {\n          dblClickOrigin[1] = null;\n        }, 500);\n      }\n    }\n  };\n\n\n  var onTouchEnd = function (event) {\n    clearTimeout(longTouchTimeout);\n    //that.instance.longTouch == void 0;\n\n    event.preventDefault();\n\n    onMouseUp(event);\n\n    //eventManager.removeEventListener(that.instance.wtTable.holder, \"mouseup\", onMouseUp);\n  };\n\n  eventManager.addEventListener(this.instance.wtTable.holder, 'mousedown', onMouseDown);\n\n  eventManager.addEventListener(this.instance.wtTable.TABLE, 'mouseover', onMouseOver);\n\n  eventManager.addEventListener(this.instance.wtTable.holder, 'mouseup', onMouseUp);\n\n\n  if(this.instance.wtTable.holder.parentNode.parentNode && Handsontable.mobileBrowser) { // check if full HOT instance, or detached WOT AND run on mobile device\n    var classSelector = \".\" + this.instance.wtTable.holder.parentNode.className.split(\" \").join(\".\");\n\n    eventManager.addEventListener(this.instance.wtTable.holder.parentNode.parentNode, 'touchstart', function (event) {\n      that.instance.touchApplied = true;\n      if (Handsontable.Dom.isChildOf(event.target, classSelector)) {\n        onTouchStart.call(event.target, event);\n      }\n    });\n    eventManager.addEventListener(this.instance.wtTable.holder.parentNode.parentNode, 'touchend', function (event) {\n      that.instance.touchApplied = false;\n      if (Handsontable.Dom.isChildOf(event.target, classSelector)) {\n        onTouchEnd.call(event.target, event);\n      }\n    });\n\n    if(!that.instance.momentumScrolling) {\n      that.instance.momentumScrolling = {};\n    }\n    eventManager.addEventListener(this.instance.wtTable.holder.parentNode.parentNode, 'scroll', function (event) {\n      clearTimeout(that.instance.momentumScrolling._timeout);\n\n      if(!that.instance.momentumScrolling.ongoing) {\n        that.instance.getSetting('onBeforeTouchScroll');\n      }\n      that.instance.momentumScrolling.ongoing = true;\n\n      that.instance.momentumScrolling._timeout = setTimeout(function () {\n        if(!that.instance.touchApplied) {\n          that.instance.momentumScrolling.ongoing = false;\n\n          that.instance.getSetting('onAfterMomentumScroll');\n        }\n      },200);\n    });\n  }\n\n  eventManager.addEventListener(window, 'resize', function () {\n    that.instance.draw();\n  });\n\n  this.destroy = function () {\n    clearTimeout(this.dblClickTimeout[0]);\n    clearTimeout(this.dblClickTimeout[1]);\n\n    eventManager.clear();\n  };\n}\n\nWalkontableEvent.prototype.parentCell = function (elem) {\n  var cell = {};\n  var TABLE = this.instance.wtTable.TABLE;\n  var TD = Handsontable.Dom.closest(elem, ['TD', 'TH'], TABLE);\n\n  if (TD && Handsontable.Dom.isChildOf(TD, TABLE)) {\n    cell.coords = this.instance.wtTable.getCoords(TD);\n    cell.TD = TD;\n  } else if (Handsontable.Dom.hasClass(elem, 'wtBorder') && Handsontable.Dom.hasClass(elem, 'current')) {\n    cell.coords = this.instance.selections.current.cellRange.highlight; //selections.current is current selected cell\n    cell.TD = this.instance.wtTable.getCell(cell.coords);\n  } else if (Handsontable.Dom.hasClass(elem, 'wtBorder') && Handsontable.Dom.hasClass(elem, 'area')) {\n    if (this.instance.selections.area.cellRange) {\n      cell.coords = this.instance.selections.area.cellRange.to; //selections.area is area selected cells\n      cell.TD = this.instance.wtTable.getCell(cell.coords);\n    }\n  }\n\n  return cell;\n};\n\n\n\nfunction walkontableRangesIntersect() {\n  var from = arguments[0];\n  var to = arguments[1];\n  for (var i = 1, ilen = arguments.length / 2; i < ilen; i++) {\n    if (from <= arguments[2 * i + 1] && to >= arguments[2 * i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Generates a random hex string. Used as namespace for Walkontable instance events.\n * @return {String} - 16 character random string: \"92b1bfc74ec4\"\n */\nfunction walkontableRandomString() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n\n  return s4() + s4() + s4() + s4();\n}\n/**\n * http://notes.jetienne.com/2011/05/18/cancelRequestAnimFrame-for-paul-irish-requestAnimFrame.html\n */\nwindow.requestAnimFrame = (function () {\n  return  window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function (/* function */ callback, /* DOMElement */ element) {\n      return window.setTimeout(callback, 1000 / 60);\n    };\n})();\n\nwindow.cancelRequestAnimFrame = (function () {\n  return window.cancelAnimationFrame ||\n    window.webkitCancelRequestAnimationFrame ||\n    window.mozCancelRequestAnimationFrame ||\n    window.oCancelRequestAnimationFrame ||\n    window.msCancelRequestAnimationFrame ||\n    clearTimeout\n})();\n\n//http://snipplr.com/view/13523/\n//modified for speed\n//http://jsperf.com/getcomputedstyle-vs-style-vs-css/8\nif (!window.getComputedStyle) {\n  (function () {\n    var elem;\n\n    var styleObj = {\n      getPropertyValue: function getPropertyValue(prop) {\n        if (prop == 'float') prop = 'styleFloat';\n        return elem.currentStyle[prop.toUpperCase()] || null;\n      }\n    };\n\n    window.getComputedStyle = function (el) {\n      elem = el;\n      return styleObj;\n    }\n  })();\n}\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim\n */\nif (!String.prototype.trim) {\n  var trimRegex = /^\\s+|\\s+$/g;\n  String.prototype.trim = function () {\n    return this.replace(trimRegex, '');\n  };\n}\n/**\n * WalkontableRowFilter\n * @constructor\n */\nfunction WalkontableRowFilter(offset, total, countTH) {\n  this.offset = offset;\n  this.total = total;\n  this.countTH = countTH;\n}\n\nWalkontableRowFilter.prototype.offsetted = function (n) {\n  return n + this.offset;\n};\n\nWalkontableRowFilter.prototype.unOffsetted = function (n) {\n  return n - this.offset;\n};\n\nWalkontableRowFilter.prototype.renderedToSource = function (n) {\n  return this.offsetted(n);\n};\n\nWalkontableRowFilter.prototype.sourceToRendered = function (n) {\n  return this.unOffsetted(n);\n};\n\nWalkontableRowFilter.prototype.offsettedTH = function (n) {\n  return n - this.countTH;\n};\n\nWalkontableRowFilter.prototype.visibleColHeadedRowToSourceRow = function (n) {\n  return this.renderedToSource(this.offsettedTH(n));\n};\n\nWalkontableRowFilter.prototype.sourceRowToVisibleColHeadedRow = function (n) {\n  return this.unOffsettedTH(this.sourceToRendered(n));\n};\n\nfunction WalkontableScroll(instance) {\n  this.instance = instance;\n}\n\n/**\n * Scrolls viewport to a cell by minimum number of cells\n * @param {WalkontableCellCoords} coords\n */\nWalkontableScroll.prototype.scrollViewport = function (coords) {\n  if (!this.instance.drawn) {\n    return;\n  }\n\n  var totalRows = this.instance.getSetting('totalRows')\n    , totalColumns = this.instance.getSetting('totalColumns');\n\n  if (coords.row < 0 || coords.row > totalRows - 1) {\n    throw new Error('row ' + coords.row + ' does not exist');\n  }\n\n  if (coords.col < 0 || coords.col > totalColumns - 1) {\n    throw new Error('column ' + coords.col + ' does not exist');\n  }\n\n    if (coords.row > this.instance.wtTable.getLastVisibleRow()) {\n      this.instance.wtScrollbars.vertical.scrollTo(coords.row, true);\n    } else if (coords.row >= this.instance.getSetting('fixedRowsTop') && coords.row < this.instance.wtTable.getFirstVisibleRow()){\n      this.instance.wtScrollbars.vertical.scrollTo(coords.row);\n    }\n\n    if (coords.col >= this.instance.wtTable.getLastVisibleColumn()) {\n      this.instance.wtScrollbars.horizontal.scrollTo(coords.col, true);\n    } else if (coords.col >= this.instance.getSetting('fixedColumnsLeft') && coords.col < this.instance.wtTable.getFirstVisibleColumn()){\n      this.instance.wtScrollbars.horizontal.scrollTo(coords.col);\n    }\n\n  //}\n};\n\nfunction WalkontableCornerScrollbarNative(instance) {\n  this.instance = instance;\n  this.type = 'corner';\n  this.init();\n  this.clone = this.makeClone('corner');\n}\n\nWalkontableCornerScrollbarNative.prototype = new WalkontableOverlay();\n\nWalkontableCornerScrollbarNative.prototype.resetFixedPosition = function () {\n  if (!this.instance.wtTable.holder.parentNode) {\n    return; //removed from DOM\n  }\n  var elem = this.clone.wtTable.holder.parentNode;\n\n  if (this.scrollHandler === window) {\n    var box = this.instance.wtTable.holder.getBoundingClientRect();\n    var top = Math.ceil(box.top);\n    var left = Math.ceil(box.left);\n    var finalLeft\n      , finalTop;\n    var bottom = Math.ceil(box.bottom);\n    var right = Math.ceil(box.right);\n\n    if (left < 0 && (right - elem.offsetWidth) > 0) {\n      finalLeft = -left + 'px';\n    } else {\n      finalLeft = '0';\n    }\n\n    if (top < 0 && (bottom - elem.offsetHeight) > 0) {\n      finalTop = -top + \"px\";\n    } else {\n      finalTop = \"0\";\n    }\n  }\n  else if(!Handsontable.freezeOverlays) {\n    finalLeft = this.instance.wtScrollbars.horizontal.getScrollPosition() + \"px\";\n    finalTop = this.instance.wtScrollbars.vertical.getScrollPosition() + \"px\";\n  }\n\n  Handsontable.Dom.setOverlayPosition(elem, finalLeft, finalTop);\n\n  elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 4 + 'px';\n  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 4 + 'px';\n};\n\nfunction WalkontableHorizontalScrollbarNative(instance) {\n  this.instance = instance;\n  this.type = 'horizontal';\n  this.offset = 0;\n  this.init();\n  this.clone = this.makeClone('left');\n}\n\nWalkontableHorizontalScrollbarNative.prototype = new WalkontableOverlay();\n\n//resetFixedPosition (in future merge it with this.refresh?)\nWalkontableHorizontalScrollbarNative.prototype.resetFixedPosition = function () {\n  if (!this.instance.wtTable.holder.parentNode) {\n    return; //removed from DOM\n  }\n  var elem = this.clone.wtTable.holder.parentNode;\n\n  if (this.scrollHandler === window) {\n\n    var box = this.instance.wtTable.holder.getBoundingClientRect();\n    var left = Math.ceil(box.left);\n    var finalLeft\n      , finalTop;\n    var right = Math.ceil(box.right);\n\n    if (left < 0 && (right - elem.offsetWidth) > 0) {\n      finalLeft = -left + 'px';\n    } else {\n      finalLeft = '0';\n    }\n\n    finalTop = this.instance.wtTable.hider.style.top;\n  }\n  else if(!Handsontable.freezeOverlays) {\n    finalLeft = this.getScrollPosition() + \"px\";\n    finalTop = this.instance.wtTable.hider.style.top;\n  }\n\n  Handsontable.Dom.setOverlayPosition(elem, finalLeft, finalTop);\n\n  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 'px';\n  elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 4 + 'px';// + 4 + 'px';\n};\n\nWalkontableHorizontalScrollbarNative.prototype.refresh = function (fastDraw) {\n  this.applyToDOM();\n  WalkontableOverlay.prototype.refresh.call(this, fastDraw);\n};\n\nWalkontableHorizontalScrollbarNative.prototype.getScrollPosition = function () {\n  return Handsontable.Dom.getScrollLeft(this.scrollHandler);\n};\n\nWalkontableHorizontalScrollbarNative.prototype.setScrollPosition = function (pos) {\n  if (this.scrollHandler === window) {\n    window.scrollTo(pos, Handsontable.Dom.getWindowScrollTop());\n  } else {\n    this.scrollHandler.scrollLeft = pos;\n  }\n};\n\nWalkontableHorizontalScrollbarNative.prototype.onScroll = function () {\n  this.instance.getSetting('onScrollHorizontally');\n};\n\nWalkontableHorizontalScrollbarNative.prototype.sumCellSizes = function (from, length) {\n  var sum = 0;\n  while(from < length) {\n    sum += this.instance.wtTable.getStretchedColumnWidth(from) || this.instance.wtSettings.defaultColumnWidth;\n    from++;\n  }\n  return sum;\n};\n\n//applyToDOM (in future merge it with this.refresh?)\nWalkontableHorizontalScrollbarNative.prototype.applyToDOM = function () {\n  var total = this.instance.getSetting('totalColumns');\n  var headerSize = this.instance.wtViewport.getRowHeaderWidth();\n\n  this.fixedContainer.style.width = headerSize + this.sumCellSizes(0, total) + 'px';// + 4 + 'px';\n\n  if (typeof this.instance.wtViewport.columnsRenderCalculator.startPosition === 'number'){\n    this.fixed.style.left = this.instance.wtViewport.columnsRenderCalculator.startPosition + 'px';\n  }\n  else if (total === 0) {\n    this.fixed.style.left = '0';\n  } else {\n    throw  new Error('Incorrect value of the columnsRenderCalculator');\n  }\n  this.fixed.style.right = '';\n};\n\n/**\n * Scrolls horizontally to a column at the left edge of the viewport\n * @param sourceCol {Number}\n * @param beyondRendered {Boolean} if TRUE, scrolls according to the bottom edge (top edge is by default)\n */\nWalkontableHorizontalScrollbarNative.prototype.scrollTo = function (sourceCol, beyondRendered) {\n  var newX = this.getTableParentOffset();\n\n  if (beyondRendered) {\n    newX += this.sumCellSizes(0, sourceCol + 1);\n    newX -= this.instance.wtViewport.getViewportWidth()\n  }\n  else {\n    var fixedColumnsLeft = this.instance.getSetting('fixedColumnsLeft');\n    newX += this.sumCellSizes(fixedColumnsLeft, sourceCol);\n  }\n\n  this.setScrollPosition(newX);\n};\n\nWalkontableHorizontalScrollbarNative.prototype.getTableParentOffset = function () {\n  if (this.scrollHandler === window) {\n    return this.instance.wtTable.holderOffset.left;\n  }\n  else {\n    return 0;\n  }\n};\n\nfunction WalkontableVerticalScrollbarNative(instance) {\n  this.instance = instance;\n  this.type = 'vertical';\n  this.init();\n  this.clone = this.makeClone('top');\n}\n\nWalkontableVerticalScrollbarNative.prototype = new WalkontableOverlay();\n\n//resetFixedPosition (in future merge it with this.refresh?)\nWalkontableVerticalScrollbarNative.prototype.resetFixedPosition = function () {\n  if (!this.instance.wtTable.holder.parentNode) {\n    return; //removed from DOM\n  }\n  var elem = this.clone.wtTable.holder.parentNode;\n\n  if (this.scrollHandler === window) {\n    var box = this.instance.wtTable.holder.getBoundingClientRect();\n    var top = Math.ceil(box.top);\n    var finalLeft\n      , finalTop;\n    var bottom = Math.ceil(box.bottom);\n\n    finalLeft = this.instance.wtTable.hider.style.left;\n\n    if (top < 0 && (bottom - elem.offsetHeight) > 0) {\n      finalTop = -top + \"px\";\n    } else {\n      finalTop = \"0\";\n    }\n  }\n  else if(!Handsontable.freezeOverlays) {\n    finalTop = this.getScrollPosition() + \"px\";\n    finalLeft = this.instance.wtTable.hider.style.left;\n  }\n\n  Handsontable.Dom.setOverlayPosition(elem, finalLeft, finalTop);\n\n  if (this.instance.wtScrollbars.horizontal.scrollHandler === window) {\n    elem.style.width = this.instance.wtViewport.getWorkspaceActualWidth() + 'px';\n  }\n  else {\n    elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 'px';\n  }\n\n  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 4 + 'px';// + 4 + 'px';\n};\n\nWalkontableVerticalScrollbarNative.prototype.getScrollPosition = function () {\n  return Handsontable.Dom.getScrollTop(this.scrollHandler);\n};\n\nWalkontableVerticalScrollbarNative.prototype.setScrollPosition = function (pos) {\n  if (this.scrollHandler === window){\n    window.scrollTo(Handsontable.Dom.getWindowScrollLeft(), pos);\n  } else {\n    this.scrollHandler.scrollTop = pos;\n  }\n};\n\nWalkontableVerticalScrollbarNative.prototype.onScroll = function () {\n  this.instance.getSetting('onScrollVertically');\n};\n\nWalkontableVerticalScrollbarNative.prototype.sumCellSizes = function (from, length) {\n  var sum = 0;\n  while (from < length) {\n    sum += this.instance.wtTable.getRowHeight(from) || this.instance.wtSettings.settings.defaultRowHeight; //TODO optimize getSetting, because this is MUCH faster then getSetting\n    from++;\n  }\n  return sum;\n};\n\nWalkontableVerticalScrollbarNative.prototype.refresh = function (fastDraw) {\n  this.applyToDOM();\n  WalkontableOverlay.prototype.refresh.call(this, fastDraw);\n};\n\n//applyToDOM (in future merge it with this.refresh?)\nWalkontableVerticalScrollbarNative.prototype.applyToDOM = function () {\n  var total = this.instance.getSetting('totalRows');\n  var headerSize = this.instance.wtViewport.getColumnHeaderHeight();\n  this.fixedContainer.style.height = headerSize + this.sumCellSizes(0, total) +  'px';// + 4 + 'px'; //+4 is needed, otherwise vertical scroll appears in Chrome (window scroll mode) - maybe because of fill handle in last row or because of box shadow\n  if (typeof this.instance.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n    this.fixed.style.top = this.instance.wtViewport.rowsRenderCalculator.startPosition + 'px';\n  }\n  else if (total === 0) {\n    this.fixed.style.top = '0'; //can happen if there are 0 rows\n  }\n  else {\n    throw new Error(\"Incorrect value of the rowsRenderCalculator\");\n  }\n  this.fixed.style.bottom = '';\n};\n\n/**\n * Scrolls vertically to a row\n * @param sourceRow {Number}\n * @param bottomEdge {Boolean} if TRUE, scrolls according to the bottom edge (top edge is by default)\n */\nWalkontableVerticalScrollbarNative.prototype.scrollTo = function (sourceRow, bottomEdge) {\n  var newY = this.getTableParentOffset();\n  if (bottomEdge) {\n    newY += this.sumCellSizes(0, sourceRow + 1);\n    newY -= this.instance.wtViewport.getViewportHeight();\n  }\n  else {\n    var fixedRowsTop = this.instance.getSetting('fixedRowsTop');\n    newY += this.sumCellSizes(fixedRowsTop, sourceRow);\n  }\n\n  this.setScrollPosition(newY);\n};\n\nWalkontableVerticalScrollbarNative.prototype.getTableParentOffset = function () {\n  if (this.scrollHandler === window) {\n    return this.instance.wtTable.holderOffset.top;\n  }\n  else {\n    return 0;\n  }\n};\n\nfunction WalkontableScrollbars(instance) {\n  this.instance = instance;\n  instance.update('scrollbarWidth', Handsontable.Dom.getScrollbarWidth());\n  instance.update('scrollbarHeight', Handsontable.Dom.getScrollbarWidth());\n  this.vertical = new WalkontableVerticalScrollbarNative(instance);\n  this.horizontal = new WalkontableHorizontalScrollbarNative(instance);\n  this.corner = new WalkontableCornerScrollbarNative(instance);\n  if (instance.getSetting('debug')) {\n    this.debug = new WalkontableDebugOverlay(instance);\n  }\n  this.registerListeners();\n}\n\nWalkontableScrollbars.prototype.registerListeners = function () {\n  var that = this;\n\n  this.refreshAll = function refreshAll() {\n    if(!that.instance.drawn) {\n      return;\n    }\n\n    if (!that.instance.wtTable.holder.parentNode) {\n      //Walkontable was detached from DOM, but this handler was not removed\n      that.destroy();\n      return;\n    }\n\n    that.instance.draw(true);\n    that.vertical.onScroll();\n    that.horizontal.onScroll();\n  };\n\n  var eventManager = Handsontable.eventManager(that.instance);\n\n  eventManager.addEventListener(this.vertical.scrollHandler, 'scroll', this.refreshAll);\n  if (this.vertical.scrollHandler !== this.horizontal.scrollHandler) {\n    eventManager.addEventListener(this.horizontal.scrollHandler, 'scroll', this.refreshAll);\n  }\n\n  if (this.vertical.scrollHandler !== window && this.horizontal.scrollHandler !== window) {\n    eventManager.addEventListener(window,'scroll', this.refreshAll);\n  }\n};\n\nWalkontableScrollbars.prototype.destroy = function () {\n  var eventManager = Handsontable.eventManager(this.instance);\n\n  if (this.vertical) {\n    this.vertical.destroy();\n    eventManager.removeEventListener(this.vertical.scrollHandler,'scroll', this.refreshAll);\n  }\n  if (this.horizontal) {\n    this.horizontal.destroy();\n    eventManager.removeEventListener(this.horizontal.scrollHandler,'scroll', this.refreshAll);\n  }\n  eventManager.removeEventListener(window,'scroll', this.refreshAll);\n  this.corner && this.corner.destroy();\n  this.debug && this.debug.destroy();\n};\n\nWalkontableScrollbars.prototype.refresh = function (fastDraw) {\n  this.horizontal && this.horizontal.refresh(fastDraw);\n  this.vertical && this.vertical.refresh(fastDraw);\n  this.corner && this.corner.refresh(fastDraw);\n  this.debug && this.debug.refresh(fastDraw);\n};\n\nWalkontableScrollbars.prototype.applyToDOM = function () {\n  this.horizontal && this.horizontal.applyToDOM();\n  this.vertical && this.vertical.applyToDOM();\n};\n\nfunction WalkontableSelection(settings, cellRange) {\n  this.settings = settings;\n  this.cellRange = cellRange || null;\n  this.instanceBorders = {};\n}\n\n/**\n * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection borders per instance\n * @param {Walkontable} instance\n * @returns {WalkontableBorder}\n */\nWalkontableSelection.prototype.getBorder = function (instance) {\n  if (this.instanceBorders[instance.guid]) {\n    return this.instanceBorders[instance.guid];\n  }\n  //where is this returned?\n  this.instanceBorders[instance.guid] = new WalkontableBorder(instance, this.settings);\n};\n\n/**\n * Returns boolean information if selection is empty\n * @returns {boolean}\n */\nWalkontableSelection.prototype.isEmpty = function () {\n  return this.cellRange === null;\n};\n\n/**\n * Adds a cell coords to the selection\n * @param {WalkontableCellCoords} coords\n */\nWalkontableSelection.prototype.add = function (coords) {\n  if (this.isEmpty()) {\n    this.cellRange = new WalkontableCellRange(coords, coords, coords);\n  }\n  else {\n    this.cellRange.expand(coords);\n  }\n};\n\n/**\n * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean information about success\n * @param {WalkontableCellCoords} oldCoords\n * @param {WalkontableCellCoords} newCoords\n * @return {boolean}\n */\nWalkontableSelection.prototype.replace = function (oldCoords, newCoords) {\n  if (!this.isEmpty()) {\n    if (this.cellRange.from.isEqual(oldCoords)) {\n      this.cellRange.from = newCoords;\n\n      return true;\n    }\n    if (this.cellRange.to.isEqual(oldCoords)) {\n      this.cellRange.to = newCoords;\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nWalkontableSelection.prototype.clear = function () {\n  this.cellRange = null;\n};\n\n/**\n * Returns the top left (TL) and bottom right (BR) selection coordinates\n * @returns {Object}\n */\nWalkontableSelection.prototype.getCorners = function () {\n  var\n    topLeft = this.cellRange.getTopLeftCorner(),\n    bottomRight = this.cellRange.getBottomRightCorner();\n\n  return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n};\n\nWalkontableSelection.prototype.addClassAtCoords = function (instance, sourceRow, sourceColumn, cls) {\n  var TD = instance.wtTable.getCell(new WalkontableCellCoords(sourceRow, sourceColumn));\n\n  if (typeof TD === 'object') {\n    Handsontable.Dom.addClass(TD, cls);\n  }\n};\n\nWalkontableSelection.prototype.draw = function (instance) {\n  var\n    _this = this,\n    renderedRows = instance.wtTable.getRenderedRowsCount(),\n    renderedColumns = instance.wtTable.getRenderedColumnsCount(),\n    corners, sourceRow, sourceCol, border, TH;\n\n  if (this.isEmpty()) {\n    if (this.settings.border) {\n      border = this.getBorder(instance);\n\n      if (border) {\n        border.disappear();\n      }\n    }\n\n    return;\n  }\n\n  corners = this.getCorners();\n\n  for (var column = 0; column < renderedColumns; column++) {\n    sourceCol = instance.wtTable.columnFilter.renderedToSource(column);\n\n    if (sourceCol >= corners[1] && sourceCol <= corners[3]) {\n      TH = instance.wtTable.getColumnHeader(sourceCol);\n\n      if (TH && _this.settings.highlightColumnClassName) {\n        Handsontable.Dom.addClass(TH, _this.settings.highlightColumnClassName);\n      }\n    }\n  }\n\n  for (var row = 0; row < renderedRows; row++) {\n    sourceRow = instance.wtTable.rowFilter.renderedToSource(row);\n\n    if (sourceRow >= corners[0] && sourceRow <= corners[2]) {\n      TH = instance.wtTable.getRowHeader(sourceRow);\n\n      if (TH && _this.settings.highlightRowClassName) {\n        Handsontable.Dom.addClass(TH, _this.settings.highlightRowClassName);\n      }\n    }\n\n    for (var column = 0; column < renderedColumns; column++) {\n      sourceCol = instance.wtTable.columnFilter.renderedToSource(column);\n\n      if (sourceRow >= corners[0] && sourceRow <= corners[2] && sourceCol >= corners[1] && sourceCol <= corners[3]) {\n        // selected cell\n        if (_this.settings.className) {\n          _this.addClassAtCoords(instance, sourceRow, sourceCol, _this.settings.className);\n        }\n      }\n      else if (sourceRow >= corners[0] && sourceRow <= corners[2]) {\n        // selection is in this row\n        if (_this.settings.highlightRowClassName) {\n          _this.addClassAtCoords(instance, sourceRow, sourceCol, _this.settings.highlightRowClassName);\n        }\n      }\n      else if (sourceCol >= corners[1] && sourceCol <= corners[3]) {\n        // selection is in this column\n        if (_this.settings.highlightColumnClassName) {\n          _this.addClassAtCoords(instance, sourceRow, sourceCol, _this.settings.highlightColumnClassName);\n        }\n      }\n    }\n  }\n\n  instance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n\n  if (this.settings.border) {\n    border = this.getBorder(instance);\n\n    if (border) {\n      // warning! border.appear modifies corners!\n      border.appear(corners);\n    }\n  }\n};\n\nfunction WalkontableSettings(instance, settings) {\n  var that = this;\n  this.instance = instance;\n\n  //default settings. void 0 means it is required, null means it can be empty\n  this.defaults = {\n    table: void 0,\n    debug: false, //shows WalkontableDebugOverlay\n\n    //presentation mode\n    stretchH: 'none', //values: all, last, none\n    currentRowClassName: null,\n    currentColumnClassName: null,\n\n    //data source\n    data: void 0,\n    fixedColumnsLeft: 0,\n    fixedRowsTop: 0,\n    rowHeaders: function () {\n      return []\n    }, //this must be array of functions: [function (row, TH) {}]\n    columnHeaders: function () {\n      return []\n    }, //this must be array of functions: [function (column, TH) {}]\n    totalRows: void 0,\n    totalColumns: void 0,\n    cellRenderer: function (row, column, TD) {\n      var cellData = that.getSetting('data', row, column);\n      Handsontable.Dom.fastInnerText(TD, cellData === void 0 || cellData === null ? '' : cellData);\n    },\n    //columnWidth: 50,\n    columnWidth: function (col) {\n      return; //return undefined means use default size for the rendered cell content\n    },\n    rowHeight: function (row) {\n      return; //return undefined means use default size for the rendered cell content\n    },\n    defaultRowHeight: 23,\n    defaultColumnWidth: 50,\n    selections: null,\n    hideBorderOnMouseDownOver: false,\n    viewportRowCalculatorOverride: null,\n    viewportColumnCalculatorOverride: null,\n\n    //callbacks\n    onCellMouseDown: null,\n    onCellMouseOver: null,\n//    onCellMouseOut: null,\n    onCellDblClick: null,\n    onCellCornerMouseDown: null,\n    onCellCornerDblClick: null,\n    beforeDraw: null,\n    onDraw: null,\n    onBeforeDrawBorders: null,\n    onScrollVertically: null,\n    onScrollHorizontally: null,\n    onBeforeTouchScroll: null,\n    onAfterMomentumScroll: null,\n\n    //constants\n    scrollbarWidth: 10,\n    scrollbarHeight: 10,\n\n    renderAllRows: false,\n    groups: false\n  };\n\n  //reference to settings\n  this.settings = {};\n  for (var i in this.defaults) {\n    if (this.defaults.hasOwnProperty(i)) {\n      if (settings[i] !== void 0) {\n        this.settings[i] = settings[i];\n      }\n      else if (this.defaults[i] === void 0) {\n        throw new Error('A required setting \"' + i + '\" was not provided');\n      }\n      else {\n        this.settings[i] = this.defaults[i];\n      }\n    }\n  }\n}\n\n/**\n * generic methods\n */\n\nWalkontableSettings.prototype.update = function (settings, value) {\n  if (value === void 0) { //settings is object\n    for (var i in settings) {\n      if (settings.hasOwnProperty(i)) {\n        this.settings[i] = settings[i];\n      }\n    }\n  }\n  else { //if value is defined then settings is the key\n    this.settings[settings] = value;\n  }\n  return this.instance;\n};\n\nWalkontableSettings.prototype.getSetting = function (key, param1, param2, param3, param4) {\n  if (typeof this.settings[key] === 'function') {\n    return this.settings[key](param1, param2, param3, param4); //this is faster than .apply - https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips\n  }\n  else if (param1 !== void 0 && Array.isArray(this.settings[key])) { //perhaps this can be removed, it is only used in tests\n    return this.settings[key][param1];\n  }\n  else {\n    return this.settings[key];\n  }\n};\n\nWalkontableSettings.prototype.has = function (key) {\n  return !!this.settings[key]\n};\n\nfunction WalkontableTable(instance, table) {\n  //reference to instance\n  this.instance = instance;\n  this.TABLE = table;\n  Handsontable.Dom.removeTextNodes(this.TABLE);\n\n  //wtSpreader\n  var parent = this.TABLE.parentNode;\n  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {\n    var spreader = document.createElement('DIV');\n    spreader.className = 'wtSpreader';\n    if (parent) {\n      parent.insertBefore(spreader, this.TABLE); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n    }\n    spreader.appendChild(this.TABLE);\n  }\n  this.spreader = this.TABLE.parentNode;\n\n  //wtHider\n  parent = this.spreader.parentNode;\n  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {\n    var hider = document.createElement('DIV');\n    hider.className = 'wtHider';\n    if (parent) {\n      parent.insertBefore(hider, this.spreader); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n    }\n    hider.appendChild(this.spreader);\n  }\n  this.hider = this.spreader.parentNode;\n  this.hiderStyle = this.hider.style;\n  this.hiderStyle.position = 'relative';\n\n  //wtHolder\n  parent = this.hider.parentNode;\n  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {\n    var holder = document.createElement('DIV');\n    holder.style.position = 'relative';\n    holder.className = 'wtHolder';\n\n    if(!instance.cloneSource) {\n      holder.className += ' ht_master';\n    }\n\n    if (parent) {\n      parent.insertBefore(holder, this.hider); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n    }\n    holder.appendChild(this.hider);\n  }\n  this.holder = this.hider.parentNode;\n\n  if (!this.isWorkingOnClone()) {\n    this.holder.parentNode.style.position = \"relative\";\n  }\n\n  //bootstrap from settings\n  this.TBODY = this.TABLE.getElementsByTagName('TBODY')[0];\n  if (!this.TBODY) {\n    this.TBODY = document.createElement('TBODY');\n    this.TABLE.appendChild(this.TBODY);\n  }\n  this.THEAD = this.TABLE.getElementsByTagName('THEAD')[0];\n  if (!this.THEAD) {\n    this.THEAD = document.createElement('THEAD');\n    this.TABLE.insertBefore(this.THEAD, this.TBODY);\n  }\n  this.COLGROUP = this.TABLE.getElementsByTagName('COLGROUP')[0];\n  if (!this.COLGROUP) {\n    this.COLGROUP = document.createElement('COLGROUP');\n    this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n  }\n\n  if (this.instance.getSetting('columnHeaders').length) {\n    if (!this.THEAD.childNodes.length) {\n      var TR = document.createElement('TR');\n      this.THEAD.appendChild(TR);\n    }\n  }\n\n  this.colgroupChildrenLength = this.COLGROUP.childNodes.length;\n  this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;\n  this.tbodyChildrenLength = this.TBODY.childNodes.length;\n\n  this.rowFilter = null;\n  this.columnFilter = null;\n}\n\nWalkontableTable.prototype.isWorkingOnClone = function () {\n  return !!this.instance.cloneSource;\n};\n\n/**\n * Redraws the table\n * @param fastDraw {Boolean} If TRUE, will try to avoid full redraw and only update the border positions. If FALSE or UNDEFINED, will perform a full redraw\n * @returns {WalkontableTable}\n */\nWalkontableTable.prototype.draw = function (fastDraw) {\n  if (!this.isWorkingOnClone()) {\n    this.holderOffset = Handsontable.Dom.offset(this.holder);\n    fastDraw = this.instance.wtViewport.createRenderCalculators(fastDraw);\n  }\n\n  if (!fastDraw) {\n    if (this.isWorkingOnClone()) {\n      this.tableOffset = this.instance.cloneSource.wtTable.tableOffset;\n    }\n    else {\n      this.tableOffset = Handsontable.Dom.offset(this.TABLE);\n    }\n    var startRow;\n    if (this.instance.cloneOverlay instanceof WalkontableDebugOverlay\n      || this.instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative\n      || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {\n      startRow = 0;\n    }\n    else {\n      startRow = this.instance.wtViewport.rowsRenderCalculator.startRow;\n    }\n\n\n    var startColumn;\n    if (this.instance.cloneOverlay instanceof WalkontableDebugOverlay\n    || this.instance.cloneOverlay instanceof  WalkontableHorizontalScrollbarNative\n    || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {\n      startColumn = 0;\n    } else {\n      startColumn = this.instance.wtViewport.columnsRenderCalculator.startColumn;\n    }\n\n    this.rowFilter = new WalkontableRowFilter(\n      startRow,\n      this.instance.getSetting('totalRows'),\n      this.instance.getSetting('columnHeaders').length\n    );\n    this.columnFilter = new WalkontableColumnFilter(\n      startColumn,\n      this.instance.getSetting('totalColumns'),\n      this.instance.getSetting('rowHeaders').length\n    );\n    this._doDraw(); //creates calculator after draw\n  }\n  else {\n    if (!this.isWorkingOnClone()) {\n      this.instance.wtViewport.createVisibleCalculators(); //in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n    }\n    this.instance.wtScrollbars && this.instance.wtScrollbars.refresh(true);\n  }\n\n  this.refreshSelections(fastDraw);\n\n  if (!this.isWorkingOnClone()) {\n    this.instance.wtScrollbars.vertical.resetFixedPosition();\n    this.instance.wtScrollbars.horizontal.resetFixedPosition();\n    this.instance.wtScrollbars.corner.resetFixedPosition();\n  }\n\n  this.instance.drawn = true;\n  return this;\n};\n\nWalkontableTable.prototype._doDraw = function () {\n  var wtRenderer = new WalkontableTableRenderer(this);\n  wtRenderer.render();\n};\n\nWalkontableTable.prototype.removeClassFromCells = function (className) {\n  var nodes = this.TABLE.querySelectorAll('.' + className);\n  for (var i = 0, ilen = nodes.length; i < ilen; i++) {\n    Handsontable.Dom.removeClass(nodes[i], className);\n  }\n};\n\nWalkontableTable.prototype.refreshSelections = function (fastDraw) {\n  var i, len;\n\n  if (!this.instance.selections) {\n    return;\n  }\n  len = this.instance.selections.length;\n\n  if (fastDraw) {\n    for (i = 0; i < len; i++) {\n      // there was no rerender, so we need to remove classNames by ourselves\n      if (this.instance.selections[i].settings.className) {\n        this.removeClassFromCells(this.instance.selections[i].settings.className);\n      }\n      if (this.instance.selections[i].settings.highlightRowClassName) {\n        this.removeClassFromCells(this.instance.selections[i].settings.highlightRowClassName);\n      }\n      if (this.instance.selections[i].settings.highlightColumnClassName) {\n        this.removeClassFromCells(this.instance.selections[i].settings.highlightColumnClassName);\n      }\n    }\n  }\n  for (i = 0; i < len; i++) {\n    this.instance.selections[i].draw(this.instance, fastDraw);\n  }\n};\n\n/**\n * getCell\n * @param {WalkontableCellCoords} coords\n * @return {Object} HTMLElement on success or {Number} one of the exit codes on error:\n *  -1 row before viewport\n *  -2 row after viewport\n *\n */\nWalkontableTable.prototype.getCell = function (coords) {\n  if (this.isRowBeforeRenderedRows(coords.row)) {\n    return -1; //row before rendered rows\n  }\n  else if (this.isRowAfterRenderedRows(coords.row)) {\n    return -2; //row after rendered rows\n  }\n\n    var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(coords.row)];\n\n    if (TR) {\n      return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(coords.col)];\n    }\n};\n\n/**\n * getColumnHeader\n * @param col\n * @return {Object} HTMLElement on success or undefined on error\n *\n */\nWalkontableTable.prototype.getColumnHeader = function(col) {\n  var THEAD = this.THEAD.childNodes[0];\n  if (THEAD) {\n    return THEAD.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n  }\n};\n\n/**\n * getRowHeader\n * @param row\n * @return {Object} HTMLElement on success or {Number} one of the exit codes on error:\n *  null table doesn't have row headers\n *\n */\nWalkontableTable.prototype.getRowHeader = function(row) {\n  if(this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) == 0) {\n    return null;\n  }\n\n  var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n  if (TR) {\n    return TR.childNodes[0];\n  }\n};\n\n/**\n * Returns cell coords object for a given TD\n * @param TD\n * @returns {WalkontableCellCoords}\n */\nWalkontableTable.prototype.getCoords = function (TD) {\n  var TR = TD.parentNode;\n  var row = Handsontable.Dom.index(TR);\n  if (TR.parentNode === this.THEAD) {\n    row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n  }\n  else {\n    row = this.rowFilter.renderedToSource(row);\n  }\n\n  return new WalkontableCellCoords(\n    row,\n    this.columnFilter.visibleRowHeadedColumnToSourceColumn(TD.cellIndex)\n  );\n};\n\nWalkontableTable.prototype.getTrForRow = function (row) {\n  return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n};\n\nWalkontableTable.prototype.getFirstRenderedRow = function () {\n  return this.instance.wtViewport.rowsRenderCalculator.startRow;\n};\n\nWalkontableTable.prototype.getFirstVisibleRow = function () {\n  return this.instance.wtViewport.rowsVisibleCalculator.startRow;\n};\n\nWalkontableTable.prototype.getFirstRenderedColumn = function () {\n  return this.instance.wtViewport.columnsRenderCalculator.startColumn;\n};\n\n//returns -1 if no column is visible\nWalkontableTable.prototype.getFirstVisibleColumn = function () {\n  return this.instance.wtViewport.columnsVisibleCalculator.startColumn;\n};\n\n//returns -1 if no row is visible\nWalkontableTable.prototype.getLastRenderedRow = function () {\n  return this.instance.wtViewport.rowsRenderCalculator.endRow;\n};\n\nWalkontableTable.prototype.getLastVisibleRow = function () {\n  return this.instance.wtViewport.rowsVisibleCalculator.endRow;\n};\n\nWalkontableTable.prototype.getLastRenderedColumn = function () {\n  return this.instance.wtViewport.columnsRenderCalculator.endColumn;\n};\n\n//returns -1 if no column is visible\nWalkontableTable.prototype.getLastVisibleColumn = function () {\n  return this.instance.wtViewport.columnsVisibleCalculator.endColumn;\n};\n\nWalkontableTable.prototype.isRowBeforeRenderedRows = function (r) {\n  return (this.rowFilter.sourceToRendered(r) < 0 && r >= 0);\n};\n\nWalkontableTable.prototype.isRowAfterViewport = function (r) {\n  return (r > this.getLastVisibleRow());\n};\n\nWalkontableTable.prototype.isRowAfterRenderedRows = function (r) {\n  return (r > this.getLastRenderedRow());\n};\n\nWalkontableTable.prototype.isColumnBeforeViewport = function (c) {\n  return (this.columnFilter.sourceToRendered(c) < 0 && c >= 0);\n};\n\nWalkontableTable.prototype.isColumnAfterViewport = function (c) {\n  return (c > this.getLastVisibleColumn());\n};\n\nWalkontableTable.prototype.isLastRowFullyVisible = function () {\n  return (this.getLastVisibleRow() === this.getLastRenderedRow());\n};\n\nWalkontableTable.prototype.isLastColumnFullyVisible = function () {\n  return (this.getLastVisibleColumn() === this.getLastRenderedColumn);\n};\n\nWalkontableTable.prototype.getRenderedColumnsCount = function () {\n  if (this.instance.cloneOverlay instanceof WalkontableDebugOverlay) {\n    return this.instance.getSetting('totalColumns');\n  }\n  else if (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {\n    return this.instance.getSetting('fixedColumnsLeft');\n  }\n  else {\n    return this.instance.wtViewport.columnsRenderCalculator.count;\n  }\n};\n\nWalkontableTable.prototype.getRenderedRowsCount = function () {\n  if (this.instance.cloneOverlay instanceof WalkontableDebugOverlay) {\n    return this.instance.getSetting('totalRows');\n  }\n  else if (this.instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {\n    return this.instance.getSetting('fixedRowsTop');\n  }\n  return this.instance.wtViewport.rowsRenderCalculator.count;\n};\n\nWalkontableTable.prototype.getVisibleRowsCount = function () {\n  return this.instance.wtViewport.rowsVisibleCalculator.count;\n};\n\nWalkontableTable.prototype.allRowsInViewport = function () {\n  return this.instance.getSetting('totalRows') == this.getVisibleRowsCount();\n};\n\n/**\n * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n * @param {Number} sourceRow\n * @return {Number}\n */\nWalkontableTable.prototype.getRowHeight = function (sourceRow) {\n  var height = this.instance.wtSettings.settings.rowHeight(sourceRow);\n  var oversizedHeight = this.instance.wtViewport.oversizedRows[sourceRow];\n  if (oversizedHeight !== void 0) {\n    height = height ? Math.max(height, oversizedHeight) : oversizedHeight;\n  }\n  return height;\n};\n\n\nWalkontableTable.prototype.getVisibleColumnsCount = function () {\n  return this.instance.wtViewport.columnsVisibleCalculator.count;\n};\n\n\nWalkontableTable.prototype.allColumnsInViewport = function () {\n  return this.instance.getSetting('totalColumns') == this.getVisibleColumnsCount();\n};\n\n\n\nWalkontableTable.prototype.getColumnWidth = function (sourceColumn) {\n  var width = this.instance.wtSettings.settings.columnWidth;\n  if(typeof width === 'function') {\n    width = width(sourceColumn);\n  } else if(typeof width === 'object') {\n    width = width[sourceColumn];\n  }\n\n  var oversizedWidth = this.instance.wtViewport.oversizedCols[sourceColumn];\n  if (oversizedWidth !== void 0) {\n    width = width ? Math.max(width, oversizedWidth) : oversizedWidth;\n  }\n  return width;\n};\n\nWalkontableTable.prototype.getStretchedColumnWidth = function (sourceColumn) {\n  var allColumns = this.instance.getSetting('totalColumns');\n  var width = this.getColumnWidth(sourceColumn) || this.instance.wtSettings.settings.defaultColumnWidth;\n\n  if(this.instance.wtViewport.columnsRenderCalculator) {\n    if (this.instance.wtViewport.columnsRenderCalculator.stretchAllRatio != 0) {\n      width = width * this.instance.wtViewport.columnsRenderCalculator.stretchAllRatio;\n    } else if (this.instance.wtViewport.columnsRenderCalculator.stretchLastWidth != 0) {\n      if (sourceColumn == allColumns - 1) {\n        width = this.instance.wtViewport.columnsRenderCalculator.stretchLastWidth;\n      }\n    }\n  }\n  return width;\n};\n\n\nfunction WalkontableTableRenderer(wtTable) {\n  this.wtTable = wtTable;\n  this.instance = wtTable.instance;\n  this.rowFilter = wtTable.rowFilter;\n  this.columnFilter = wtTable.columnFilter;\n\n  this.TABLE = wtTable.TABLE;\n  this.THEAD = wtTable.THEAD;\n  this.TBODY = wtTable.TBODY;\n  this.COLGROUP = wtTable.COLGROUP;\n\n  this.utils = WalkontableTableRenderer.utils;\n\n}\n\nWalkontableTableRenderer.prototype.render = function () {\n  if (!this.wtTable.isWorkingOnClone()) {\n    this.instance.getSetting('beforeDraw', true);\n  }\n\n  this.rowHeaders = this.instance.getSetting('rowHeaders');\n  this.rowHeaderCount = this.rowHeaders.length;\n  this.fixedRowsTop = this.instance.getSetting('fixedRowsTop');\n  this.columnHeaders = this.instance.getSetting('columnHeaders');\n  this.columnHeaderCount = this.columnHeaders.length;\n\n  var visibleColIndex\n    , totalRows = this.instance.getSetting('totalRows')\n    , totalColumns = this.instance.getSetting('totalColumns')\n    , displayTds\n    , adjusted = false\n    , workspaceWidth\n    , cloneLimit = this.wtTable.getRenderedRowsCount();\n\n  if (totalColumns > 0) {\n    this.adjustAvailableNodes();\n    adjusted = true;\n\n    this.renderColGroups();\n\n    this.renderColumnHeaders();\n\n    displayTds = this.wtTable.getRenderedColumnsCount();\n\n    //Render table rows\n    this.renderRows(totalRows, cloneLimit, displayTds);\n\n    if (!this.wtTable.isWorkingOnClone()) {\n      workspaceWidth = this.instance.wtViewport.getWorkspaceWidth();\n      this.instance.wtViewport.containerWidth = null;\n    }\n\n    this.adjustColumnWidths(displayTds);\n  }\n\n  if (!adjusted) {\n    this.adjustAvailableNodes();\n  }\n\n  this.removeRedundantRows(cloneLimit);\n\n  if (!this.wtTable.isWorkingOnClone()) {\n    this.markOversizedRows();\n\n    this.instance.wtViewport.createVisibleCalculators();\n\n    this.instance.wtScrollbars.applyToDOM();\n\n    if (workspaceWidth !== this.instance.wtViewport.getWorkspaceWidth()) {\n      //workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n      this.instance.wtViewport.containerWidth = null;\n\n      var firstRendered = this.wtTable.getFirstRenderedColumn();\n      var lastRendered = this.wtTable.getLastRenderedColumn();\n\n      for (var i = firstRendered ; i < lastRendered; i++) {\n        var width = this.wtTable.getStretchedColumnWidth(i);\n        var renderedIndex = this.columnFilter.sourceToRendered(i);\n        this.COLGROUP.childNodes[renderedIndex + this.rowHeaderCount].style.width = width + 'px';\n      }\n    }\n\n    this.instance.wtScrollbars.refresh(false);\n\n    this.instance.getSetting('onDraw', true);\n  }\n\n};\n\nWalkontableTableRenderer.prototype.removeRedundantRows = function (renderedRowsCount) {\n  while (this.wtTable.tbodyChildrenLength > renderedRowsCount) {\n    this.TBODY.removeChild(this.TBODY.lastChild);\n    this.wtTable.tbodyChildrenLength--;\n  }\n};\n\nWalkontableTableRenderer.prototype.renderRows = function (totalRows, cloneLimit, displayTds) {\n  var lastTD, TR;\n  var visibleRowIndex = 0;\n  var sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);\n  var isWorkingOnClone = this.wtTable.isWorkingOnClone();\n\n  while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {\n    if (visibleRowIndex > 1000) {\n      throw new Error('Security brake: Too much TRs. Please define height for your table, which will enforce scrollbars.');\n    }\n\n    if (cloneLimit !== void 0 && visibleRowIndex === cloneLimit) {\n      break; //we have as much rows as needed for this clone\n    }\n\n    TR = this.getOrCreateTrForRow(visibleRowIndex, TR);\n\n    //Render row headers\n    this.renderRowHeaders(sourceRowIndex, TR);\n\n    this.adjustColumns(TR, displayTds + this.rowHeaderCount);\n\n    lastTD = this.renderCells(sourceRowIndex, TR, displayTds);\n\n    //after last column is rendered, check if last cell is fully displayed\n    if (!isWorkingOnClone) {\n      this.resetOversizedRow(sourceRowIndex);\n    }\n\n\n    if (TR.firstChild) {\n      var height = this.instance.wtTable.getRowHeight(sourceRowIndex); //if I have 2 fixed columns with one-line content and the 3rd column has a multiline content, this is the way to make sure that the overlay will has same row height\n      if (height) {\n        TR.firstChild.style.height = height + 'px';\n      }\n      else {\n        TR.firstChild.style.height = '';\n      }\n    }\n\n    visibleRowIndex++;\n\n    sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);\n  }\n};\n\nWalkontableTableRenderer.prototype.resetOversizedRow = function (sourceRow) {\n  if (this.instance.wtViewport.oversizedRows && this.instance.wtViewport.oversizedRows[sourceRow]) {\n    this.instance.wtViewport.oversizedRows[sourceRow] = void 0;  //void 0 is faster than delete, see http://jsperf.com/delete-vs-undefined-vs-null/16\n  }\n};\n\nWalkontableTableRenderer.prototype.markOversizedRows = function () {\n  var previousRowHeight\n    , trInnerHeight\n    , sourceRowIndex\n    , currentTr;\n\n  var rowCount = this.instance.wtTable.TBODY.childNodes.length;\n  while (rowCount) {\n    rowCount--;\n    sourceRowIndex = this.instance.wtTable.rowFilter.renderedToSource(rowCount);\n    previousRowHeight = this.instance.wtTable.getRowHeight(sourceRowIndex);\n    currentTr = this.instance.wtTable.getTrForRow(sourceRowIndex);\n\n    trInnerHeight = Handsontable.Dom.innerHeight(currentTr) - 1;\n\n    if ((!previousRowHeight && this.instance.wtSettings.settings.defaultRowHeight < trInnerHeight || previousRowHeight < trInnerHeight)) {\n      this.instance.wtViewport.oversizedRows[sourceRowIndex] = trInnerHeight;\n    }\n  }\n\n};\n\nWalkontableTableRenderer.prototype.renderCells = function (sourceRowIndex, TR, displayTds) {\n  var TD, sourceColIndex;\n\n  for (var visibleColIndex = 0; visibleColIndex < displayTds; visibleColIndex++) {\n    sourceColIndex = this.columnFilter.renderedToSource(visibleColIndex);\n    if (visibleColIndex === 0) {\n      TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];\n    }\n    else {\n      TD = TD.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes\n    }\n\n    //If the number of headers has been reduced, we need to replace excess TH with TD\n    if (TD.nodeName == 'TH') {\n      TD = this.utils.replaceThWithTd(TD, TR);\n    }\n\n    if (!Handsontable.Dom.hasClass(TD, 'hide')) {\n      TD.className = '';\n    }\n\n    TD.removeAttribute('style');\n\n    this.instance.wtSettings.settings.cellRenderer(sourceRowIndex, sourceColIndex, TD);\n\n  }\n\n  return TD;\n};\n\nWalkontableTableRenderer.prototype.adjustColumnWidths = function (displayTds) {\n  var width;\n  this.instance.wtViewport.columnsRenderCalculator.refreshStretching(this.instance.wtViewport.getViewportWidth());\n\n  for (var renderedColIndex = 0; renderedColIndex < displayTds; renderedColIndex++) {\n    width = this.wtTable.getStretchedColumnWidth(this.columnFilter.renderedToSource(renderedColIndex));\n      this.COLGROUP.childNodes[renderedColIndex + this.rowHeaderCount].style.width = width + 'px';\n  }\n};\n\nWalkontableTableRenderer.prototype.appendToTbody = function (TR) {\n  this.TBODY.appendChild(TR);\n  this.wtTable.tbodyChildrenLength++;\n};\n\nWalkontableTableRenderer.prototype.getOrCreateTrForRow = function (rowIndex, currentTr) {\n  var TR;\n\n  if (rowIndex >= this.wtTable.tbodyChildrenLength) {\n    TR = this.createRow();\n    this.appendToTbody(TR);\n  } else if (rowIndex === 0) {\n    TR = this.TBODY.firstChild;\n  } else {\n    TR = currentTr.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes\n  }\n\n  return TR;\n};\n\nWalkontableTableRenderer.prototype.createRow = function () {\n  var TR = document.createElement('TR');\n  for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {\n    TR.appendChild(document.createElement('TH'));\n  }\n\n  return TR;\n};\n\nWalkontableTableRenderer.prototype.renderRowHeader = function(row, col, TH){\n  TH.className = '';\n  TH.removeAttribute('style');\n  this.rowHeaders[col](row, TH, col);\n};\n\nWalkontableTableRenderer.prototype.renderRowHeaders = function (row, TR) {\n  for (var TH = TR.firstChild, visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {\n\n    //If the number of row headers increased we need to create TH or replace an existing TD node with TH\n    if (!TH) {\n      TH = document.createElement('TH');\n      TR.appendChild(TH);\n    } else if (TH.nodeName == 'TD') {\n      TH = this.utils.replaceTdWithTh(TH, TR);\n    }\n\n    this.renderRowHeader(row, visibleColIndex, TH);\n    TH = TH.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes\n  }\n};\n\nWalkontableTableRenderer.prototype.adjustAvailableNodes = function () {\n  //adjust COLGROUP\n  this.adjustColGroups();\n\n  //adjust THEAD\n  this.adjustThead();\n};\n\nWalkontableTableRenderer.prototype.renderColumnHeaders = function () {\n  if (!this.columnHeaderCount) {\n    return;\n  }\n\n  var columnCount = this.wtTable.getRenderedColumnsCount(),\n    TR,\n    renderedColumnIndex;\n\n  for (var i = 0; i < this.columnHeaderCount; i++) {\n    TR = this.getTrForColumnHeaders(i);\n\n    for (renderedColumnIndex = (-1) * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {\n        var sourceCol = this.columnFilter.renderedToSource(renderedColumnIndex);\n        this.renderColumnHeader(i, sourceCol, TR.childNodes[renderedColumnIndex + this.rowHeaderCount]);\n      }\n  }\n};\n\nWalkontableTableRenderer.prototype.adjustColGroups = function () {\n  var columnCount = this.wtTable.getRenderedColumnsCount();\n\n  //adjust COLGROUP\n  while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {\n    this.COLGROUP.appendChild(document.createElement('COL'));\n    this.wtTable.colgroupChildrenLength++;\n  }\n  while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {\n    this.COLGROUP.removeChild(this.COLGROUP.lastChild);\n    this.wtTable.colgroupChildrenLength--;\n  }\n};\n\nWalkontableTableRenderer.prototype.adjustThead = function () {\n  var columnCount = this.wtTable.getRenderedColumnsCount();\n  var TR = this.THEAD.firstChild;\n  if (this.columnHeaders.length) {\n\n    for (var i = 0, columnHeadersLength = this.columnHeaders.length; i < columnHeadersLength; i++) {\n      TR = this.THEAD.childNodes[i];\n      if (!TR) {\n        TR = document.createElement('TR');\n        this.THEAD.appendChild(TR);\n      }\n      this.theadChildrenLength = TR.childNodes.length;\n      while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {\n        TR.appendChild(document.createElement('TH'));\n        this.theadChildrenLength++;\n      }\n      while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {\n        TR.removeChild(TR.lastChild);\n        this.theadChildrenLength--;\n      }\n    }\n\n    var theadChildrenLength = this.THEAD.childNodes.length;\n    if(theadChildrenLength > this.columnHeaders.length) {\n      for(var i = this.columnHeaders.length; i < theadChildrenLength; i++ ) {\n        this.THEAD.removeChild(this.THEAD.lastChild);\n      }\n    }\n  }\n\n  else if (TR) {\n    Handsontable.Dom.empty(TR);\n  }\n};\n\nWalkontableTableRenderer.prototype.getTrForColumnHeaders = function (index) {\n  var TR = this.THEAD.childNodes[index];\n//  if (this.rowHeaderCount) {\n//    for(var i = 0; i < this.rowHeaderCount; i++) {\n//      this.renderRowHeaders(i - this.rowHeaderCount, TR);\n//    }\n//  }\n\n  return TR;\n};\n\nWalkontableTableRenderer.prototype.renderColumnHeader = function (row, col, TH) {\n  TH.className = '';\n  TH.removeAttribute('style');\n  return this.columnHeaders[row](col, TH, row);\n};\n\nWalkontableTableRenderer.prototype.renderColGroups = function () {\n  for (var colIndex = 0; colIndex < this.wtTable.colgroupChildrenLength; colIndex++) {\n    if (colIndex < this.rowHeaderCount) {\n      Handsontable.Dom.addClass(this.COLGROUP.childNodes[colIndex], 'rowHeader');\n    }\n    else {\n      Handsontable.Dom.removeClass(this.COLGROUP.childNodes[colIndex], 'rowHeader');\n    }\n  }\n};\n\nWalkontableTableRenderer.prototype.adjustColumns = function (TR, desiredCount) {\n  var count = TR.childNodes.length;\n  while (count < desiredCount) {\n    var TD = document.createElement('TD');\n    TR.appendChild(TD);\n    count++;\n  }\n  while (count > desiredCount) {\n    TR.removeChild(TR.lastChild);\n    count--;\n  }\n};\n\nWalkontableTableRenderer.prototype.removeRedundantColumns = function (renderedColumnsCount) {\n  while (this.wtTable.tbodyChildrenLength > renderedColumnsCount) {\n    this.TBODY.removeChild(this.TBODY.lastChild);\n    this.wtTable.tbodyChildrenLength--;\n  }\n};\n\n/*\n Helper functions, which does not have any side effects\n */\nWalkontableTableRenderer.utils = {};\n\nWalkontableTableRenderer.utils.replaceTdWithTh = function (TD, TR) {\n  var TH;\n  TH = document.createElement('TH');\n  TR.insertBefore(TH, TD);\n  TR.removeChild(TD);\n\n  return TH;\n};\n\nWalkontableTableRenderer.utils.replaceThWithTd = function (TH, TR) {\n  var TD = document.createElement('TD');\n  TR.insertBefore(TD, TH);\n  TR.removeChild(TH);\n\n  return TD;\n};\n\n\n\nfunction WalkontableViewport(instance) {\n  this.instance = instance;\n  this.oversizedRows = [];\n  this.oversizedCols = [];\n\n  var that = this;\n\n  var eventManager = Handsontable.eventManager(instance);\n  eventManager.addEventListener(window,'resize',function () {\n    that.clientHeight = that.getWorkspaceHeight();\n  });\n}\n\nWalkontableViewport.prototype.getWorkspaceHeight = function () {\n  var scrollHandler = this.instance.wtScrollbars.vertical.scrollHandler;\n  if (scrollHandler === window) {\n    return document.documentElement.clientHeight;\n  }\n  else {\n    var elemHeight = Handsontable.Dom.outerHeight(scrollHandler);\n    var height = (elemHeight > 0 && scrollHandler.clientHeight > 0) ? scrollHandler.clientHeight : Infinity; //returns height without DIV scrollbar\n    return height;\n  }\n};\n\n\nWalkontableViewport.prototype.getWorkspaceWidth = function () {\n  var width;\n\n  var totalColumns = this.instance.getSetting(\"totalColumns\");\n  var scrollHandler = this.instance.wtScrollbars.horizontal.scrollHandler;\n\n  if(Handsontable.freezeOverlays) {\n    width = Math.min(document.documentElement.offsetWidth - this.getWorkspaceOffset().left, document.documentElement.offsetWidth);\n  } else {\n    width = Math.min(this.getContainerFillWidth(), document.documentElement.offsetWidth - this.getWorkspaceOffset().left, document.documentElement.offsetWidth);\n  }\n\n  if (scrollHandler === window && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n    //in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n    //otherwise continue below, which will allow stretching\n    //this is used in `scroll_window.html`\n    //TODO test me\n    return document.documentElement.clientWidth;\n  }\n\n  if (scrollHandler !== window){\n    var overflow = this.instance.wtScrollbars.horizontal.scrollHandler.style.overflow;\n\n    if (overflow == \"scroll\" || overflow == \"hidden\" || overflow == \"auto\") {\n      //this is used in `scroll.html`\n      //TODO test me\n      return Math.max(width, scrollHandler.clientWidth);\n    }\n  }\n\n  //this is used in `stretch.html`, `stretch_window.html`\n  //TODO test me\n  return Math.max(width, Handsontable.Dom.outerWidth(this.instance.wtTable.TABLE));\n};\n\nWalkontableViewport.prototype.sumColumnWidths = function (from, length) {\n  var sum = 0;\n  while(from < length) {\n    sum += this.instance.wtTable.getColumnWidth(from) || this.instance.wtSettings.defaultColumnWidth;\n    from++;\n  }\n  return sum;\n};\nWalkontableViewport.prototype.getContainerFillWidth = function() {\n\n  if(this.containerWidth) {\n    return this.containerWidth;\n  }\n\n  var mainContainer = this.instance.wtTable.holder,\n      fillWidth,\n      dummyElement;\n\n  while(mainContainer.parentNode != document.body && mainContainer.parentNode != null && mainContainer.className.indexOf('handsontable') === -1) {\n    mainContainer = mainContainer.parentNode;\n  }\n\n  dummyElement = document.createElement(\"DIV\");\n  dummyElement.style.width = \"100%\";\n  dummyElement.style.height = \"1px\";\n  mainContainer.appendChild(dummyElement);\n  fillWidth = dummyElement.offsetWidth;\n\n  this.containerWidth = fillWidth;\n\n  mainContainer.removeChild(dummyElement);\n\n  return fillWidth;\n};\n\nWalkontableViewport.prototype.getWorkspaceOffset = function () {\n  return Handsontable.Dom.offset(this.instance.wtTable.TABLE);\n};\n\nWalkontableViewport.prototype.getWorkspaceActualHeight = function () {\n  return Handsontable.Dom.outerHeight(this.instance.wtTable.TABLE);\n};\n\nWalkontableViewport.prototype.getWorkspaceActualWidth = function () {\n  return Handsontable.Dom.outerWidth(this.instance.wtTable.TABLE) || Handsontable.Dom.outerWidth(this.instance.wtTable.TBODY) || Handsontable.Dom.outerWidth(this.instance.wtTable.THEAD); //IE8 reports 0 as <table> offsetWidth;\n};\n\nWalkontableViewport.prototype.getColumnHeaderHeight = function () {\n  if (isNaN(this.columnHeaderHeight)) {\n    this.columnHeaderHeight = Handsontable.Dom.outerHeight(this.instance.wtTable.THEAD);\n  }\n  return this.columnHeaderHeight;\n};\n\nWalkontableViewport.prototype.getViewportHeight = function () {\n\n  var containerHeight = this.getWorkspaceHeight();\n\n  if (containerHeight === Infinity) {\n    return containerHeight;\n  }\n\n  var columnHeaderHeight = this.getColumnHeaderHeight();\n  if (columnHeaderHeight > 0) {\n    containerHeight -= columnHeaderHeight;\n  }\n\n  return containerHeight;\n\n};\n\nWalkontableViewport.prototype.getRowHeaderWidth = function () {\n  if (this.instance.cloneSource) {\n    return this.instance.cloneSource.wtViewport.getRowHeaderWidth();\n  }\n  if (isNaN(this.rowHeaderWidth)) {\n    var rowHeaders = this.instance.getSetting('rowHeaders');\n    if (rowHeaders.length) {\n      var TH = this.instance.wtTable.TABLE.querySelector('TH');\n      this.rowHeaderWidth = 0;\n      for (var i = 0, ilen = rowHeaders.length; i < ilen; i++) {\n        if (TH) {\n          this.rowHeaderWidth += Handsontable.Dom.outerWidth(TH);\n          TH = TH.nextSibling;\n        }\n        else {\n          this.rowHeaderWidth += 50; //yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring. TODO: proper fix\n        }\n      }\n    }\n    else {\n      this.rowHeaderWidth = 0;\n    }\n  }\n  return this.rowHeaderWidth;\n};\n\n// Viewport width = Workspace width - Row Headers width\nWalkontableViewport.prototype.getViewportWidth = function () {\n  var containerWidth = this.getWorkspaceWidth();\n\n  if (containerWidth === Infinity) {\n    return containerWidth;\n  }\n\n  var rowHeaderWidth = this.getRowHeaderWidth();\n  if (rowHeaderWidth > 0) {\n    return containerWidth - rowHeaderWidth;\n  }\n  else {\n    return containerWidth;\n  }\n};\n\n/**\n * Creates:\n *  - rowsRenderCalculator (before draw, to qualify rows for rendering)\n *  - rowsVisibleCalculator (after draw, to measure which rows are actually visible)\n * @returns {WalkontableViewportRowsCalculator}\n */\nWalkontableViewport.prototype.createRowsCalculator = function (visible) {\n  this.rowHeaderWidth = NaN;\n\n  var height;\n  if (this.instance.wtSettings.settings.renderAllRows) {\n    height = Infinity;\n  }\n  else {\n    height = this.getViewportHeight();\n  }\n\n  var pos = this.instance.wtScrollbars.vertical.getScrollPosition() - this.instance.wtScrollbars.vertical.getTableParentOffset();\n  if (pos < 0) {\n    pos = 0;\n  }\n\n  var fixedRowsTop = this.instance.getSetting('fixedRowsTop');\n  if(fixedRowsTop) {\n    var fixedRowsHeight = this.instance.wtScrollbars.vertical.sumCellSizes(0, fixedRowsTop);\n    pos += fixedRowsHeight;\n    height -= fixedRowsHeight;\n  }\n\n  var that = this;\n  return new WalkontableViewportRowsCalculator(\n    height,\n    pos,\n    this.instance.getSetting('totalRows'),\n    function(sourceRow) {\n      return that.instance.wtTable.getRowHeight(sourceRow)\n    },\n    visible ? null : this.instance.wtSettings.settings.viewportRowCalculatorOverride,\n    visible ? true : false\n  );\n};\n\n/**\n * Creates:\n *  - columnsRenderCalculator (before draw, to qualify columns for rendering)\n *  - columnsVisibleCalculator (after draw, to measure which columns are actually visible)\n * @returns {WalkontableViewportRowsCalculator}\n */\nWalkontableViewport.prototype.createColumnsCalculator = function (visible) {\n  this.columnHeaderHeight = NaN;\n\n  var width = this.getViewportWidth();\n\n  var pos = this.instance.wtScrollbars.horizontal.getScrollPosition() - this.instance.wtScrollbars.vertical.getTableParentOffset();\n  if (pos < 0) {\n    pos = 0;\n  }\n\n  var fixedColumnsLeft = this.instance.getSetting('fixedColumnsLeft');\n  if(fixedColumnsLeft) {\n    var fixedColumnsWidth = this.instance.wtScrollbars.horizontal.sumCellSizes(0, fixedColumnsLeft);\n    pos += fixedColumnsWidth;\n    width -= fixedColumnsWidth;\n  }\n\n  var that = this;\n  return new WalkontableViewportColumnsCalculator(\n    width,\n    pos,\n    this.instance.getSetting('totalColumns'),\n    function (sourceCol) {\n      return that.instance.wtTable.getColumnWidth(sourceCol);\n    },\n    visible ? null : this.instance.wtSettings.settings.viewportColumnCalculatorOverride,\n    visible ? true : false,\n    this.instance.getSetting('stretchH')\n  )\n};\n\n\n/**\n * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and cols should be rendered)\n * @param fastDraw {Boolean} If TRUE, will try to avoid full redraw and only update the border positions. If FALSE or UNDEFINED, will perform a full redraw\n */\nWalkontableViewport.prototype.createRenderCalculators = function (fastDraw) {\n  if (fastDraw) {\n    var proposedRowsVisibleCalculator = this.createRowsCalculator(true);\n    var proposedColumnsVisibleCalculator = this.createColumnsCalculator(true);\n    if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) ) ) {\n      fastDraw = false;\n    }\n  }\n\n  if(!fastDraw) {\n    this.rowsRenderCalculator = this.createRowsCalculator();\n    this.columnsRenderCalculator = this.createColumnsCalculator();\n  }\n\n  this.rowsVisibleCalculator = null; //delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\n  this.columnsVisibleCalculator = null;\n\n  return fastDraw;\n};\n\n/**\n * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are the actually visible rows and columns)\n */\nWalkontableViewport.prototype.createVisibleCalculators = function () {\n  this.rowsVisibleCalculator = this.createRowsCalculator(true);\n  this.columnsVisibleCalculator = this.createColumnsCalculator(true);\n};\n\n/**\n * Returns information whether proposedRowsVisibleCalculator viewport\n * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator)\n *\n * Returns TRUE if all proposed visible rows are already rendered (meaning: redraw is not needed)\n * Returns FALSE if at least one proposed visible row is not already rendered (meaning: redraw is needed)\n *\n * @returns {boolean}\n */\nWalkontableViewport.prototype.areAllProposedVisibleRowsAlreadyRendered = function (proposedRowsVisibleCalculator) {\n  if (this.rowsVisibleCalculator) {\n    if (proposedRowsVisibleCalculator.startRow < this.rowsRenderCalculator.startRow || (proposedRowsVisibleCalculator.startRow === this.rowsRenderCalculator.startRow && proposedRowsVisibleCalculator.startRow > 0)) {\n      return false;\n    }\n    else if (proposedRowsVisibleCalculator.endRow > this.rowsRenderCalculator.endRow || (proposedRowsVisibleCalculator.endRow === this.rowsRenderCalculator.endRow && proposedRowsVisibleCalculator.endRow < this.instance.getSetting('totalRows') - 1)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns information whether proposedColumnsVisibleCalculator viewport\n * is contained inside column rendered in previous draw (cached in columnsRenderCalculator)\n *\n * Returns TRUE if all proposed visible columns are already rendered (meaning: redraw is not needed)\n * Returns FALSE if at least one proposed visible column is not already rendered (meaning: redraw is needed)\n *\n * @returns {boolean}\n */\nWalkontableViewport.prototype.areAllProposedVisibleColumnsAlreadyRendered = function (proposedColumnsVisibleCalculator) {\n  if (this.columnsVisibleCalculator) {\n    if (proposedColumnsVisibleCalculator.startColumn < this.columnsRenderCalculator.startColumn || (proposedColumnsVisibleCalculator.startColumn === this.columnsRenderCalculator.startColumn && proposedColumnsVisibleCalculator.startColumn > 0)) {\n      return false;\n    }\n    else if (proposedColumnsVisibleCalculator.endColumn > this.columnsRenderCalculator.endColumn || (proposedColumnsVisibleCalculator.endColumn === this.columnsRenderCalculator.endColumn && proposedColumnsVisibleCalculator.endColumn < this.instance.getSetting('totalColumns') - 1)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n  return false;\n};\n\nfunction WalkontableViewportColumnsCalculator (width, scrollOffset, totalColumns, columnWidthFn, overrideFn, onlyFullyVisible, stretchH) {\n  this.scrollOffset = scrollOffset;\n  this.startColumn = null;\n  this.endColumn = null;\n  this.startPosition = null;\n  this.count = 0;\n  this.stretchAllRatio = 0;\n  this.stretchLastWidth = 0;\n  this.stretch = stretchH;\n\n\n  var i;\n  var sum = 0;\n  var columnWidth;\n  var needReverse = true;\n  var defaultColumnWidth = 50;\n  var startPositions = [];\n\n  var ratio = 1;\n\n  var getColumnWidth = function (i) {\n    ratio = ratio || 1;\n    var width = columnWidthFn(i);\n    if (width === undefined) {\n      width = defaultColumnWidth ;\n    }\n    return width;\n  };\n\n  this.refreshStretching = function (width) {\n    var columnWidth;\n    var sumAll = 0;\n\n    for(var i = 0; i < totalColumns; i++) {\n      columnWidth = getColumnWidth(i);\n      sumAll +=columnWidth;\n    }\n\n    var remainingSize = sumAll - width;\n    if (this.stretch === 'all' && remainingSize < 0){\n      this.stretchAllRatio = width / sumAll;\n    } else if (this.stretch === 'last' && width !== Infinity) {\n      this.stretchLastWidth = -remainingSize + getColumnWidth(totalColumns-1);\n    }\n  };\n\n\n  for (i = 0; i< totalColumns; i++) {\n    columnWidth = getColumnWidth(i);\n\n    if (sum <= scrollOffset && !onlyFullyVisible){\n      this.startColumn = i;\n    }\n\n    if (sum >= scrollOffset && sum + columnWidth <= scrollOffset + width) {\n      if (this.startColumn == null) {\n        this.startColumn = i;\n      }\n      this.endColumn = i;\n    }\n    startPositions.push(sum);\n    sum += columnWidth;\n    if(!onlyFullyVisible) {\n      this.endColumn = i;\n    }\n\n    if(sum >= scrollOffset + width) {\n      needReverse = false;\n      break;\n    }\n  }\n\n  if (this.endColumn == totalColumns - 1 && needReverse) {\n    this.startColumn = this.endColumn;\n    while(this.startColumn > 0) {\n      var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];\n      if (viewportSum <= width || !onlyFullyVisible) {\n        this.startColumn--;\n      }\n      if (viewportSum > width) {\n        break;\n      }\n    }\n  }\n\n  if (this.startColumn !== null && overrideFn){\n    overrideFn(this);\n  }\n\n  this.startPosition = startPositions[this.startColumn];\n  if (this.startPosition == void 0) {\n    this.startPosition = null;\n  }\n\n  if (this.startColumn != null) {\n    this.count = this.endColumn - this.startColumn + 1;\n  }\n}\n\n\n/**\n * Viewport calculator constructor. Calculates indexes of rows to render OR rows that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * Object properties:\n *   this.scrollOffset - position of vertical scroll (in px)\n *   this.startRow - index of the first rendered/visible row (can be overwritten using overrideFn)\n *   this.startPosition - position of the first rendered/visible row (in px)\n *   this.endRow - index of the last rendered/visible row (can be overwritten using overrideFn)\n *   this.count - number of rendered/visible rows\n *\n * @param height - height of the viewport\n * @param scrollOffset - current vertical scroll position of the viewport\n * @param totalRows - total number of rows\n * @param rowHeightFn - function that returns the height of the row at a given index (in px)\n * @param overrideFn - function that changes calculated this.startRow, this.endRow (used by mergeCells.js plugin)\n * @param onlyFullyVisible {bool} - if TRUE, only startRow and endRow will be indexes of rows that are FULLY in viewport\n * @constructor\n */\nfunction WalkontableViewportRowsCalculator(height, scrollOffset, totalRows, rowHeightFn, overrideFn, onlyFullyVisible) {\n  this.scrollOffset = scrollOffset;\n  this.startRow = null;\n  this.startPosition = null;\n  this.endRow = null;\n  this.count = 0;\n  var sum = 0;\n  var rowHeight;\n  var needReverse = true;\n  var defaultRowHeight = 23;\n  var startPositions = [];\n  for (var i = 0; i < totalRows; i++) {\n    rowHeight = rowHeightFn(i);\n    if (rowHeight === undefined) {\n      rowHeight = defaultRowHeight;\n    }\n    if (sum <= scrollOffset && !onlyFullyVisible) {\n      this.startRow = i;\n    }\n    if (sum >= scrollOffset && sum + rowHeight <= scrollOffset + height) {\n      if (this.startRow == null) {\n        this.startRow = i;\n      }\n      this.endRow = i;\n    }\n    startPositions.push(sum);\n    sum += rowHeight;\n    if(!onlyFullyVisible) {\n      this.endRow = i;\n    }\n    if (sum >= scrollOffset + height) {\n      needReverse = false;\n      break;\n    }\n  }\n\n  //If the rendering has reached the last row and there is still some space available in the viewport, we need to render in reverse in order to fill the whole viewport with rows\n  if (this.endRow == totalRows - 1 && needReverse) {\n    this.startRow = this.endRow;\n    while(this.startRow > 0) {\n      var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1]; //rowHeight is the height of the last row\n      if (viewportSum <= height || !onlyFullyVisible)\n      {\n        this.startRow--;\n      }\n      if (viewportSum >= height)\n      {\n       break;\n      }\n    }\n  }\n\n  if (this.startRow !== null && overrideFn) {\n    overrideFn(this);\n  }\n\n  this.startPosition = startPositions[this.startRow];\n  if (this.startPosition == void 0) {\n    this.startPosition = null;\n  }\n\n  if (this.startRow != null) {\n    this.count = this.endRow - this.startRow + 1;\n  }\n}\n\nif (window.jQuery) {\n  (function (window, $, Handsontable) {\n    $.fn.handsontable = function (action) {\n      var i\n        , ilen\n        , args\n        , output\n        , userSettings\n        , $this = this.first() // Use only first element from list\n        , instance = $this.data('handsontable');\n\n      // Init case\n      if (typeof action !== 'string') {\n        userSettings = action || {};\n        if (instance) {\n          instance.updateSettings(userSettings);\n        }\n        else {\n          instance = new Handsontable.Core($this[0], userSettings);\n          $this.data('handsontable', instance);\n          instance.init();\n        }\n\n        return $this;\n      }\n      // Action case\n      else {\n        args = [];\n        if (arguments.length > 1) {\n          for (i = 1, ilen = arguments.length; i < ilen; i++) {\n            args.push(arguments[i]);\n          }\n        }\n\n        if (instance) {\n          if (typeof instance[action] !== 'undefined') {\n            output = instance[action].apply(instance, args);\n\n            if (action === 'destroy'){\n              $this.removeData();\n            }\n          }\n          else {\n            throw new Error('Handsontable do not provide action: ' + action);\n          }\n        }\n\n        return output;\n      }\n    };\n  })(window, jQuery, Handsontable);\n}\n\n\n\n})(window, Handsontable);\n\n/*!\n * numeral.js\n * version : 1.5.3\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function () {\n\n    /************************************\n        Constants\n    ************************************/\n\n    var numeral,\n        VERSION = '1.5.3',\n        // internal storage for language config files\n        languages = {},\n        currentLanguage = 'en',\n        zeroFormat = null,\n        defaultFormat = '0,0',\n        // check for nodeJS\n        hasModule = (typeof module !== 'undefined' && module.exports);\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n\n    // Numeral prototype object\n    function Numeral (number) {\n        this._value = number;\n    }\n\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed (value, precision, roundingFunction, optionals) {\n        var power = Math.pow(10, precision),\n            optionalsRegExp,\n            output;\n            \n        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\n        // Multiply up by precision, round accurately, then divide and use native toFixed():\n        output = (roundingFunction(value * power) / power).toFixed(precision);\n\n        if (optionals) {\n            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n\n        return output;\n    }\n\n    /************************************\n        Formatting\n    ************************************/\n\n    // determine what type of formatting we need to do\n    function formatNumeral (n, format, roundingFunction) {\n        var output;\n\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(n, format, roundingFunction);\n        } else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(n, format, roundingFunction);\n        } else if (format.indexOf(':') > -1) { // time\n            output = formatTime(n, format);\n        } else { // plain ol' numbers or bytes\n            output = formatNumber(n._value, format, roundingFunction);\n        }\n\n        // return string\n        return output;\n    }\n\n    // revert to number\n    function unformatNumeral (n, string) {\n        var stringOriginal = string,\n            thousandRegExp,\n            millionRegExp,\n            billionRegExp,\n            trillionRegExp,\n            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n            bytesMultiplier = false,\n            power;\n\n        if (string.indexOf(':') > -1) {\n            n._value = unformatTime(string);\n        } else {\n            if (string === zeroFormat) {\n                n._value = 0;\n            } else {\n                if (languages[currentLanguage].delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');\n                }\n\n                // see if abbreviations are there so that we can multiply to the correct number\n                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n\n                // see if bytes are there so that we can multiply to the correct number\n                for (power = 0; power <= suffixes.length; power++) {\n                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;\n\n                    if (bytesMultiplier) {\n                        break;\n                    }\n                }\n\n                // do some math to create our number\n                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\\.]+/g, ''));\n\n                // round if we are talking about bytes\n                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;\n            }\n        }\n        return n._value;\n    }\n\n    function formatCurrency (n, format, roundingFunction) {\n        var symbolIndex = format.indexOf('$'),\n            openParenIndex = format.indexOf('('),\n            minusSignIndex = format.indexOf('-'),\n            space = '',\n            spliceIndex,\n            output;\n\n        // check for space before or after currency\n        if (format.indexOf(' $') > -1) {\n            space = ' ';\n            format = format.replace(' $', '');\n        } else if (format.indexOf('$ ') > -1) {\n            space = ' ';\n            format = format.replace('$ ', '');\n        } else {\n            format = format.replace('$', '');\n        }\n\n        // format the number\n        output = formatNumber(n._value, format, roundingFunction);\n\n        // position the symbol\n        if (symbolIndex <= 1) {\n            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                output = output.split('');\n                spliceIndex = 1;\n                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){\n                    // the symbol appears before the \"(\" or \"-\"\n                    spliceIndex = 0;\n                }\n                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);\n                output = output.join('');\n            } else {\n                output = languages[currentLanguage].currency.symbol + space + output;\n            }\n        } else {\n            if (output.indexOf(')') > -1) {\n                output = output.split('');\n                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);\n                output = output.join('');\n            } else {\n                output = output + space + languages[currentLanguage].currency.symbol;\n            }\n        }\n\n        return output;\n    }\n\n    function formatPercentage (n, format, roundingFunction) {\n        var space = '',\n            output,\n            value = n._value * 100;\n\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        } else {\n            format = format.replace('%', '');\n        }\n\n        output = formatNumber(value, format, roundingFunction);\n        \n        if (output.indexOf(')') > -1 ) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        } else {\n            output = output + space + '%';\n        }\n\n        return output;\n    }\n\n    function formatTime (n) {\n        var hours = Math.floor(n._value/60/60),\n            minutes = Math.floor((n._value - (hours * 60 * 60))/60),\n            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);\n    }\n\n    function unformatTime (string) {\n        var timeArray = string.split(':'),\n            seconds = 0;\n        // turn hours and minutes into seconds and add them all up\n        if (timeArray.length === 3) {\n            // hours\n            seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n            // minutes\n            seconds = seconds + (Number(timeArray[1]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[2]);\n        } else if (timeArray.length === 2) {\n            // minutes\n            seconds = seconds + (Number(timeArray[0]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[1]);\n        }\n        return Number(seconds);\n    }\n\n    function formatNumber (value, format, roundingFunction) {\n        var negP = false,\n            signed = false,\n            optDec = false,\n            abbr = '',\n            abbrK = false, // force abbreviation to thousands\n            abbrM = false, // force abbreviation to millions\n            abbrB = false, // force abbreviation to billions\n            abbrT = false, // force abbreviation to trillions\n            abbrForce = false, // force abbreviation\n            bytes = '',\n            ord = '',\n            abs = Math.abs(value),\n            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n            min,\n            max,\n            power,\n            w,\n            precision,\n            thousands,\n            d = '',\n            neg = false;\n\n        // check if number is zero and a custom zero format has been set\n        if (value === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        } else {\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (format.indexOf('(') > -1) {\n                negP = true;\n                format = format.slice(1, -1);\n            } else if (format.indexOf('+') > -1) {\n                signed = true;\n                format = format.replace(/\\+/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (format.indexOf('a') > -1) {\n                // check if abbreviation is specified\n                abbrK = format.indexOf('aK') >= 0;\n                abbrM = format.indexOf('aM') >= 0;\n                abbrB = format.indexOf('aB') >= 0;\n                abbrT = format.indexOf('aT') >= 0;\n                abbrForce = abbrK || abbrM || abbrB || abbrT;\n\n                // check for space before abbreviation\n                if (format.indexOf(' a') > -1) {\n                    abbr = ' ';\n                    format = format.replace(' a', '');\n                } else {\n                    format = format.replace('a', '');\n                }\n\n                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n                    // trillion\n                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;\n                    value = value / Math.pow(10, 12);\n                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n                    // billion\n                    abbr = abbr + languages[currentLanguage].abbreviations.billion;\n                    value = value / Math.pow(10, 9);\n                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n                    // million\n                    abbr = abbr + languages[currentLanguage].abbreviations.million;\n                    value = value / Math.pow(10, 6);\n                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n                    // thousand\n                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;\n                    value = value / Math.pow(10, 3);\n                }\n            }\n\n            // see if we are formatting bytes\n            if (format.indexOf('b') > -1) {\n                // check for space before\n                if (format.indexOf(' b') > -1) {\n                    bytes = ' ';\n                    format = format.replace(' b', '');\n                } else {\n                    format = format.replace('b', '');\n                }\n\n                for (power = 0; power <= suffixes.length; power++) {\n                    min = Math.pow(1024, power);\n                    max = Math.pow(1024, power+1);\n\n                    if (value >= min && value < max) {\n                        bytes = bytes + suffixes[power];\n                        if (min > 0) {\n                            value = value / min;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // see if ordinal is wanted\n            if (format.indexOf('o') > -1) {\n                // check for space before\n                if (format.indexOf(' o') > -1) {\n                    ord = ' ';\n                    format = format.replace(' o', '');\n                } else {\n                    format = format.replace('o', '');\n                }\n\n                ord = ord + languages[currentLanguage].ordinal(value);\n            }\n\n            if (format.indexOf('[.]') > -1) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            w = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n\n            if (precision) {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    d = toFixed(value, precision.length, roundingFunction);\n                }\n\n                w = d.split('.')[0];\n\n                if (d.split('.')[1].length) {\n                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];\n                } else {\n                    d = '';\n                }\n\n                if (optDec && Number(d.slice(1)) === 0) {\n                    d = '';\n                }\n            } else {\n                w = toFixed(value, null, roundingFunction);\n            }\n\n            // format number\n            if (w.indexOf('-') > -1) {\n                w = w.slice(1);\n                neg = true;\n            }\n\n            if (thousands > -1) {\n                w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                w = '';\n            }\n\n            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');\n        }\n    }\n\n    /************************************\n        Top Level Functions\n    ************************************/\n\n    numeral = function (input) {\n        if (numeral.isNumeral(input)) {\n            input = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            input = 0;\n        } else if (!Number(input)) {\n            input = numeral.fn.unformat(input);\n        }\n\n        return new Numeral(Number(input));\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function (obj) {\n        return obj instanceof Numeral;\n    };\n\n    // This function will load languages and then set the global language.  If\n    // no arguments are passed in, it will simply return the current global\n    // language key.\n    numeral.language = function (key, values) {\n        if (!key) {\n            return currentLanguage;\n        }\n\n        if (key && !values) {\n            if(!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            currentLanguage = key;\n        }\n\n        if (values || !languages[key]) {\n            loadLanguage(key, values);\n        }\n\n        return numeral;\n    };\n    \n    // This function provides access to the loaded language data.  If\n    // no arguments are passed in, it will simply return the current\n    // global language object.\n    numeral.languageData = function (key) {\n        if (!key) {\n            return languages[currentLanguage];\n        }\n        \n        if (!languages[key]) {\n            throw new Error('Unknown language : ' + key);\n        }\n        \n        return languages[key];\n    };\n\n    numeral.language('en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function (number) {\n            var b = number % 10;\n            return (~~ (number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    numeral.zeroFormat = function (format) {\n        zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function (format) {\n        defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    /************************************\n        Helpers\n    ************************************/\n\n    function loadLanguage(key, values) {\n        languages[key] = values;\n    }\n\n    /************************************\n        Floating-point helpers\n    ************************************/\n\n    // The floating-point helper functions and implementation\n    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/\n\n    /**\n     * Array.prototype.reduce for browsers that don't support it\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility\n     */\n    if ('function' !== typeof Array.prototype.reduce) {\n        Array.prototype.reduce = function (callback, opt_initialValue) {\n            'use strict';\n            \n            if (null === this || 'undefined' === typeof this) {\n                // At the moment all modern browsers, that support strict mode, have\n                // native implementation of Array.prototype.reduce. For instance, IE8\n                // does not support strict mode, so this check is actually useless.\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n            \n            if ('function' !== typeof callback) {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var index,\n                value,\n                length = this.length >>> 0,\n                isValueSet = false;\n\n            if (1 < arguments.length) {\n                value = opt_initialValue;\n                isValueSet = true;\n            }\n\n            for (index = 0; length > index; ++index) {\n                if (this.hasOwnProperty(index)) {\n                    if (isValueSet) {\n                        value = callback(value, this[index], index, this);\n                    } else {\n                        value = this[index];\n                        isValueSet = true;\n                    }\n                }\n            }\n\n            if (!isValueSet) {\n                throw new TypeError('Reduce of empty array with no initial value');\n            }\n\n            return value;\n        };\n    }\n\n    \n    /**\n     * Computes the multiplier necessary to make x >= 1,\n     * effectively eliminating miscalculations caused by\n     * finite precision.\n     */\n    function multiplier(x) {\n        var parts = x.toString().split('.');\n        if (parts.length < 2) {\n            return 1;\n        }\n        return Math.pow(10, parts[1].length);\n    }\n\n    /**\n     * Given a variable number of arguments, returns the maximum\n     * multiplier that must be used to normalize an operation involving\n     * all of them.\n     */\n    function correctionFactor() {\n        var args = Array.prototype.slice.call(arguments);\n        return args.reduce(function (prev, next) {\n            var mp = multiplier(prev),\n                mn = multiplier(next);\n        return mp > mn ? mp : mn;\n        }, -Infinity);\n    }        \n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n\n    numeral.fn = Numeral.prototype = {\n\n        clone : function () {\n            return numeral(this);\n        },\n\n        format : function (inputString, roundingFunction) {\n            return formatNumeral(this, \n                  inputString ? inputString : defaultFormat, \n                  (roundingFunction !== undefined) ? roundingFunction : Math.round\n              );\n        },\n\n        unformat : function (inputString) {\n            if (Object.prototype.toString.call(inputString) === '[object Number]') { \n                return inputString; \n            }\n            return unformatNumeral(this, inputString ? inputString : defaultFormat);\n        },\n\n        value : function () {\n            return this._value;\n        },\n\n        valueOf : function () {\n            return this._value;\n        },\n\n        set : function (value) {\n            this._value = Number(value);\n            return this;\n        },\n\n        add : function (value) {\n            var corrFactor = correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum + corrFactor * curr;\n            }\n            this._value = [this._value, value].reduce(cback, 0) / corrFactor;\n            return this;\n        },\n\n        subtract : function (value) {\n            var corrFactor = correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum - corrFactor * curr;\n            }\n            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            \n            return this;\n        },\n\n        multiply : function (value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = correctionFactor(accum, curr);\n                return (accum * corrFactor) * (curr * corrFactor) /\n                    (corrFactor * corrFactor);\n            }\n            this._value = [this._value, value].reduce(cback, 1);\n            return this;\n        },\n\n        divide : function (value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = correctionFactor(accum, curr);\n                return (accum * corrFactor) / (curr * corrFactor);\n            }\n            this._value = [this._value, value].reduce(cback);            \n            return this;\n        },\n\n        difference : function (value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n\n    };\n\n    /************************************\n        Exposing Numeral\n    ************************************/\n\n    // CommonJS module is defined\n    if (hasModule) {\n        module.exports = numeral;\n    }\n\n    /*global ender:false */\n    if (typeof ender === 'undefined') {\n        // here, `this` means `window` in the browser, or `global` on the server\n        // add `numeral` as a global object via a string identifier,\n        // for Closure Compiler 'advanced' mode\n        this['numeral'] = numeral;\n    }\n\n    /*global define:false */\n    if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return numeral;\n        });\n    }\n}).call(this);\n"]}